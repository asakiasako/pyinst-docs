{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs \u00a4 For full documentation visit mkdocs.org . Commands \u00a4 mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout \u00a4 mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Overview"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"changelog/","text":"","title":"Changelog"},{"location":"extend/","text":"","title":"Extend"},{"location":"usage/","text":"","title":"Usage"},{"location":"api/abc/","text":"This module provides abstract base classes to describe different kinds of instruments. BaseInstrument is the base class of all the Instrument Model classes. VisaInstrument and RawSerialInstrument are classes based on BaseInstrument to describe VISA compliant instruments and serial-port based instruments. There are many other abstract classes to describe a kind of instrument that has some particular functions. For example, OpticalFrequencySetter defines the interfaces of an instrument which has optical frequency/wavelength setting function. Among these ABCs are Instrument Type classes. An Instrument Type class defines the interfaces of a specific instrument type. It always starts with a prefix Type , for example, TypeVOA or TypeOPM . An Instrument Model class will inherit at least one of these Instrument Type classes, and implement the abstract methods inherited. So the interfaces of the same type of instruments can be unified. Besides the standard methods defined by the Instrument Type class, a Instrument Model class may also define its unique methods. InstrumentMeta \u00a4 Bases: ABCMeta The meta class of BaseInstrument. ins_type () property \u00a4 The instrument type flag of the specific instrument model. Source code in pyinst\\abc.py 50 51 52 53 54 55 56 @property def ins_type ( cls : type ) -> InstrumentType : \"\"\"The instrument type flag of the specific instrument model.\"\"\" value = 0 for base in cls . mro ()[ 2 :]: value |= getattr ( base , 'ins_type' , 0 ) return value BaseInstrument ( resource_name ) \u00a4 ABC of all the instrument model classes. Parameters: Name Type Description Default resource_name str The instrument resource name. Please refer to resource_name property for more information. required Source code in pyinst\\abc.py 117 118 119 120 121 122 123 124 def __init__ ( self , resource_name : str ): \"\"\" Args: resource_name: The instrument resource name. Please refer to `resource_name` property for more information. \"\"\" self . __resource_name = resource_name super ( BaseInstrument , self ) . __init__ () brand () property abstractmethod \u00a4 The brand/manufactory of the instrument. Source code in pyinst\\abc.py 62 63 64 65 @property @abstractmethod def brand ( self ) -> str : \"\"\"The brand/manufactory of the instrument.\"\"\" model () property abstractmethod \u00a4 The model name of the instrument. Source code in pyinst\\abc.py 67 68 69 70 @property @abstractmethod def model ( self ) -> str : \"\"\"The model name of the instrument.\"\"\" details () property \u00a4 A map of information to describe the instrument. Source code in pyinst\\abc.py 72 73 74 75 76 77 @property def details ( self ) -> Mapping [ str , str ]: \"\"\" A map of information to describe the instrument. \"\"\" return {} params () property \u00a4 A list of dict to define parameters required for object creation. This is mainly used for upper level (e.g. GUI) to render options. dict fields: name (str) : Required. The name of the param, exactly the same in __init__ method. type (str) : Required. options: int | str | bool . options (list) : Optional. Valid options. min (int) : Optional. For type int only. max (int) : Optional. For type int only. Examples: [ { \"name\" : \"slot\" , \"type\" : \"int\" , \"min\" : 1 , \"max\" : 10 }, { \"name\" : \"range_level\" , \"type\" : \"str\" , \"options\" : [ \"HIGH\" , \"LOW\" ] } ] Source code in pyinst\\abc.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 @property def params ( self ) -> List [ dict ]: \"\"\" A list of dict to define parameters required for object creation. This is mainly used for upper level (e.g. GUI) to render options. dict fields: - `name (str)`: Required. The name of the param, exactly the same in `__init__` method. - `type (str)`: Required. options: `int` | `str` | `bool`. - `options (list)`: Optional. Valid options. + `min (int)`: Optional. For type `int` only. + `max (int)`: Optional. For type `int` only. Examples: ``` python [ { \"name\": \"slot\", \"type\": \"int\", \"min\": 1, \"max\": 10 }, { \"name\": \"range_level\", \"type\": \"str\", \"options\": [\"HIGH\", \"LOW\"] } ] ``` \"\"\" close () abstractmethod \u00a4 Release the instrument resource. Source code in pyinst\\abc.py 139 140 141 @abstractmethod def close ( self ) -> None : \"\"\"Release the instrument resource.\"\"\" resource_name () property \u00a4 For VISA compliant instruments, it is the resource name or alias of the VISA resource. For other instruments connected with serial port, it is the port name. For other instruments connected with USB, it is the S/N of the instrument or USB chip. Source code in pyinst\\abc.py 143 144 145 146 147 148 149 150 151 152 153 @property def resource_name ( self ) -> str : \"\"\" - For VISA compliant instruments, it is the resource name or alias of the VISA resource. - For other instruments connected with serial port, it is the port name. - For other instruments connected with USB, it is the S/N of the instrument or USB chip. \"\"\" return self . __resource_name create ( * args , ** kwargs ) classmethod \u00a4 Create an instance of the instrument model. If an exception is raised during the instance creation, return None. Parameters: Name Type Description Default *args Directly passed to the instrument model class. () **kwargs Directly passed to the instrument model class. {} Returns: Type Description Optional [ Self ] The created instrument model class, or None if creation failed. Source code in pyinst\\abc.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 @classmethod def create ( cls , * args , ** kwargs ) -> Optional [ Self ]: \"\"\"Create an instance of the instrument model. If an exception is raised during the instance creation, return None. Args: *args: Directly passed to the instrument model class. **kwargs: Directly passed to the instrument model class. Returns: The created instrument model class, or None if creation failed. \"\"\" try : instance = cls ( * args , ** kwargs ) except : instance = None return instance VisaInstrument ( resource_name , read_termination = VI_READ_TERMINATION , write_termination = VI_WRITE_TERMINATION , timeout = VI_TIMEOUT , open_timeout = VI_OPEN_TIMEOUT , query_delay = VI_QUERY_DELAY , encoding = 'ascii' , ** kwargs ) \u00a4 Bases: BaseInstrument Base class of VISA compliant instruments that use message based communication. VisaInstrument creates a proxy object with pyvisa to communicate with VISA compliant instruments. Refer to PyVISA Documents for more information. Parameters: Name Type Description Default resource_name str Resource name or alias of the VISA resource to open. required read_termination str Read termination character. VI_READ_TERMINATION write_termination str Write termination character. VI_WRITE_TERMINATION timeout int Timeout in milliseconds for all resource I/O operations. VI_TIMEOUT open_timeout int If the access_mode parameter requests a lock, then this parameter specifies the absolute time period (in milliseconds) that the resource waits to get unlocked before this operation returns an error. VI_OPEN_TIMEOUT query_delay float Delay in seconds between write and read operations. VI_QUERY_DELAY encoding str Encoding used for read and write operations. 'ascii' **kwargs directly passed to rm.open_resource {} Source code in pyinst\\abc.py 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 def __init__ ( self , resource_name : str , read_termination : str = VI_READ_TERMINATION , write_termination : str = VI_WRITE_TERMINATION , timeout : int = VI_TIMEOUT , open_timeout : int = VI_OPEN_TIMEOUT , query_delay : float = VI_QUERY_DELAY , encoding : str = \"ascii\" , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. read_termination: Read termination character. write_termination: Write termination character. timeout: Timeout in milliseconds for all resource I/O operations. open_timeout: If the access_mode parameter requests a lock, then this parameter specifies the absolute time period (in milliseconds) that the resource waits to get unlocked before this operation returns an error. query_delay: Delay in seconds between write and read operations. encoding: Encoding used for read and write operations. **kwargs: directly passed to `rm.open_resource` \"\"\" super () . __init__ ( resource_name = resource_name ) rm = pyvisa . ResourceManager () self . _inst : pyvisa . resources . MessageBasedResource = rm . open_resource ( resource_name , read_termination = read_termination , write_termination = write_termination , open_timeout = open_timeout , timeout = timeout , query_delay = query_delay , encoding = encoding , ** kwargs ) self . _check_communication () resource_name () property \u00a4 Resource name or alias of the VISA resource. Source code in pyinst\\abc.py 237 238 239 240 @property def resource_name ( self ) -> str : \"\"\"Resource name or alias of the VISA resource.\"\"\" return self . __resource_name resource_info () property \u00a4 Get the (extended) information of the VISA resource. Source code in pyinst\\abc.py 242 243 244 245 @property def resource_info ( self ) -> pyvisa . highlevel . ResourceInfo : \"\"\"Get the (extended) information of the VISA resource.\"\"\" return self . _inst . resource_info idn () property \u00a4 Returns a string that uniquely identifies the instrument. Source code in pyinst\\abc.py 247 248 249 250 @property def idn ( self ) -> str : \"\"\"Returns a string that uniquely identifies the instrument.\"\"\" return self . query ( '*IDN?' ) opc () property \u00a4 Operation complete query. Source code in pyinst\\abc.py 252 253 254 255 @property def opc ( self ) -> str : \"\"\"Operation complete query.\"\"\" return self . query ( '*OPC?' ) close () \u00a4 Closes the VISA session and marks the handle as invalid. Source code in pyinst\\abc.py 257 258 259 260 261 def close ( self ) -> None : \"\"\" Closes the VISA session and marks the handle as invalid. \"\"\" self . _inst . close () command ( message ) \u00a4 Write a VISA command without read back. Alias of write(message). Parameters: Name Type Description Default message str The message to be sent. required Returns: Type Description int Number of bytes written. Source code in pyinst\\abc.py 276 277 278 279 280 281 282 283 284 285 286 287 288 def command ( self , message : str ) -> int : \"\"\" Write a VISA command without read back. Alias of write(message). Args: message: The message to be sent. Returns: Number of bytes written. \"\"\" return self . write ( message ) write ( message , termination = None , encoding = None ) \u00a4 Write a string message to the device. The write_termination is always appended to it. Parameters: Name Type Description Default message str The message to be sent. required termination Optional [ str ] Alternative character termination to use. If None, the value of write_termination passed to __init__ method is used. Defaults to None. None encoding Optional [ str ] Alternative encoding to use to turn str into bytes. If None, the value of encoding passed to __init__ method is used. Defaults to None. None Returns: Type Description int Number of bytes written. Source code in pyinst\\abc.py 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 def write ( self , message : str , termination : Optional [ str ] = None , encoding : Optional [ str ] = None , ) -> int : \"\"\"Write a string message to the device. The write_termination is always appended to it. Args: message: The message to be sent. termination: Alternative character termination to use. If None, the value of write_termination passed to `__init__` method is used. Defaults to None. encoding: Alternative encoding to use to turn str into bytes. If None, the value of encoding passed to `__init__` method is used. Defaults to None. Returns: Number of bytes written. \"\"\" return self . _inst . write ( message , termination , encoding ) read ( termination = None , encoding = None ) \u00a4 Read a string from the device. Reading stops when the device stops sending (e.g. by setting appropriate bus lines), or the termination characters sequence was detected. Attention: Only the last character of the termination characters is really used to stop reading, however, the whole sequence is compared to the ending of the read string message. If they don't match, a warning is issued. Parameters: Name Type Description Default termination Optional [ str ] Alternative character termination to use. If None, the value of write_termination passed to __init__ method is used. Defaults to None. None encoding Optional [ str ] Alternative encoding to use to turn bytes into str. If None, the value of encoding passed to __init__ method is used. Defaults to None. None Returns: Type Description str Message read from the instrument and decoded. Source code in pyinst\\abc.py 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 def read ( self , termination : Optional [ str ] = None , encoding : Optional [ str ] = None ) -> str : \"\"\"Read a string from the device. Reading stops when the device stops sending (e.g. by setting appropriate bus lines), or the termination characters sequence was detected. Attention: Only the last character of the termination characters is really used to stop reading, however, the whole sequence is compared to the ending of the read string message. If they don't match, a warning is issued. Args: termination: Alternative character termination to use. If None, the value of write_termination passed to `__init__` method is used. Defaults to None. encoding: Alternative encoding to use to turn bytes into str. If None, the value of encoding passed to `__init__` method is used. Defaults to None. Returns: Message read from the instrument and decoded. \"\"\" return self . _inst . read ( termination , encoding ) query ( message , delay = None ) \u00a4 A combination of write(message) and read() Parameters: Name Type Description Default message str The message to send. required delay Optional [ float ] Delay in seconds between write and read operations. If None, defaults to query_delay passed to __init__ method. None Returns: Type Description str Answer from the device. Source code in pyinst\\abc.py 339 340 341 342 343 344 345 346 347 348 349 350 351 def query ( self , message : str , delay : Optional [ float ] = None ) -> str : \"\"\"A combination of write(message) and read() Args: message: The message to send. delay: Delay in seconds between write and read operations. If None, defaults to query_delay passed to `__init__` method. Returns: Answer from the device. \"\"\" return self . _inst . query ( message , delay ) read_binary_values ( datatype = 'f' , is_big_endian = False , container = list , header_fmt = 'ieee' , expect_termination = True , data_points = 0 , chunk_size = None ) \u00a4 Read values from the device in binary format returning an iterable of values. Parameters: Name Type Description Default datatype pyvisa . util . BINARY_DATATYPES Format string for a single element. See struct module. 'f' by default. 'f' is_big_endian bool Are the data in big or little endian order. Defaults to False. False container Type | Callable [[ Iterable ], Sequence ] Container type to use for the output data. Possible values are: list, tuple, np.ndarray, etc, Default to list. list header_fmt pyvisa . util . BINARY_HEADERS Format of the header prefixing the data. Defaults to 'ieee'. 'ieee' expect_termination bool When set to False, the expected length of the binary values block does not account for the final termination character (the read termination). Defaults to True. True data_points int Number of points expected in the block. This is used only if the instrument does not report it itself. This will be converted in a number of bytes based on the datatype. Defaults to 0. 0 chunk_size Optional [ int ] Size of the chunks to read from the device. Using larger chunks may be faster for large amount of data. None Returns: Type Description Sequence [ int | float ] Data read from the device. Source code in pyinst\\abc.py 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 def read_binary_values ( self , datatype : pyvisa . util . BINARY_DATATYPES = \"f\" , is_big_endian : bool = False , container : Type | Callable [[ Iterable ], Sequence ] = list , header_fmt : pyvisa . util . BINARY_HEADERS = \"ieee\" , expect_termination : bool = True , data_points : int = 0 , chunk_size : Optional [ int ] = None , ) -> Sequence [ int | float ]: \"\"\"Read values from the device in binary format returning an iterable of values. Args: datatype: Format string for a single element. See struct module. 'f' by default. is_big_endian: Are the data in big or little endian order. Defaults to False. container: Container type to use for the output data. Possible values are: list, tuple, np.ndarray, etc, Default to list. header_fmt: Format of the header prefixing the data. Defaults to 'ieee'. expect_termination: When set to False, the expected length of the binary values block does not account for the final termination character (the read termination). Defaults to True. data_points: Number of points expected in the block. This is used only if the instrument does not report it itself. This will be converted in a number of bytes based on the datatype. Defaults to 0. chunk_size: Size of the chunks to read from the device. Using larger chunks may be faster for large amount of data. Returns: Data read from the device. \"\"\" return self . _inst . read_binary_values ( datatype , is_big_endian , container , header_fmt , expect_termination , data_points , chunk_size ) query_binary_values ( message , datatype = 'f' , is_big_endian = False , container = list , delay = None , header_fmt = 'ieee' , expect_termination = True , data_points = 0 , chunk_size = None ) \u00a4 Query the device for values in binary format returning an iterable of values. Parameters: Name Type Description Default message str The message to send. required datatype pyvisa . util . BINARY_DATATYPES Format string for a single element. See struct module. 'f' by default. 'f' is_big_endian bool Are the data in big or little endian order. Defaults to False. False container Type | Callable [[ Iterable ], Sequence ] Container type to use for the output data. Possible values are: list, tuple, np.ndarray, etc, Default to list. list delay Optional [ float ] Delay in seconds between write and read operations. If None, defaults to query_delay passed to __init__ method. None header_fmt pyvisa . util . BINARY_HEADERS Format of the header prefixing the data. Defaults to 'ieee'. 'ieee' expect_termination bool When set to False, the expected length of the binary values block does not account for the final termination character (the read termination). Defaults to True. True data_points int Number of points expected in the block. This is used only if the instrument does not report it itself. This will be converted in a number of bytes based on the datatype. Defaults to 0. 0 chunk_size Optional [ int ] Size of the chunks to read from the device. Using larger chunks may be faster for large amount of data. None Returns: Type Description Sequence [ int | float ] Data read from the device. Source code in pyinst\\abc.py 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 def query_binary_values ( self , message : str , datatype : pyvisa . util . BINARY_DATATYPES = \"f\" , is_big_endian : bool = False , container : Type | Callable [[ Iterable ], Sequence ] = list , delay : Optional [ float ] = None , header_fmt : pyvisa . util . BINARY_HEADERS = \"ieee\" , expect_termination : bool = True , data_points : int = 0 , chunk_size : Optional [ int ] = None , ) -> Sequence [ int | float ]: \"\"\"Query the device for values in binary format returning an iterable of values. Args: message: The message to send. datatype: Format string for a single element. See struct module. 'f' by default. is_big_endian: Are the data in big or little endian order. Defaults to False. container: Container type to use for the output data. Possible values are: list, tuple, np.ndarray, etc, Default to list. delay: Delay in seconds between write and read operations. If None, defaults to query_delay passed to `__init__` method. header_fmt: Format of the header prefixing the data. Defaults to 'ieee'. expect_termination: When set to False, the expected length of the binary values block does not account for the final termination character (the read termination). Defaults to True. data_points: Number of points expected in the block. This is used only if the instrument does not report it itself. This will be converted in a number of bytes based on the datatype. Defaults to 0. chunk_size: Size of the chunks to read from the device. Using larger chunks may be faster for large amount of data. Returns: Data read from the device. \"\"\" return self . _inst . query_binary_values ( message , datatype , is_big_endian , container , delay , header_fmt , expect_termination , data_points , chunk_size ) set_visa_attribute ( name , state ) \u00a4 Set the state of an attribute in this resource. One should prefer the dedicated descriptor for often used attributes since those perform checks and automatic conversion on the value. Parameters: Name Type Description Default name pyvisa . constants . ResourceAttribute Attribute for which the state is to be modified. required state Any The state of the attribute to be set for the specified object. required Returns: Type Description pyvisa . constants . StatusCode Return value of the library call. Source code in pyinst\\abc.py 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 def set_visa_attribute ( self , name : pyvisa . constants . ResourceAttribute , state : Any ) -> pyvisa . constants . StatusCode : \"\"\"Set the state of an attribute in this resource. One should prefer the dedicated descriptor for often used attributes since those perform checks and automatic conversion on the value. Args: name: Attribute for which the state is to be modified. state: The state of the attribute to be set for the specified object. Returns: Return value of the library call. \"\"\" return self . _inst . set_visa_attribute ( name , state ) get_visa_attribute ( name ) \u00a4 Retrieves the state of an attribute in this resource. One should prefer the dedicated descriptor for often used attributes since those perform checks and automatic conversion on the value. Parameters: Name Type Description Default name pyvisa . constants . ResourceAttribute Resource attribute for which the state query is made. required Returns: Type Description Any The state of the queried attribute for a specified resource. Source code in pyinst\\abc.py 454 455 456 457 458 459 460 461 462 463 464 465 466 def get_visa_attribute ( self , name : pyvisa . constants . ResourceAttribute ) -> Any : \"\"\"Retrieves the state of an attribute in this resource. One should prefer the dedicated descriptor for often used attributes since those perform checks and automatic conversion on the value. Args: name: Resource attribute for which the state query is made. Returns: The state of the queried attribute for a specified resource. \"\"\" return self . _inst . get_visa_attribute ( name ) RawSerialInstrument ( resource_name , baudrate , bytesize = SerialByteSize . EIGHTBITS , parity = SerialParity . NONE , stopbits = SerialStopBits . ONE , read_termination = SERIAL_READ_TERMINATION , write_termination = SERIAL_WRITE_TERMINATION , read_timeout = SERIAL_READ_TIMEOUT , write_timeout = SERIAL_WRITE_TIMEOUT , query_delay = SERIAL_QUERY_DELAY , encoding = 'ascii' , ** kwargs ) \u00a4 Bases: BaseInstrument Instrument based on raw serial communication. Compared to VISA compliant instruments, SerialRawInstrument do not have a common application architecture. It depends on the manufactory. SerialRawInstrument creates a proxy object using pySerial to communicate with instruments. Refer to pySerial Documents for more information. Parameters: Name Type Description Default resource_name str Serial port name. required baudrate int Baud rate such as 9600 or 115200 etc.. required bytesize SerialByteSize Number of data bits. SerialByteSize.EIGHTBITS parity SerialParity Parity checking. SerialParity.NONE stopbits SerialStopBits Number of stop bits. SerialStopBits.ONE read_termination str Read termination character. SERIAL_READ_TERMINATION write_termination str Write termination character. SERIAL_WRITE_TERMINATION read_timeout int Timeout in milliseconds for read operations. SERIAL_READ_TIMEOUT write_timeout int Timeout in milliseconds for write operations. SERIAL_WRITE_TIMEOUT query_delay float Delay in seconds between write and read operations. SERIAL_QUERY_DELAY encoding str Encoding used for read and write operations. 'ascii' Source code in pyinst\\abc.py 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 def __init__ ( self , resource_name : str , baudrate : int , bytesize : SerialByteSize = SerialByteSize . EIGHTBITS , parity : SerialParity = SerialParity . NONE , stopbits : SerialStopBits = SerialStopBits . ONE , read_termination : str = SERIAL_READ_TERMINATION , write_termination : str = SERIAL_WRITE_TERMINATION , read_timeout : int = SERIAL_READ_TIMEOUT , write_timeout : int = SERIAL_WRITE_TIMEOUT , query_delay : float = SERIAL_QUERY_DELAY , encoding : str = \"ascii\" , ** kwargs ): \"\"\" Args: resource_name: Serial port name. baudrate: Baud rate such as 9600 or 115200 etc.. bytesize: Number of data bits. parity: Parity checking. stopbits: Number of stop bits. read_termination: Read termination character. write_termination: Write termination character. read_timeout: Timeout in milliseconds for read operations. write_timeout: Timeout in milliseconds for write operations. query_delay: Delay in seconds between write and read operations. encoding: Encoding used for read and write operations. \"\"\" __serial = serial . Serial ( port = resource_name , baudrate = baudrate , bytesize = bytesize . value , parity = parity . value , stopbits = stopbits . value , timeout = read_timeout , write_timeout = write_timeout , ) self . __serial = __serial self . __read_termination = read_termination self . __write_termination = write_termination self . __encoding = encoding self . __query_delay = query_delay super () . __init__ ( resource_name = resource_name ) close () \u00a4 Close the serial port immediately. Source code in pyinst\\abc.py 532 533 534 def close ( self ) -> None : \"\"\"Close the serial port immediately.\"\"\" self . __serial . close () command ( message ) \u00a4 Write a serial command without read back. Alias of write(message). Parameters: Name Type Description Default message str message to be sent. required Returns: Type Description int Number of bytes written. Source code in pyinst\\abc.py 536 537 538 539 540 541 542 543 544 545 546 547 548 def command ( self , message : str ) -> int : \"\"\" Write a serial command without read back. Alias of write(message). Args: message: message to be sent. Returns: Number of bytes written. \"\"\" return self . write ( message ) write ( message , termination = None , encoding = None ) \u00a4 Write a string message to the device. The write_termination is always appended to it. Parameters: Name Type Description Default message str message to be sent. required termination Optional [ str ] Alternative character termination to use. If None, the value of write_termination passed to __init__ method is used. Defaults to None. None encoding Optional [ str ] Alternative encoding to use to turn str into bytes. If None, the value of encoding passed to __init__ method is used. Defaults to None. None Returns: Type Description int Number of bytes written. Source code in pyinst\\abc.py 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 def write ( self , message : str , termination : Optional [ str ] = None , encoding : Optional [ str ] = None , ) -> int : \"\"\"Write a string message to the device. The write_termination is always appended to it. Args: message: message to be sent. termination: Alternative character termination to use. If None, the value of write_termination passed to `__init__` method is used. Defaults to None. encoding: Alternative encoding to use to turn str into bytes. If None, the value of encoding passed to `__init__` method is used. Defaults to None. Returns: Number of bytes written. \"\"\" tx_str = ' {message}{term} ' . format ( message = message , term = termination or self . __write_termination ) tx_bytes = tx_str . encode ( encoding or self . __encoding ) # clear input buffer so the data buffered before command is cleared self . __serial . reset_input_buffer () return self . __serial . write ( tx_bytes ) read ( termination = None , encoding = None ) \u00a4 Read a string from the device. Reading stops when the device stops sending, or the termination characters sequence was detected. Parameters: Name Type Description Default termination Optional [ str ] Alternative character termination to use. If None, the value of write_termination passed to __init__ method is used. Defaults to None. None encoding Optional [ str ] Alternative encoding to use to turn bytes into str. If None, the value of encoding passed to __init__ method is used. Defaults to None. None Returns: Type Description str Message read from the instrument and decoded. Source code in pyinst\\abc.py 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 def read ( self , termination : Optional [ str ] = None , encoding : Optional [ str ] = None ) -> str : \"\"\"Read a string from the device. Reading stops when the device stops sending, or the termination characters sequence was detected. Args: termination: Alternative character termination to use. If None, the value of write_termination passed to `__init__` method is used. Defaults to None. encoding: Alternative encoding to use to turn bytes into str. If None, the value of encoding passed to `__init__` method is used. Defaults to None. Returns: Message read from the instrument and decoded. \"\"\" buffer = bytes () term = termination or self . __read_termination encoding = encoding or self . __encoding while True : rx = self . __serial . read () if not rx : raise InstrIOError ( 'Timeout before read_termination received.' ) buffer += rx if buffer . endswith ( term . encode ( encoding )): break return buffer . decode ( encoding ) . rstrip ( term ) query ( message , delay = None ) \u00a4 A combination of write(message) and read() Parameters: Name Type Description Default message str The message to send. required delay Optional [ float ] Delay in seconds between write and read operations. If None, defaults to query_delay passed to __init__ method. None Returns: Type Description str Answer from the device. Source code in pyinst\\abc.py 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 def query ( self , message : str , delay : Optional [ float ] = None ) -> str : \"\"\"A combination of write(message) and read() Args: message: The message to send. delay: Delay in seconds between write and read operations. If None, defaults to query_delay passed to `__init__` method. Returns: Answer from the device. \"\"\" self . write ( message ) time . sleep ( delay or self . __query_delay ) return self . read () OpticalFrequencySetter \u00a4 Bases: ABC Instrument with optical frequency/wavelength setting. min_frequency () property abstractmethod \u00a4 The minimum settable optical frequency value in THz. Source code in pyinst\\abc.py 635 636 637 638 639 @property @abstractmethod def min_frequency ( self ) -> float : \"\"\"The minimum settable optical frequency value in THz.\"\"\" return LIGHTSPEED / self . max_wavelength max_frequency () property abstractmethod \u00a4 The maximum settable optical frequency value in THz. Source code in pyinst\\abc.py 641 642 643 644 645 @property @abstractmethod def max_frequency ( self ) -> float : \"\"\"The maximum settable optical frequency value in THz.\"\"\" return LIGHTSPEED / self . min_wavelength min_wavelength () property abstractmethod \u00a4 The minimum settable optical wavelength value in nm. Source code in pyinst\\abc.py 647 648 649 650 651 @property @abstractmethod def min_wavelength ( self ) -> float : \"\"\"The minimum settable optical wavelength value in nm.\"\"\" return LIGHTSPEED / self . max_frequency max_wavelength () property abstractmethod \u00a4 The maximum settable optical wavelength value in nm. Source code in pyinst\\abc.py 653 654 655 656 657 @property @abstractmethod def max_wavelength ( self ) -> float : \"\"\"The maximum settable optical wavelength value in nm.\"\"\" return LIGHTSPEED / self . min_frequency get_frequency () abstractmethod \u00a4 Queries the optical frequency setting of the instrument in THz. Returns: Type Description float The optical frequency setting value in THz. Source code in pyinst\\abc.py 659 660 661 662 663 664 665 666 667 @abstractmethod def get_frequency ( self ) -> float : \"\"\" Queries the optical frequency setting of the instrument in THz. Returns: The optical frequency setting value in THz. \"\"\" return round ( LIGHTSPEED / self . get_wavelength (), 6 ) set_frequency ( frequency ) abstractmethod \u00a4 Set optical frequency. Parameters: Name Type Description Default frequency int | float The optical frequency setting in THz. required Source code in pyinst\\abc.py 669 670 671 672 673 674 675 676 677 @abstractmethod def set_frequency ( self , frequency : int | float ) -> None : \"\"\"Set optical frequency. Args: frequency: The optical frequency setting in THz. \"\"\" wavelength = round ( LIGHTSPEED / frequency , 6 ) self . set_wavelength ( wavelength ) get_wavelength () abstractmethod \u00a4 Queries the optical wavelength setting of the instrument in nm. Returns: Type Description float The optical wavelength setting value in nm. Source code in pyinst\\abc.py 679 680 681 682 683 684 685 686 @abstractmethod def get_wavelength ( self ) -> float : \"\"\"Queries the optical wavelength setting of the instrument in nm. Returns: The optical wavelength setting value in nm. \"\"\" return round ( LIGHTSPEED / self . get_frequency (), 6 ) set_wavelength ( wavelength ) abstractmethod \u00a4 Set optical wavelength. Parameters: Name Type Description Default wavelength int | float The optical wavelength setting in nm. required Source code in pyinst\\abc.py 688 689 690 691 692 693 694 695 696 @abstractmethod def set_wavelength ( self , wavelength : int | float ) -> None : \"\"\"Set optical wavelength. Args: wavelength: The optical wavelength setting in nm. \"\"\" frequency = round ( LIGHTSPEED / wavelength , 6 ) self . set_frequency ( frequency ) TypeOPM \u00a4 Bases: OpticalFrequencySetter ABC to define the interfaces of an Optical Power Meter. min_avg_time () property abstractmethod \u00a4 The minimum averaging time in ms. Source code in pyinst\\abc.py 704 705 706 707 @property @abstractmethod def min_avg_time ( self ) -> float : \"\"\"The minimum averaging time in ms.\"\"\" max_avg_time () property abstractmethod \u00a4 The maximum averaging time in ms. Source code in pyinst\\abc.py 709 710 711 712 @property @abstractmethod def max_avg_time ( self ) -> float : \"\"\"The maximum averaging time in ms.\"\"\" min_pow_cal () property abstractmethod \u00a4 The minimum power calibration value in dB. Source code in pyinst\\abc.py 714 715 716 717 @property @abstractmethod def min_pow_cal ( self ) -> float : \"\"\"The minimum power calibration value in dB.\"\"\" max_pow_cal () property abstractmethod \u00a4 The maximum power calibration value in dB. Source code in pyinst\\abc.py 719 720 721 722 @property @abstractmethod def max_pow_cal ( self ) -> float : \"\"\"The maximum power calibration value in dB.\"\"\" get_power_value () abstractmethod \u00a4 Fetch the value of measured optical power in current unit setting. The measured value includes the power calibration. Measured value (dBm) = the actual measured value (dBm) + power calibration (dB) Refer to get_pow_cal and set_pow_cal to operate with the power calibration. Note It is possible that some OPM models defined the power calibration opposite in sign, but it is normalized in pyinst. Please refer to the math function above. Returns: Type Description float The value of the optical power. Source code in pyinst\\abc.py 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 @abstractmethod def get_power_value ( self ) -> float : \"\"\"Fetch the value of measured optical power in current unit setting. The measured value includes the power calibration. Measured value (dBm) = the actual measured value (dBm) + power calibration (dB) Refer to `get_pow_cal` and `set_pow_cal` to operate with the power calibration. Note: It is possible that some OPM models defined the power calibration opposite in sign, but it is normalized in pyinst. Please refer to the math function above. Returns: The value of the optical power. \"\"\" get_power_unit () abstractmethod \u00a4 Get optical power unit setting. Returns: Type Description OpticalPowerUnit The unit of the optical power. Source code in pyinst\\abc.py 743 744 745 746 747 748 749 @abstractmethod def get_power_unit ( self ) -> OpticalPowerUnit : \"\"\"Get optical power unit setting. Returns: The unit of the optical power. \"\"\" set_power_unit ( unit ) abstractmethod \u00a4 Set the unit of optical power. Parameters: Name Type Description Default unit OpticalPowerUnit The unit of the optical power. required Source code in pyinst\\abc.py 751 752 753 754 755 756 757 @abstractmethod def set_power_unit ( self , unit : OpticalPowerUnit ) -> None : \"\"\"Set the unit of optical power. Args: unit: The unit of the optical power. \"\"\" get_power () \u00a4 Queries the measured optical power value and unit. Returns: Name Type Description value float The value of the optical power. unit OpticalPowerUnit The unit of the optical power. Source code in pyinst\\abc.py 759 760 761 762 763 764 765 766 def get_power ( self ) -> Tuple [ float , OpticalPowerUnit ]: \"\"\"Queries the measured optical power value and unit. Returns: value: The value of the optical power. unit: The unit of the optical power. \"\"\" return self . get_power_value (), self . get_power_unit () get_dbm_value () \u00a4 Returns the optical power value measured in dBm. If the power unit setting is W, a math conversion will be performed. Returns: Type Description float The value of the optical power in dBm. Source code in pyinst\\abc.py 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 def get_dbm_value ( self ) -> float : \"\"\"Returns the optical power value measured in dBm. If the power unit setting is W, a math conversion will be performed. Returns: The value of the optical power in dBm. \"\"\" unit = self . get_power_unit () value = self . get_power_value () if unit == OpticalPowerUnit . DBM : return value else : return w_to_dbm ( value ) get_w_value () \u00a4 Returns the optical power value measured in W. If the power unit setting is dBm, a math conversion will be performed. Returns: Type Description float The value of the optical power in W. Source code in pyinst\\abc.py 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 def get_w_value ( self ) -> float : \"\"\"Returns the optical power value measured in W. If the power unit setting is dBm, a math conversion will be performed. Returns: The value of the optical power in W. \"\"\" unit = self . get_power_unit () value = self . get_power_value () if unit == OpticalPowerUnit . W : return value else : return dbm_to_w ( value ) get_pow_cal () abstractmethod \u00a4 Get the power calibration offset in dB. Returns: Type Description float The power calibration offset in dB. Source code in pyinst\\abc.py 800 801 802 803 804 805 806 807 @abstractmethod def get_pow_cal ( self ) -> float : \"\"\" Get the power calibration offset in dB. Returns: The power calibration offset in dB. \"\"\" set_pow_cal ( value ) abstractmethod \u00a4 Set the power calibration offset in dB. Parameters: Name Type Description Default value int | float The power calibration offset in dB. required Source code in pyinst\\abc.py 809 810 811 812 813 814 815 816 @abstractmethod def set_pow_cal ( self , value : int | float ) -> None : \"\"\" Set the power calibration offset in dB. Args: value: The power calibration offset in dB. \"\"\" get_avg_time () abstractmethod \u00a4 Get the averaging time in ms. Returns: Type Description float The averaging time in ms. Source code in pyinst\\abc.py 818 819 820 821 822 823 824 825 @abstractmethod def get_avg_time ( self ) -> float : \"\"\" Get the averaging time in ms. Returns: The averaging time in ms. \"\"\" set_avg_time ( value ) abstractmethod \u00a4 Set the averaging time in ms. Parameters: Name Type Description Default value int | float The averaging time in ms. required Source code in pyinst\\abc.py 827 828 829 830 831 832 833 834 @abstractmethod def set_avg_time ( self , value : int | float ) -> None : \"\"\" Set the averaging time in ms. Args: value: The averaging time in ms. \"\"\" TypeVOA \u00a4 Bases: OpticalFrequencySetter ABC to define the interfaces of a Variable Optical Attenuator. min_att () property abstractmethod \u00a4 Minimum settable attenuation in dB. The minimum settable attenuation = 0 dB + the optical attenuation offset value. Source code in pyinst\\abc.py 844 845 846 847 848 849 850 851 @property @abstractmethod def min_att ( self ) -> float : \"\"\"Minimum settable attenuation in dB. The minimum settable attenuation = 0 dB + the optical attenuation offset value. \"\"\" max_att () property abstractmethod \u00a4 Maximum settable attenuation in dB. The maximum settable attenuation = The maximum attenuation + the optical attenuation offset value. Source code in pyinst\\abc.py 853 854 855 856 857 858 859 860 @property @abstractmethod def max_att ( self ) -> float : \"\"\"Maximum settable attenuation in dB. The maximum settable attenuation = The maximum attenuation + the optical attenuation offset value. \"\"\" min_att_offset () property abstractmethod \u00a4 Minimum attenuation offset value in dB. Source code in pyinst\\abc.py 862 863 864 865 @property @abstractmethod def min_att_offset ( self ) -> float : \"\"\"Minimum attenuation offset value in dB.\"\"\" max_att_offset () property abstractmethod \u00a4 Maximum attenuation offset value in dB. Source code in pyinst\\abc.py 867 868 869 870 @property @abstractmethod def max_att_offset ( self ) -> float : \"\"\"Maximum attenuation offset value in dB.\"\"\" enable ( en = True ) abstractmethod \u00a4 Enable (disable) the optical output. Parameters: Name Type Description Default en bool True = Enable, False = Disable. True Source code in pyinst\\abc.py 872 873 874 875 876 877 878 879 @abstractmethod def enable ( self , en : bool = True ) -> None : \"\"\" Enable (disable) the optical output. Args: en: True = Enable, False = Disable. \"\"\" disable () abstractmethod \u00a4 Disable the optical output. Source code in pyinst\\abc.py 881 882 883 @abstractmethod def disable ( self ) -> None : \"\"\"Disable the optical output.\"\"\" is_enabled () abstractmethod \u00a4 Returns: Type Description bool Whether the optical output is enabled. Source code in pyinst\\abc.py 885 886 887 888 889 890 @abstractmethod def is_enabled ( self ) -> bool : \"\"\" Returns: Whether the optical output is enabled. \"\"\" get_att () abstractmethod \u00a4 Get the current attenuation value in dB. Includes the attenuation offset. Queried attenuator = the actual attenuator value + attenuator offset Use get_att_offset and set_att_offset to operate with the attenuator offset. Note It is possible that some VOA models defined the attenuation offset opposite in sign. But it is normalized in pyinst to align with the math function above. Returns: Type Description float The attenuation value in dB. Source code in pyinst\\abc.py 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 @abstractmethod def get_att ( self ) -> float : \"\"\" Get the current attenuation value in dB. Includes the attenuation offset. Queried attenuator = the actual attenuator value + attenuator offset Use `get_att_offset` and `set_att_offset` to operate with the attenuator offset. Note: It is possible that some VOA models defined the attenuation offset opposite in sign. But it is normalized in pyinst to align with the math function above. Returns: The attenuation value in dB. \"\"\" set_att ( att ) abstractmethod \u00a4 Set attenuation value in dB. Includes the attenuation offset. Refer to get_att for more information. Parameters: Name Type Description Default att int | float The attenuation value in dB. required Source code in pyinst\\abc.py 913 914 915 916 917 918 919 920 921 922 923 @abstractmethod def set_att ( self , att : int | float ) -> None : \"\"\" Set attenuation value in dB. Includes the attenuation offset. Refer to `get_att` for more information. Args: att: The attenuation value in dB. \"\"\" get_att_offset () abstractmethod \u00a4 Get the attenuation offset value in dB. Returns: Type Description float The attenuation offset in dB. Source code in pyinst\\abc.py 925 926 927 928 929 930 931 932 @abstractmethod def get_att_offset ( self ) -> float : \"\"\" Get the attenuation offset value in dB. Returns: The attenuation offset in dB. \"\"\" set_att_offset ( offset ) abstractmethod \u00a4 Set the attenuation offset value in dB. Parameters: Name Type Description Default offset int | float The attenuation offset in dB. required Source code in pyinst\\abc.py 934 935 936 937 938 939 940 941 @abstractmethod def set_att_offset ( self , offset : int | float ) -> None : \"\"\" Set the attenuation offset value in dB. Args: offset: The attenuation offset in dB. \"\"\" TypeOMA \u00a4 Bases: OpticalFrequencySetter ABC to define the interfaces of an Optical Modulation Analyzer. The operating logic is different between vendors/models, so limited methods are defined here. run ( _run = True ) abstractmethod \u00a4 Run (or stop) OMA. Parameters: Name Type Description Default _run bool True = run, False = stop. True Source code in pyinst\\abc.py 953 954 955 956 957 958 959 960 @abstractmethod def run ( self , _run : bool = True ) -> None : \"\"\" Run (or stop) OMA. Args: _run: True = run, False = stop. \"\"\" stop () abstractmethod \u00a4 Stop OMA. Source code in pyinst\\abc.py 962 963 964 @abstractmethod def stop ( self ) -> None : \"\"\"Stop OMA.\"\"\" TypeOSA \u00a4 Bases: OpticalFrequencySetter ABC to define the interfaces of an Optical Spectrum Analyzer. The operating logic is different between vendors/models, so no common methods are defined here. run ( _run = True ) abstractmethod \u00a4 Start repeat sweep. Parameters: Name Type Description Default _run bool True = run, False = stop. True Source code in pyinst\\abc.py 976 977 978 979 980 981 982 983 @abstractmethod def run ( self , _run : bool = True ) -> None : \"\"\" Start repeat sweep. Args: _run: True = run, False = stop. \"\"\" stop () abstractmethod \u00a4 Stop sweep. Source code in pyinst\\abc.py 985 986 987 @abstractmethod def stop ( self ) -> None : \"\"\"Stop sweep.\"\"\" single () abstractmethod \u00a4 Perform single sweep. Source code in pyinst\\abc.py 989 990 991 @abstractmethod def single ( self ) -> None : \"\"\"Perform single sweep.\"\"\" is_running () abstractmethod \u00a4 Get the sweep state of the OSA. Returns: Type Description bool Whether the repeat sweep is running. Source code in pyinst\\abc.py 993 994 995 996 997 998 999 1000 @abstractmethod def is_running ( self ) -> bool : \"\"\" Get the sweep state of the OSA. Returns: Whether the repeat sweep is running. \"\"\" get_osnr () abstractmethod \u00a4 Get the measured OSNR in dB. Returns: Type Description float The OSNR value in dB. Source code in pyinst\\abc.py 1002 1003 1004 1005 1006 1007 1008 @abstractmethod def get_osnr ( self ) -> float : \"\"\"Get the measured OSNR in dB. Returns: The OSNR value in dB. \"\"\" TypeWM \u00a4 Bases: ABC ABC to define the interfaces of an Optical Wavelength Meter. get_frequency () abstractmethod \u00a4 Queries the measured optical frequency in THz. Returns: Type Description float The measured optical frequency value. Source code in pyinst\\abc.py 1018 1019 1020 1021 1022 1023 1024 1025 1026 @abstractmethod def get_frequency ( self ) -> float : \"\"\" Queries the measured optical frequency in THz. Returns: The measured optical frequency value. \"\"\" return round ( LIGHTSPEED / self . get_wavelength (), 6 ) get_wavelength () abstractmethod \u00a4 Queries the mearured optical wavelength in nm. Returns: Type Description float The measured optical wavelength value. Source code in pyinst\\abc.py 1028 1029 1030 1031 1032 1033 1034 1035 @abstractmethod def get_wavelength ( self ) -> float : \"\"\"Queries the mearured optical wavelength in nm. Returns: The measured optical wavelength value. \"\"\" return round ( LIGHTSPEED / self . get_frequency (), 6 ) run ( _run = True ) abstractmethod \u00a4 Start repeat measurement. Parameters: Name Type Description Default _run bool True = run, False = stop. True Source code in pyinst\\abc.py 1037 1038 1039 1040 1041 1042 1043 1044 @abstractmethod def run ( self , _run : bool = True ) -> None : \"\"\" Start repeat measurement. Args: _run: True = run, False = stop. \"\"\" stop () abstractmethod \u00a4 Stop repeat measurement. Source code in pyinst\\abc.py 1046 1047 1048 @abstractmethod def stop ( self ) -> None : \"\"\"Stop repeat measurement.\"\"\" single () abstractmethod \u00a4 Perform single measurement. Source code in pyinst\\abc.py 1050 1051 1052 @abstractmethod def single ( self ) -> None : \"\"\"Perform single measurement.\"\"\" is_running () abstractmethod \u00a4 Get the measurement state of the wavemeter. Returns: Type Description bool True = reapeat measurement, False = stopped. Source code in pyinst\\abc.py 1054 1055 1056 1057 1058 1059 1060 1061 @abstractmethod def is_running ( self ) -> bool : \"\"\" Get the measurement state of the wavemeter. Returns: True = reapeat measurement, False = stopped. \"\"\" TypeOTF \u00a4 Bases: OpticalFrequencySetter ABC to define the interfaces of an Optical Tunable Filter. min_bandwidth_in_nm () property abstractmethod \u00a4 The minimum bandwidth in nm. Source code in pyinst\\abc.py 1069 1070 1071 1072 1073 @property @abstractmethod def min_bandwidth_in_nm ( self ) -> float : \"\"\"The minimum bandwidth in nm.\"\"\" return bw_in_ghz_to_nm ( self . min_bandwidth_in_ghz ) max_bandwidth_in_nm () property abstractmethod \u00a4 The maximum bandwidth in nm. Source code in pyinst\\abc.py 1075 1076 1077 1078 1079 @property @abstractmethod def max_bandwidth_in_nm ( self ) -> float : \"\"\"The maximum bandwidth in nm.\"\"\" return bw_in_ghz_to_nm ( self . max_bandwidth_in_ghz ) min_bandwidth_in_ghz () property abstractmethod \u00a4 The minimum bandwidth in GHz. Source code in pyinst\\abc.py 1081 1082 1083 1084 1085 @property @abstractmethod def min_bandwidth_in_ghz ( self ) -> float : \"\"\"The minimum bandwidth in GHz.\"\"\" return bw_in_nm_to_ghz ( self . min_bandwidth_in_nm ) max_bandwidth_in_ghz () property abstractmethod \u00a4 The maximum bandwidth in GHz. Source code in pyinst\\abc.py 1087 1088 1089 1090 1091 @property @abstractmethod def max_bandwidth_in_ghz ( self ) -> float : \"\"\"The maximum bandwidth in GHz.\"\"\" return bw_in_nm_to_ghz ( self . max_bandwidth_in_nm ) get_bandwidth ( unit ) \u00a4 Get the filter bandwidth value in specified unit. Parameters: Name Type Description Default unit OpticalBandwidthUnit The unit for the bandwidth value. required Returns: Type Description float The bandwidth value in specified unit. Source code in pyinst\\abc.py 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 def get_bandwidth ( self , unit : OpticalBandwidthUnit ) -> float : \"\"\" Get the filter bandwidth value in specified unit. Args: unit: The unit for the bandwidth value. Returns: The bandwidth value in specified unit. \"\"\" unit = OpticalBandwidthUnit ( unit ) if unit == OpticalBandwidthUnit . GHZ : return self . get_bandwidth_in_ghz () else : return self . get_bandwidth_in_nm () set_bandwidth ( value , unit ) \u00a4 Set the filter bandwidth in specified unit. Parameters: Name Type Description Default value int | float The bandwidth value in specified unit. required unit OpticalBandwidthUnit The unit of the bandwidth value. required Source code in pyinst\\abc.py 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 def set_bandwidth ( self , value : int | float , unit : OpticalBandwidthUnit ) -> None : \"\"\" Set the filter bandwidth in specified unit. Args: value: The bandwidth value in specified unit. unit: The unit of the bandwidth value. \"\"\" unit = OpticalBandwidthUnit ( unit ) if unit == OpticalBandwidthUnit . GHZ : return self . set_bandwidth_in_ghz ( value ) else : return self . set_bandwidth_in_nm ( value ) get_bandwidth_in_nm () abstractmethod \u00a4 Get the filter bandwidth in nm. Returns: Type Description float The bandwidth value in nm. Source code in pyinst\\abc.py 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 @abstractmethod def get_bandwidth_in_nm ( self ) -> float : \"\"\" Get the filter bandwidth in nm. Returns: The bandwidth value in nm. \"\"\" bw_ghz = self . get_bandwidth_in_ghz () return round ( bw_in_ghz_to_nm ( bw_ghz ), 6 ) set_bandwidth_in_nm ( value ) abstractmethod \u00a4 Set the filter bandwidth in nm. Parameters: Name Type Description Default value int | float The bandwidth value in nm. required Source code in pyinst\\abc.py 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 @abstractmethod def set_bandwidth_in_nm ( self , value : int | float ) -> None : \"\"\" Set the filter bandwidth in nm. Args: value: The bandwidth value in nm. \"\"\" bw_ghz = round ( bw_in_nm_to_ghz ( value ), 6 ) self . set_bandwidth_in_ghz ( bw_ghz ) get_bandwidth_in_ghz () abstractmethod \u00a4 Get the filter bandwidth in GHz. Returns: Type Description float The bandwidth value in GHz. Source code in pyinst\\abc.py 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 @abstractmethod def get_bandwidth_in_ghz ( self ) -> float : \"\"\" Get the filter bandwidth in GHz. Returns: The bandwidth value in GHz. \"\"\" bw_nm = self . get_bandwidth_in_nm () return round ( bw_in_nm_to_ghz ( bw_nm ), 6 ) set_bandwidth_in_ghz ( value ) abstractmethod \u00a4 Set the filter bandwidth in GHz. Parameters: Name Type Description Default value int | float The bandwidth value in GHz. required Source code in pyinst\\abc.py 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 @abstractmethod def set_bandwidth_in_ghz ( self , value : int | float ) -> None : \"\"\" Set the filter bandwidth in GHz. Args: value: The bandwidth value in GHz. \"\"\" bw_nm = round ( bw_in_ghz_to_nm ( value ), 6 ) self . set_bandwidth_in_nm ( bw_nm ) TypeTS \u00a4 Bases: ABC ABC to define the interfaces of a Temperature Source. A temperature source is an instrument that has the ability to control environment temperature, including chamber, TEC (Thermo Electric Cooler), thermo-stream, and so on. Each TypeTS class has a ts_type property to indicate the type of the thermostream. It is a member of TemperatureSourceType enum. ts_type () property \u00a4 The type of the temperature source. Source code in pyinst\\abc.py 1181 1182 1183 1184 @property def ts_type ( self ) -> TemperatureSourceType : \"\"\"The type of the temperature source.\"\"\" return TemperatureSourceType . UNDEFINED set_target_temp ( value ) abstractmethod \u00a4 Set the target temperature. Parameters: Name Type Description Default value int | float The target temperature value. required Source code in pyinst\\abc.py 1186 1187 1188 1189 1190 1191 1192 1193 @abstractmethod def set_target_temp ( self , value : int | float ) -> None : \"\"\" Set the target temperature. Args: value: The target temperature value. \"\"\" get_target_temp () abstractmethod \u00a4 Get the target temperature setting. Returns: Type Description float The target temperature setting value. Source code in pyinst\\abc.py 1195 1196 1197 1198 1199 1200 1201 1202 @abstractmethod def get_target_temp ( self ) -> float : \"\"\" Get the target temperature setting. Returns: The target temperature setting value. \"\"\" get_current_temp () abstractmethod \u00a4 Queries the current monitored temperature. Returns: Type Description float The current temperature monitor value. Source code in pyinst\\abc.py 1204 1205 1206 1207 1208 1209 1210 1211 @abstractmethod def get_current_temp ( self ) -> float : \"\"\" Queries the current monitored temperature. Returns: The current temperature monitor value. \"\"\" set_temp_unit ( unit ) abstractmethod \u00a4 Set the temperature unit. Parameters: Name Type Description Default unit TemperatureUnit The temperature unit. required Source code in pyinst\\abc.py 1213 1214 1215 1216 1217 1218 1219 1220 @abstractmethod def set_temp_unit ( self , unit : TemperatureUnit ) -> None : \"\"\" Set the temperature unit. Args: unit: The temperature unit. \"\"\" get_temp_unit () abstractmethod \u00a4 Get the temperature unit setting. Returns: Type Description TemperatureUnit The temperature unit. Source code in pyinst\\abc.py 1222 1223 1224 1225 1226 1227 1228 1229 @abstractmethod def get_temp_unit ( self ) -> TemperatureUnit : \"\"\" Get the temperature unit setting. Returns: The temperature unit. \"\"\" TypeSW \u00a4 Bases: ABC ABC to define the interfaces of an Optical Switch. set_channel ( channel ) abstractmethod \u00a4 Switch to the specified channel route. Parameters: Name Type Description Default channel int The channel number. required Source code in pyinst\\abc.py 1237 1238 1239 1240 1241 1242 1243 1244 @abstractmethod def set_channel ( self , channel : int ) -> None : \"\"\" Switch to the specified channel route. Args: channel: The channel number. \"\"\" get_channel () abstractmethod \u00a4 Queries the current channel route of the switch. Returns: Type Description int The channel number of current route. Source code in pyinst\\abc.py 1246 1247 1248 1249 1250 1251 1252 1253 @abstractmethod def get_channel ( self ) -> int : \"\"\" Queries the current channel route of the switch. Returns: The channel number of current route. \"\"\" TypeMSW \u00a4 Bases: ABC ABC to define the interfaces of an Optical Matrix Switch. connect ( port1 , port2 , enable = True ) abstractmethod \u00a4 Sets a new optical connection. Note that this method will delete any existing connections using port1 or port2. Use check to confirm whether either port is already in use. Parameters: Name Type Description Default port1 int The valid port at one end of the path. required port2 int The valid port at the other end of the path. required enable bool Whether to enable the connection. True Source code in pyinst\\abc.py 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 @abstractmethod def connect ( self , port1 : int , port2 : int , enable : bool = True ) -> None : \"\"\" Sets a new optical connection. Note that this method will delete any existing connections using port1 or port2. Use `check` to confirm whether either port is already in use. Args: port1: The valid port at one end of the path. port2: The valid port at the other end of the path. enable: Whether to enable the connection. \"\"\" connected_with ( port ) abstractmethod \u00a4 Returns connection information of the specified port. If the port is connected, return the port number at the other end of the connection. If no connection exists for the port, return None. Parameters: Name Type Description Default port int The port number to check connection information. required Returns: Type Description Optional [ int ] Connection information for the specified port. Optional [ int ] None = No connection exists. Optional [ int ] Optional [ int ] int N = Port number at other end of the connection. Source code in pyinst\\abc.py 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 @abstractmethod def connected_with ( self , port : int ) -> Optional [ int ]: \"\"\" Returns connection information of the specified port. If the port is connected, return the port number at the other end of the connection. If no connection exists for the port, return None. Args: port: The port number to check connection information. Returns: Connection information for the specified port. None = No connection exists. int N = Port number at other end of the connection. \"\"\" clear ( port ) abstractmethod \u00a4 Clears a configured optical connection connected to the specified port. Parameters: Name Type Description Default port int The port at either end of the configured connection. required Source code in pyinst\\abc.py 1296 1297 1298 1299 1300 1301 1302 1303 @abstractmethod def clear ( self , port : int ) -> None : \"\"\" Clears a configured optical connection connected to the specified port. Args: port: The port at either end of the configured connection. \"\"\" clear_all () abstractmethod \u00a4 Clears all configured optical connections. Source code in pyinst\\abc.py 1305 1306 1307 @abstractmethod def clear_all ( self ) -> None : \"\"\"Clears all configured optical connections.\"\"\" check ( port1 , port2 ) abstractmethod \u00a4 To check if port1 and port2 are both not in use. Parameters: Name Type Description Default port1 int The port at one end of the path. required port2 int The port at the other end of the path. required Returns: Type Description bool True = Both ports available (not in use). bool False = Conflict; one or both ports already in use. Source code in pyinst\\abc.py 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 @abstractmethod def check ( self , port1 : int , port2 : int ) -> bool : \"\"\" To check if port1 and port2 are both not in use. Args: port1: The port at one end of the path. port2: The port at the other end of the path. Returns: True = Both ports available (not in use). False = Conflict; one or both ports already in use. \"\"\" enable ( port , enable = True ) abstractmethod \u00a4 Sets the connection state of a configured optical connection. Parameters: Name Type Description Default port int The port at either end of the connection. required enable bool True = Enable | False = Disable. True Source code in pyinst\\abc.py 1324 1325 1326 1327 1328 1329 1330 1331 1332 @abstractmethod def enable ( self , port : int , enable : bool = True ) -> None : \"\"\" Sets the connection state of a configured optical connection. Args: port: The port at either end of the connection. enable: True = Enable | False = Disable. \"\"\" disable ( port ) abstractmethod \u00a4 Disable the connection of a configured optical connection. Parameters: Name Type Description Default port int The port at either end of the connection. required Source code in pyinst\\abc.py 1334 1335 1336 1337 1338 1339 1340 1341 @abstractmethod def disable ( self , port : int ) -> None : \"\"\" Disable the connection of a configured optical connection. Args: port: The port at either end of the connection. \"\"\" is_enabled ( port ) abstractmethod \u00a4 Returns the connection state of a configured optical connection. Returns: Type Description bool True = Enabled | False = Disabled Source code in pyinst\\abc.py 1343 1344 1345 1346 1347 1348 1349 1350 @abstractmethod def is_enabled ( self , port : int ) -> bool : \"\"\" Returns the connection state of a configured optical connection. Returns: True = Enabled | False = Disabled \"\"\" TypePS \u00a4 Bases: ABC ABC to define the interfaces of a Power Supply. min_voltage () property abstractmethod \u00a4 The minimum programmable voltage level in V. Source code in pyinst\\abc.py 1358 1359 1360 1361 @property @abstractmethod def min_voltage ( self ) -> float : \"\"\"The minimum programmable voltage level in V.\"\"\" max_voltage () property abstractmethod \u00a4 The maximum programmable voltage level in V. Source code in pyinst\\abc.py 1363 1364 1365 1366 @property @abstractmethod def max_voltage ( self ) -> float : \"\"\"The maximum programmable voltage level in V.\"\"\" min_current () property abstractmethod \u00a4 The minimum programmable current level in A. Source code in pyinst\\abc.py 1368 1369 1370 1371 @property @abstractmethod def min_current ( self ) -> float : \"\"\"The minimum programmable current level in A.\"\"\" max_current () property abstractmethod \u00a4 The maximum programmable current level in A. Source code in pyinst\\abc.py 1373 1374 1375 1376 @property @abstractmethod def max_current ( self ) -> float : \"\"\"The maximum programmable current level in A.\"\"\" enable ( en = True ) abstractmethod \u00a4 Enables (or disables) the outputs of the power supply. Parameters: Name Type Description Default en bool True = Enable, False = Disable. True Source code in pyinst\\abc.py 1378 1379 1380 1381 1382 1383 1384 1385 @abstractmethod def enable ( self , en : bool = True ) -> None : \"\"\" Enables (or disables) the outputs of the power supply. Args: en: `True` = Enable, `False` = Disable. \"\"\" disable () abstractmethod \u00a4 Disables the output of the power supply. Source code in pyinst\\abc.py 1387 1388 1389 @abstractmethod def disable ( self ) -> None : \"\"\"Disables the output of the power supply.\"\"\" is_enabled () abstractmethod \u00a4 Queries whether the output of the power supply is enabled. Returns: Type Description bool True = Enabled, False = Disabled Source code in pyinst\\abc.py 1391 1392 1393 1394 1395 1396 1397 1398 @abstractmethod def is_enabled ( self ) -> bool : \"\"\" Queries whether the output of the power supply is enabled. Returns: `True` = Enabled, `False` = Disabled \"\"\" set_voltage_limit ( value ) abstractmethod \u00a4 Sets the immediate voltage level of the power supply. Parameters: Name Type Description Default value int | float The voltage level in V. required Source code in pyinst\\abc.py 1400 1401 1402 1403 1404 1405 1406 1407 @abstractmethod def set_voltage_limit ( self , value : int | float ) -> None : \"\"\" Sets the immediate voltage level of the power supply. Args: value: The voltage level in V. \"\"\" get_voltage_limit () abstractmethod \u00a4 Queries the immediate voltage level of the power supply. Returns: Type Description float The voltage level in V. Source code in pyinst\\abc.py 1409 1410 1411 1412 1413 1414 1415 1416 @abstractmethod def get_voltage_limit ( self ) -> float : \"\"\" Queries the immediate voltage level of the power supply. Returns: The voltage level in V. \"\"\" measure_voltage () abstractmethod \u00a4 Queries the voltage measured at the sense terminals of the power supply. Returns: Type Description float The voltage measured in V. Source code in pyinst\\abc.py 1418 1419 1420 1421 1422 1423 1424 1425 @abstractmethod def measure_voltage ( self ) -> float : \"\"\"Queries the voltage measured at the sense terminals of the power supply. Returns: The voltage measured in V. \"\"\" set_current_limit ( value ) abstractmethod \u00a4 Sets the immediate current level of the power supply. Parameters: Name Type Description Default value int | float The current level in A. required Source code in pyinst\\abc.py 1427 1428 1429 1430 1431 1432 1433 1434 @abstractmethod def set_current_limit ( self , value : int | float ) -> None : \"\"\" Sets the immediate current level of the power supply. Args: value: The current level in A. \"\"\" get_current_limit () abstractmethod \u00a4 Queries the immediate current level of the power supply. Returns: Type Description float The current level in A. Source code in pyinst\\abc.py 1436 1437 1438 1439 1440 1441 1442 1443 @abstractmethod def get_current_limit ( self ) -> float : \"\"\" Queries the immediate current level of the power supply. Returns: The current level in A. \"\"\" measure_current () abstractmethod \u00a4 Queries the current measured across the current sense resistor inside the power supply. Returns: Type Description float The current measured in A. Source code in pyinst\\abc.py 1445 1446 1447 1448 1449 1450 1451 1452 @abstractmethod def measure_current ( self ) -> float : \"\"\"Queries the current measured across the current sense resistor inside the power supply. Returns: The current measured in A. \"\"\" TypePSwithOvpOcpFunctions \u00a4 Bases: TypePS ABC to define the interfaces of a Power Supply with OCP & OVP functions. set_ocp_level ( level ) abstractmethod \u00a4 Sets the current level at which the overcurrent protection (OCP) circuit will trip. If the peak output current exceeds the OCP level, then the output current is programmed to zero. You can use is_ocp_tripped() to query if the OCP circuit is tripped. An overcurrent condition can be cleared with the clear_ocp() method after the condition that caused the OCP trip is removed. Parameters: Name Type Description Default level int | float The OCP level in A. required Source code in pyinst\\abc.py 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 @abstractmethod def set_ocp_level ( self , level : int | float ) -> None : \"\"\" Sets the current level at which the overcurrent protection (OCP) circuit will trip. If the peak output current exceeds the OCP level, then the output current is programmed to zero. You can use `is_ocp_tripped()` to query if the OCP circuit is tripped. An overcurrent condition can be cleared with the `clear_ocp()` method after the condition that caused the OCP trip is removed. Args: level: The OCP level in A. \"\"\" get_ocp_level () abstractmethod \u00a4 Returns the overcurrent protection trip level presently programmed. See set_ocp_level() for more details. Returns: Type Description float The OCP level in A. Source code in pyinst\\abc.py 1475 1476 1477 1478 1479 1480 1481 1482 1483 @abstractmethod def get_ocp_level ( self ) -> float : \"\"\"Returns the overcurrent protection trip level presently programmed. See `set_ocp_level()` for more details. Returns: The OCP level in A. \"\"\" enable_ocp ( enable = True ) abstractmethod \u00a4 Enables (or disables) the overcurrent protection function of the power supply. Parameters: Name Type Description Default enable bool True = Enable, False = Disable. True Source code in pyinst\\abc.py 1485 1486 1487 1488 1489 1490 1491 1492 @abstractmethod def enable_ocp ( self , enable : bool = True ) -> None : \"\"\"Enables (or disables) the overcurrent protection function of the power supply. Args: enable: `True` = Enable, `False` = Disable. \"\"\" disable_ocp () abstractmethod \u00a4 Disables the overcurrent protection function of the power supply. Source code in pyinst\\abc.py 1494 1495 1496 1497 @abstractmethod def disable_ocp ( self ) -> None : \"\"\"Disables the overcurrent protection function of the power supply. \"\"\" is_ocp_enabled () abstractmethod \u00a4 Queries whether the overcurrent protection function of the power supply is enabled. Returns: Type Description bool Whether the OCP function is enabled. Source code in pyinst\\abc.py 1499 1500 1501 1502 1503 1504 1505 1506 @abstractmethod def is_ocp_enabled ( self ) -> bool : \"\"\"Queries whether the overcurrent protection function of the power supply is enabled. Returns: Whether the OCP function is enabled. \"\"\" is_ocp_tripped () abstractmethod \u00a4 Queries if the overcurrent protection circuit is tripped and not cleared. Returns: Type Description bool If the overcurrent protection circuit is tripped and not cleared. Source code in pyinst\\abc.py 1508 1509 1510 1511 1512 1513 1514 1515 @abstractmethod def is_ocp_tripped ( self ) -> bool : \"\"\"Queries if the overcurrent protection circuit is tripped and not cleared. Returns: If the overcurrent protection circuit is tripped and not cleared. \"\"\" clear_ocp () abstractmethod \u00a4 This method causes the overcurrent protection circuit to be cleared. Before using this method, lower the output current below the trip OCP point, or raise the OCP trip level above the output setting. Note Note that the overcurrent condition caused by an external source must be removed first before proceeding this method. Source code in pyinst\\abc.py 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 @abstractmethod def clear_ocp ( self ) -> None : \"\"\"This method causes the overcurrent protection circuit to be cleared. Before using this method, lower the output current below the trip OCP point, or raise the OCP trip level above the output setting. Note: Note that the overcurrent condition caused by an external source must be removed first before proceeding this method. \"\"\" set_ovp_level ( level ) abstractmethod \u00a4 Sets the voltage level at which the overvoltage protection (OVP) circuit will trip. If the peak output voltage exceeds the OVP level, then the power supply output is shorted by an internal SCR. You can use is_ovp_tripped() to query if the OVP circuit is tripped. An overvoltage condition can be cleared with the clear_ovp() method after the condition that caused the OVP trip is removed. Parameters: Name Type Description Default level int | float The OVP level in V. required Source code in pyinst\\abc.py 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 @abstractmethod def set_ovp_level ( self , level : int | float ) -> None : \"\"\" Sets the voltage level at which the overvoltage protection (OVP) circuit will trip. If the peak output voltage exceeds the OVP level, then the power supply output is shorted by an internal SCR. You can use `is_ovp_tripped()` to query if the OVP circuit is tripped. An overvoltage condition can be cleared with the `clear_ovp()` method after the condition that caused the OVP trip is removed. Args: level: The OVP level in V. \"\"\" get_ovp_level () abstractmethod \u00a4 Returns the overvoltage protection trip level presently programmed. See set_ovp_level() for more details. Returns: Type Description float The OVP level in V. Source code in pyinst\\abc.py 1543 1544 1545 1546 1547 1548 1549 1550 1551 @abstractmethod def get_ovp_level ( self ) -> float : \"\"\"Returns the overvoltage protection trip level presently programmed. See `set_ovp_level()` for more details. Returns: The OVP level in V. \"\"\" enable_ovp ( enable = True ) abstractmethod \u00a4 Enables (or disables) the overvoltage protection function of the power supply. Parameters: Name Type Description Default enable bool True = Enable, False = Disable. True Source code in pyinst\\abc.py 1553 1554 1555 1556 1557 1558 1559 1560 @abstractmethod def enable_ovp ( self , enable : bool = True ) -> None : \"\"\"Enables (or disables) the overvoltage protection function of the power supply. Args: enable: `True` = Enable, `False` = Disable. \"\"\" disable_ovp () abstractmethod \u00a4 Disables the overvoltage protection function of the power supply. Source code in pyinst\\abc.py 1562 1563 1564 1565 @abstractmethod def disable_ovp ( self ) -> None : \"\"\"Disables the overvoltage protection function of the power supply. \"\"\" is_ovp_enabled () abstractmethod \u00a4 Queries whether the overvoltage protection function of the power supply is enabled. Returns: Type Description bool Whether the OVP function is enabled. Source code in pyinst\\abc.py 1567 1568 1569 1570 1571 1572 1573 1574 @abstractmethod def is_ovp_enabled ( self ) -> bool : \"\"\"Queries whether the overvoltage protection function of the power supply is enabled. Returns: Whether the OVP function is enabled. \"\"\" is_ovp_tripped () abstractmethod \u00a4 Queries if the overvoltage protection circuit is tripped and not cleared. Returns: Type Description bool If the overvoltage protection circuit is tripped and not cleared. Source code in pyinst\\abc.py 1576 1577 1578 1579 1580 1581 1582 1583 @abstractmethod def is_ovp_tripped ( self ) -> bool : \"\"\"Queries if the overvoltage protection circuit is tripped and not cleared. Returns: If the overvoltage protection circuit is tripped and not cleared. \"\"\" clear_ovp () abstractmethod \u00a4 This method causes the overvoltage protection circuit to be cleared. Before sending this method, lower the output voltage below the trip OVP point, or raise the OVP trip level above the output setting. Note Note that the overvoltage condition caused by an external source must be removed first before proceeding this method. Source code in pyinst\\abc.py 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 @abstractmethod def clear_ovp ( self ) -> None : \"\"\"This method causes the overvoltage protection circuit to be cleared. Before sending this method, lower the output voltage below the trip OVP point, or raise the OVP trip level above the output setting. Note: Note that the overvoltage condition caused by an external source must be removed first before proceeding this method. \"\"\" TypePDLE \u00a4 Bases: OpticalFrequencySetter ABC to define the interfaces of a PDL Emulator. min_pdl () property abstractmethod \u00a4 The minimum settable PDL value. Source code in pyinst\\abc.py 1603 1604 1605 1606 @property @abstractmethod def min_pdl ( self ) -> float : \"\"\"The minimum settable PDL value.\"\"\" max_pdl () property abstractmethod \u00a4 The maximum settable PDL value. Source code in pyinst\\abc.py 1608 1609 1610 1611 @property @abstractmethod def max_pdl ( self ) -> float : \"\"\"The maximum settable PDL value.\"\"\" get_pdl_value () abstractmethod \u00a4 Returns: Type Description float The PDL setting value in dB. Source code in pyinst\\abc.py 1613 1614 1615 1616 1617 1618 @abstractmethod def get_pdl_value ( self ) -> float : \"\"\" Returns: The PDL setting value in dB. \"\"\" set_pdl_value ( value ) abstractmethod \u00a4 Parameters: Name Type Description Default value int | float The PDL setting value in dB. required Source code in pyinst\\abc.py 1620 1621 1622 1623 1624 1625 @abstractmethod def set_pdl_value ( self , value : int | float ) -> None : \"\"\" Args: value: The PDL setting value in dB. \"\"\" TypePOLC \u00a4 Bases: OpticalFrequencySetter ABC to define the interfaces of a Polarization Controller/Scrambler. start_scrambling ( mode , rate , ** params ) abstractmethod \u00a4 Start scrambling with the specified mode and rate. Parameters: Name Type Description Default mode str Scrambling mode. Valid options depends on specific model. required rate int | float Scrambling rate. Different mode may have different units. required **params Additional scrambling params if any. {} Source code in pyinst\\abc.py 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 @abstractmethod def start_scrambling ( self , mode : str , rate : int | float , ** params ) -> None : \"\"\" Start scrambling with the specified mode and rate. Args: mode: Scrambling mode. Valid options depends on specific model. rate: Scrambling rate. Different mode may have different units. **params: Additional scrambling params if any. \"\"\" stop_scrambling () abstractmethod \u00a4 Stop scrambling. Source code in pyinst\\abc.py 1644 1645 1646 @abstractmethod def stop_scrambling ( self ) -> None : \"\"\"Stop scrambling.\"\"\" TypePMDE \u00a4 Bases: OpticalFrequencySetter ABC to define the interfaces of a PMD Emulator. set_pmd_value ( pmd , sopmd ) abstractmethod \u00a4 Set PMD (DGD) and SOPMD (Second Order PMD) target value. Parameters: Name Type Description Default pmd int | float The DGD value in ps. required sopmd int | float The 2nd order pmd in ps**2. required Source code in pyinst\\abc.py 1654 1655 1656 1657 1658 1659 1660 1661 1662 @abstractmethod def set_pmd_value ( self , pmd : int | float , sopmd : int | float ) -> None : \"\"\" Set PMD (DGD) and SOPMD (Second Order PMD) target value. Args: pmd: The DGD value in ps. sopmd: The 2nd order pmd in ps**2. \"\"\" get_pmd_value () abstractmethod \u00a4 Get PMD (DGD) and SOPMD (Second Order PMD) target value. Returns: Name Type Description pmd float The DGD value in ps. sopmd float The 2nd order pmd in ps**2. Source code in pyinst\\abc.py 1664 1665 1666 1667 1668 1669 1670 1671 1672 @abstractmethod def get_pmd_value ( self ) -> Tuple [ float , float ]: \"\"\" Get PMD (DGD) and SOPMD (Second Order PMD) target value. Returns: pmd: The DGD value in ps. sopmd: The 2nd order pmd in ps**2. \"\"\"","title":"Abstract Base Classes"},{"location":"api/abc/#pyinst.abc.InstrumentMeta","text":"Bases: ABCMeta The meta class of BaseInstrument.","title":"InstrumentMeta"},{"location":"api/abc/#pyinst.abc.InstrumentMeta.ins_type","text":"The instrument type flag of the specific instrument model. Source code in pyinst\\abc.py 50 51 52 53 54 55 56 @property def ins_type ( cls : type ) -> InstrumentType : \"\"\"The instrument type flag of the specific instrument model.\"\"\" value = 0 for base in cls . mro ()[ 2 :]: value |= getattr ( base , 'ins_type' , 0 ) return value","title":"ins_type()"},{"location":"api/abc/#pyinst.abc.BaseInstrument","text":"ABC of all the instrument model classes. Parameters: Name Type Description Default resource_name str The instrument resource name. Please refer to resource_name property for more information. required Source code in pyinst\\abc.py 117 118 119 120 121 122 123 124 def __init__ ( self , resource_name : str ): \"\"\" Args: resource_name: The instrument resource name. Please refer to `resource_name` property for more information. \"\"\" self . __resource_name = resource_name super ( BaseInstrument , self ) . __init__ ()","title":"BaseInstrument"},{"location":"api/abc/#pyinst.abc.BaseInstrument.brand","text":"The brand/manufactory of the instrument. Source code in pyinst\\abc.py 62 63 64 65 @property @abstractmethod def brand ( self ) -> str : \"\"\"The brand/manufactory of the instrument.\"\"\"","title":"brand()"},{"location":"api/abc/#pyinst.abc.BaseInstrument.model","text":"The model name of the instrument. Source code in pyinst\\abc.py 67 68 69 70 @property @abstractmethod def model ( self ) -> str : \"\"\"The model name of the instrument.\"\"\"","title":"model()"},{"location":"api/abc/#pyinst.abc.BaseInstrument.details","text":"A map of information to describe the instrument. Source code in pyinst\\abc.py 72 73 74 75 76 77 @property def details ( self ) -> Mapping [ str , str ]: \"\"\" A map of information to describe the instrument. \"\"\" return {}","title":"details()"},{"location":"api/abc/#pyinst.abc.BaseInstrument.params","text":"A list of dict to define parameters required for object creation. This is mainly used for upper level (e.g. GUI) to render options. dict fields: name (str) : Required. The name of the param, exactly the same in __init__ method. type (str) : Required. options: int | str | bool . options (list) : Optional. Valid options. min (int) : Optional. For type int only. max (int) : Optional. For type int only. Examples: [ { \"name\" : \"slot\" , \"type\" : \"int\" , \"min\" : 1 , \"max\" : 10 }, { \"name\" : \"range_level\" , \"type\" : \"str\" , \"options\" : [ \"HIGH\" , \"LOW\" ] } ] Source code in pyinst\\abc.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 @property def params ( self ) -> List [ dict ]: \"\"\" A list of dict to define parameters required for object creation. This is mainly used for upper level (e.g. GUI) to render options. dict fields: - `name (str)`: Required. The name of the param, exactly the same in `__init__` method. - `type (str)`: Required. options: `int` | `str` | `bool`. - `options (list)`: Optional. Valid options. + `min (int)`: Optional. For type `int` only. + `max (int)`: Optional. For type `int` only. Examples: ``` python [ { \"name\": \"slot\", \"type\": \"int\", \"min\": 1, \"max\": 10 }, { \"name\": \"range_level\", \"type\": \"str\", \"options\": [\"HIGH\", \"LOW\"] } ] ``` \"\"\"","title":"params()"},{"location":"api/abc/#pyinst.abc.BaseInstrument.close","text":"Release the instrument resource. Source code in pyinst\\abc.py 139 140 141 @abstractmethod def close ( self ) -> None : \"\"\"Release the instrument resource.\"\"\"","title":"close()"},{"location":"api/abc/#pyinst.abc.BaseInstrument.resource_name","text":"For VISA compliant instruments, it is the resource name or alias of the VISA resource. For other instruments connected with serial port, it is the port name. For other instruments connected with USB, it is the S/N of the instrument or USB chip. Source code in pyinst\\abc.py 143 144 145 146 147 148 149 150 151 152 153 @property def resource_name ( self ) -> str : \"\"\" - For VISA compliant instruments, it is the resource name or alias of the VISA resource. - For other instruments connected with serial port, it is the port name. - For other instruments connected with USB, it is the S/N of the instrument or USB chip. \"\"\" return self . __resource_name","title":"resource_name()"},{"location":"api/abc/#pyinst.abc.BaseInstrument.create","text":"Create an instance of the instrument model. If an exception is raised during the instance creation, return None. Parameters: Name Type Description Default *args Directly passed to the instrument model class. () **kwargs Directly passed to the instrument model class. {} Returns: Type Description Optional [ Self ] The created instrument model class, or None if creation failed. Source code in pyinst\\abc.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 @classmethod def create ( cls , * args , ** kwargs ) -> Optional [ Self ]: \"\"\"Create an instance of the instrument model. If an exception is raised during the instance creation, return None. Args: *args: Directly passed to the instrument model class. **kwargs: Directly passed to the instrument model class. Returns: The created instrument model class, or None if creation failed. \"\"\" try : instance = cls ( * args , ** kwargs ) except : instance = None return instance","title":"create()"},{"location":"api/abc/#pyinst.abc.VisaInstrument","text":"Bases: BaseInstrument Base class of VISA compliant instruments that use message based communication. VisaInstrument creates a proxy object with pyvisa to communicate with VISA compliant instruments. Refer to PyVISA Documents for more information. Parameters: Name Type Description Default resource_name str Resource name or alias of the VISA resource to open. required read_termination str Read termination character. VI_READ_TERMINATION write_termination str Write termination character. VI_WRITE_TERMINATION timeout int Timeout in milliseconds for all resource I/O operations. VI_TIMEOUT open_timeout int If the access_mode parameter requests a lock, then this parameter specifies the absolute time period (in milliseconds) that the resource waits to get unlocked before this operation returns an error. VI_OPEN_TIMEOUT query_delay float Delay in seconds between write and read operations. VI_QUERY_DELAY encoding str Encoding used for read and write operations. 'ascii' **kwargs directly passed to rm.open_resource {} Source code in pyinst\\abc.py 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 def __init__ ( self , resource_name : str , read_termination : str = VI_READ_TERMINATION , write_termination : str = VI_WRITE_TERMINATION , timeout : int = VI_TIMEOUT , open_timeout : int = VI_OPEN_TIMEOUT , query_delay : float = VI_QUERY_DELAY , encoding : str = \"ascii\" , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. read_termination: Read termination character. write_termination: Write termination character. timeout: Timeout in milliseconds for all resource I/O operations. open_timeout: If the access_mode parameter requests a lock, then this parameter specifies the absolute time period (in milliseconds) that the resource waits to get unlocked before this operation returns an error. query_delay: Delay in seconds between write and read operations. encoding: Encoding used for read and write operations. **kwargs: directly passed to `rm.open_resource` \"\"\" super () . __init__ ( resource_name = resource_name ) rm = pyvisa . ResourceManager () self . _inst : pyvisa . resources . MessageBasedResource = rm . open_resource ( resource_name , read_termination = read_termination , write_termination = write_termination , open_timeout = open_timeout , timeout = timeout , query_delay = query_delay , encoding = encoding , ** kwargs ) self . _check_communication ()","title":"VisaInstrument"},{"location":"api/abc/#pyinst.abc.VisaInstrument.resource_name","text":"Resource name or alias of the VISA resource. Source code in pyinst\\abc.py 237 238 239 240 @property def resource_name ( self ) -> str : \"\"\"Resource name or alias of the VISA resource.\"\"\" return self . __resource_name","title":"resource_name()"},{"location":"api/abc/#pyinst.abc.VisaInstrument.resource_info","text":"Get the (extended) information of the VISA resource. Source code in pyinst\\abc.py 242 243 244 245 @property def resource_info ( self ) -> pyvisa . highlevel . ResourceInfo : \"\"\"Get the (extended) information of the VISA resource.\"\"\" return self . _inst . resource_info","title":"resource_info()"},{"location":"api/abc/#pyinst.abc.VisaInstrument.idn","text":"Returns a string that uniquely identifies the instrument. Source code in pyinst\\abc.py 247 248 249 250 @property def idn ( self ) -> str : \"\"\"Returns a string that uniquely identifies the instrument.\"\"\" return self . query ( '*IDN?' )","title":"idn()"},{"location":"api/abc/#pyinst.abc.VisaInstrument.opc","text":"Operation complete query. Source code in pyinst\\abc.py 252 253 254 255 @property def opc ( self ) -> str : \"\"\"Operation complete query.\"\"\" return self . query ( '*OPC?' )","title":"opc()"},{"location":"api/abc/#pyinst.abc.VisaInstrument.close","text":"Closes the VISA session and marks the handle as invalid. Source code in pyinst\\abc.py 257 258 259 260 261 def close ( self ) -> None : \"\"\" Closes the VISA session and marks the handle as invalid. \"\"\" self . _inst . close ()","title":"close()"},{"location":"api/abc/#pyinst.abc.VisaInstrument.command","text":"Write a VISA command without read back. Alias of write(message). Parameters: Name Type Description Default message str The message to be sent. required Returns: Type Description int Number of bytes written. Source code in pyinst\\abc.py 276 277 278 279 280 281 282 283 284 285 286 287 288 def command ( self , message : str ) -> int : \"\"\" Write a VISA command without read back. Alias of write(message). Args: message: The message to be sent. Returns: Number of bytes written. \"\"\" return self . write ( message )","title":"command()"},{"location":"api/abc/#pyinst.abc.VisaInstrument.write","text":"Write a string message to the device. The write_termination is always appended to it. Parameters: Name Type Description Default message str The message to be sent. required termination Optional [ str ] Alternative character termination to use. If None, the value of write_termination passed to __init__ method is used. Defaults to None. None encoding Optional [ str ] Alternative encoding to use to turn str into bytes. If None, the value of encoding passed to __init__ method is used. Defaults to None. None Returns: Type Description int Number of bytes written. Source code in pyinst\\abc.py 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 def write ( self , message : str , termination : Optional [ str ] = None , encoding : Optional [ str ] = None , ) -> int : \"\"\"Write a string message to the device. The write_termination is always appended to it. Args: message: The message to be sent. termination: Alternative character termination to use. If None, the value of write_termination passed to `__init__` method is used. Defaults to None. encoding: Alternative encoding to use to turn str into bytes. If None, the value of encoding passed to `__init__` method is used. Defaults to None. Returns: Number of bytes written. \"\"\" return self . _inst . write ( message , termination , encoding )","title":"write()"},{"location":"api/abc/#pyinst.abc.VisaInstrument.read","text":"Read a string from the device. Reading stops when the device stops sending (e.g. by setting appropriate bus lines), or the termination characters sequence was detected. Attention: Only the last character of the termination characters is really used to stop reading, however, the whole sequence is compared to the ending of the read string message. If they don't match, a warning is issued. Parameters: Name Type Description Default termination Optional [ str ] Alternative character termination to use. If None, the value of write_termination passed to __init__ method is used. Defaults to None. None encoding Optional [ str ] Alternative encoding to use to turn bytes into str. If None, the value of encoding passed to __init__ method is used. Defaults to None. None Returns: Type Description str Message read from the instrument and decoded. Source code in pyinst\\abc.py 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 def read ( self , termination : Optional [ str ] = None , encoding : Optional [ str ] = None ) -> str : \"\"\"Read a string from the device. Reading stops when the device stops sending (e.g. by setting appropriate bus lines), or the termination characters sequence was detected. Attention: Only the last character of the termination characters is really used to stop reading, however, the whole sequence is compared to the ending of the read string message. If they don't match, a warning is issued. Args: termination: Alternative character termination to use. If None, the value of write_termination passed to `__init__` method is used. Defaults to None. encoding: Alternative encoding to use to turn bytes into str. If None, the value of encoding passed to `__init__` method is used. Defaults to None. Returns: Message read from the instrument and decoded. \"\"\" return self . _inst . read ( termination , encoding )","title":"read()"},{"location":"api/abc/#pyinst.abc.VisaInstrument.query","text":"A combination of write(message) and read() Parameters: Name Type Description Default message str The message to send. required delay Optional [ float ] Delay in seconds between write and read operations. If None, defaults to query_delay passed to __init__ method. None Returns: Type Description str Answer from the device. Source code in pyinst\\abc.py 339 340 341 342 343 344 345 346 347 348 349 350 351 def query ( self , message : str , delay : Optional [ float ] = None ) -> str : \"\"\"A combination of write(message) and read() Args: message: The message to send. delay: Delay in seconds between write and read operations. If None, defaults to query_delay passed to `__init__` method. Returns: Answer from the device. \"\"\" return self . _inst . query ( message , delay )","title":"query()"},{"location":"api/abc/#pyinst.abc.VisaInstrument.read_binary_values","text":"Read values from the device in binary format returning an iterable of values. Parameters: Name Type Description Default datatype pyvisa . util . BINARY_DATATYPES Format string for a single element. See struct module. 'f' by default. 'f' is_big_endian bool Are the data in big or little endian order. Defaults to False. False container Type | Callable [[ Iterable ], Sequence ] Container type to use for the output data. Possible values are: list, tuple, np.ndarray, etc, Default to list. list header_fmt pyvisa . util . BINARY_HEADERS Format of the header prefixing the data. Defaults to 'ieee'. 'ieee' expect_termination bool When set to False, the expected length of the binary values block does not account for the final termination character (the read termination). Defaults to True. True data_points int Number of points expected in the block. This is used only if the instrument does not report it itself. This will be converted in a number of bytes based on the datatype. Defaults to 0. 0 chunk_size Optional [ int ] Size of the chunks to read from the device. Using larger chunks may be faster for large amount of data. None Returns: Type Description Sequence [ int | float ] Data read from the device. Source code in pyinst\\abc.py 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 def read_binary_values ( self , datatype : pyvisa . util . BINARY_DATATYPES = \"f\" , is_big_endian : bool = False , container : Type | Callable [[ Iterable ], Sequence ] = list , header_fmt : pyvisa . util . BINARY_HEADERS = \"ieee\" , expect_termination : bool = True , data_points : int = 0 , chunk_size : Optional [ int ] = None , ) -> Sequence [ int | float ]: \"\"\"Read values from the device in binary format returning an iterable of values. Args: datatype: Format string for a single element. See struct module. 'f' by default. is_big_endian: Are the data in big or little endian order. Defaults to False. container: Container type to use for the output data. Possible values are: list, tuple, np.ndarray, etc, Default to list. header_fmt: Format of the header prefixing the data. Defaults to 'ieee'. expect_termination: When set to False, the expected length of the binary values block does not account for the final termination character (the read termination). Defaults to True. data_points: Number of points expected in the block. This is used only if the instrument does not report it itself. This will be converted in a number of bytes based on the datatype. Defaults to 0. chunk_size: Size of the chunks to read from the device. Using larger chunks may be faster for large amount of data. Returns: Data read from the device. \"\"\" return self . _inst . read_binary_values ( datatype , is_big_endian , container , header_fmt , expect_termination , data_points , chunk_size )","title":"read_binary_values()"},{"location":"api/abc/#pyinst.abc.VisaInstrument.query_binary_values","text":"Query the device for values in binary format returning an iterable of values. Parameters: Name Type Description Default message str The message to send. required datatype pyvisa . util . BINARY_DATATYPES Format string for a single element. See struct module. 'f' by default. 'f' is_big_endian bool Are the data in big or little endian order. Defaults to False. False container Type | Callable [[ Iterable ], Sequence ] Container type to use for the output data. Possible values are: list, tuple, np.ndarray, etc, Default to list. list delay Optional [ float ] Delay in seconds between write and read operations. If None, defaults to query_delay passed to __init__ method. None header_fmt pyvisa . util . BINARY_HEADERS Format of the header prefixing the data. Defaults to 'ieee'. 'ieee' expect_termination bool When set to False, the expected length of the binary values block does not account for the final termination character (the read termination). Defaults to True. True data_points int Number of points expected in the block. This is used only if the instrument does not report it itself. This will be converted in a number of bytes based on the datatype. Defaults to 0. 0 chunk_size Optional [ int ] Size of the chunks to read from the device. Using larger chunks may be faster for large amount of data. None Returns: Type Description Sequence [ int | float ] Data read from the device. Source code in pyinst\\abc.py 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 def query_binary_values ( self , message : str , datatype : pyvisa . util . BINARY_DATATYPES = \"f\" , is_big_endian : bool = False , container : Type | Callable [[ Iterable ], Sequence ] = list , delay : Optional [ float ] = None , header_fmt : pyvisa . util . BINARY_HEADERS = \"ieee\" , expect_termination : bool = True , data_points : int = 0 , chunk_size : Optional [ int ] = None , ) -> Sequence [ int | float ]: \"\"\"Query the device for values in binary format returning an iterable of values. Args: message: The message to send. datatype: Format string for a single element. See struct module. 'f' by default. is_big_endian: Are the data in big or little endian order. Defaults to False. container: Container type to use for the output data. Possible values are: list, tuple, np.ndarray, etc, Default to list. delay: Delay in seconds between write and read operations. If None, defaults to query_delay passed to `__init__` method. header_fmt: Format of the header prefixing the data. Defaults to 'ieee'. expect_termination: When set to False, the expected length of the binary values block does not account for the final termination character (the read termination). Defaults to True. data_points: Number of points expected in the block. This is used only if the instrument does not report it itself. This will be converted in a number of bytes based on the datatype. Defaults to 0. chunk_size: Size of the chunks to read from the device. Using larger chunks may be faster for large amount of data. Returns: Data read from the device. \"\"\" return self . _inst . query_binary_values ( message , datatype , is_big_endian , container , delay , header_fmt , expect_termination , data_points , chunk_size )","title":"query_binary_values()"},{"location":"api/abc/#pyinst.abc.VisaInstrument.set_visa_attribute","text":"Set the state of an attribute in this resource. One should prefer the dedicated descriptor for often used attributes since those perform checks and automatic conversion on the value. Parameters: Name Type Description Default name pyvisa . constants . ResourceAttribute Attribute for which the state is to be modified. required state Any The state of the attribute to be set for the specified object. required Returns: Type Description pyvisa . constants . StatusCode Return value of the library call. Source code in pyinst\\abc.py 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 def set_visa_attribute ( self , name : pyvisa . constants . ResourceAttribute , state : Any ) -> pyvisa . constants . StatusCode : \"\"\"Set the state of an attribute in this resource. One should prefer the dedicated descriptor for often used attributes since those perform checks and automatic conversion on the value. Args: name: Attribute for which the state is to be modified. state: The state of the attribute to be set for the specified object. Returns: Return value of the library call. \"\"\" return self . _inst . set_visa_attribute ( name , state )","title":"set_visa_attribute()"},{"location":"api/abc/#pyinst.abc.VisaInstrument.get_visa_attribute","text":"Retrieves the state of an attribute in this resource. One should prefer the dedicated descriptor for often used attributes since those perform checks and automatic conversion on the value. Parameters: Name Type Description Default name pyvisa . constants . ResourceAttribute Resource attribute for which the state query is made. required Returns: Type Description Any The state of the queried attribute for a specified resource. Source code in pyinst\\abc.py 454 455 456 457 458 459 460 461 462 463 464 465 466 def get_visa_attribute ( self , name : pyvisa . constants . ResourceAttribute ) -> Any : \"\"\"Retrieves the state of an attribute in this resource. One should prefer the dedicated descriptor for often used attributes since those perform checks and automatic conversion on the value. Args: name: Resource attribute for which the state query is made. Returns: The state of the queried attribute for a specified resource. \"\"\" return self . _inst . get_visa_attribute ( name )","title":"get_visa_attribute()"},{"location":"api/abc/#pyinst.abc.RawSerialInstrument","text":"Bases: BaseInstrument Instrument based on raw serial communication. Compared to VISA compliant instruments, SerialRawInstrument do not have a common application architecture. It depends on the manufactory. SerialRawInstrument creates a proxy object using pySerial to communicate with instruments. Refer to pySerial Documents for more information. Parameters: Name Type Description Default resource_name str Serial port name. required baudrate int Baud rate such as 9600 or 115200 etc.. required bytesize SerialByteSize Number of data bits. SerialByteSize.EIGHTBITS parity SerialParity Parity checking. SerialParity.NONE stopbits SerialStopBits Number of stop bits. SerialStopBits.ONE read_termination str Read termination character. SERIAL_READ_TERMINATION write_termination str Write termination character. SERIAL_WRITE_TERMINATION read_timeout int Timeout in milliseconds for read operations. SERIAL_READ_TIMEOUT write_timeout int Timeout in milliseconds for write operations. SERIAL_WRITE_TIMEOUT query_delay float Delay in seconds between write and read operations. SERIAL_QUERY_DELAY encoding str Encoding used for read and write operations. 'ascii' Source code in pyinst\\abc.py 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 def __init__ ( self , resource_name : str , baudrate : int , bytesize : SerialByteSize = SerialByteSize . EIGHTBITS , parity : SerialParity = SerialParity . NONE , stopbits : SerialStopBits = SerialStopBits . ONE , read_termination : str = SERIAL_READ_TERMINATION , write_termination : str = SERIAL_WRITE_TERMINATION , read_timeout : int = SERIAL_READ_TIMEOUT , write_timeout : int = SERIAL_WRITE_TIMEOUT , query_delay : float = SERIAL_QUERY_DELAY , encoding : str = \"ascii\" , ** kwargs ): \"\"\" Args: resource_name: Serial port name. baudrate: Baud rate such as 9600 or 115200 etc.. bytesize: Number of data bits. parity: Parity checking. stopbits: Number of stop bits. read_termination: Read termination character. write_termination: Write termination character. read_timeout: Timeout in milliseconds for read operations. write_timeout: Timeout in milliseconds for write operations. query_delay: Delay in seconds between write and read operations. encoding: Encoding used for read and write operations. \"\"\" __serial = serial . Serial ( port = resource_name , baudrate = baudrate , bytesize = bytesize . value , parity = parity . value , stopbits = stopbits . value , timeout = read_timeout , write_timeout = write_timeout , ) self . __serial = __serial self . __read_termination = read_termination self . __write_termination = write_termination self . __encoding = encoding self . __query_delay = query_delay super () . __init__ ( resource_name = resource_name )","title":"RawSerialInstrument"},{"location":"api/abc/#pyinst.abc.RawSerialInstrument.close","text":"Close the serial port immediately. Source code in pyinst\\abc.py 532 533 534 def close ( self ) -> None : \"\"\"Close the serial port immediately.\"\"\" self . __serial . close ()","title":"close()"},{"location":"api/abc/#pyinst.abc.RawSerialInstrument.command","text":"Write a serial command without read back. Alias of write(message). Parameters: Name Type Description Default message str message to be sent. required Returns: Type Description int Number of bytes written. Source code in pyinst\\abc.py 536 537 538 539 540 541 542 543 544 545 546 547 548 def command ( self , message : str ) -> int : \"\"\" Write a serial command without read back. Alias of write(message). Args: message: message to be sent. Returns: Number of bytes written. \"\"\" return self . write ( message )","title":"command()"},{"location":"api/abc/#pyinst.abc.RawSerialInstrument.write","text":"Write a string message to the device. The write_termination is always appended to it. Parameters: Name Type Description Default message str message to be sent. required termination Optional [ str ] Alternative character termination to use. If None, the value of write_termination passed to __init__ method is used. Defaults to None. None encoding Optional [ str ] Alternative encoding to use to turn str into bytes. If None, the value of encoding passed to __init__ method is used. Defaults to None. None Returns: Type Description int Number of bytes written. Source code in pyinst\\abc.py 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 def write ( self , message : str , termination : Optional [ str ] = None , encoding : Optional [ str ] = None , ) -> int : \"\"\"Write a string message to the device. The write_termination is always appended to it. Args: message: message to be sent. termination: Alternative character termination to use. If None, the value of write_termination passed to `__init__` method is used. Defaults to None. encoding: Alternative encoding to use to turn str into bytes. If None, the value of encoding passed to `__init__` method is used. Defaults to None. Returns: Number of bytes written. \"\"\" tx_str = ' {message}{term} ' . format ( message = message , term = termination or self . __write_termination ) tx_bytes = tx_str . encode ( encoding or self . __encoding ) # clear input buffer so the data buffered before command is cleared self . __serial . reset_input_buffer () return self . __serial . write ( tx_bytes )","title":"write()"},{"location":"api/abc/#pyinst.abc.RawSerialInstrument.read","text":"Read a string from the device. Reading stops when the device stops sending, or the termination characters sequence was detected. Parameters: Name Type Description Default termination Optional [ str ] Alternative character termination to use. If None, the value of write_termination passed to __init__ method is used. Defaults to None. None encoding Optional [ str ] Alternative encoding to use to turn bytes into str. If None, the value of encoding passed to __init__ method is used. Defaults to None. None Returns: Type Description str Message read from the instrument and decoded. Source code in pyinst\\abc.py 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 def read ( self , termination : Optional [ str ] = None , encoding : Optional [ str ] = None ) -> str : \"\"\"Read a string from the device. Reading stops when the device stops sending, or the termination characters sequence was detected. Args: termination: Alternative character termination to use. If None, the value of write_termination passed to `__init__` method is used. Defaults to None. encoding: Alternative encoding to use to turn bytes into str. If None, the value of encoding passed to `__init__` method is used. Defaults to None. Returns: Message read from the instrument and decoded. \"\"\" buffer = bytes () term = termination or self . __read_termination encoding = encoding or self . __encoding while True : rx = self . __serial . read () if not rx : raise InstrIOError ( 'Timeout before read_termination received.' ) buffer += rx if buffer . endswith ( term . encode ( encoding )): break return buffer . decode ( encoding ) . rstrip ( term )","title":"read()"},{"location":"api/abc/#pyinst.abc.RawSerialInstrument.query","text":"A combination of write(message) and read() Parameters: Name Type Description Default message str The message to send. required delay Optional [ float ] Delay in seconds between write and read operations. If None, defaults to query_delay passed to __init__ method. None Returns: Type Description str Answer from the device. Source code in pyinst\\abc.py 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 def query ( self , message : str , delay : Optional [ float ] = None ) -> str : \"\"\"A combination of write(message) and read() Args: message: The message to send. delay: Delay in seconds between write and read operations. If None, defaults to query_delay passed to `__init__` method. Returns: Answer from the device. \"\"\" self . write ( message ) time . sleep ( delay or self . __query_delay ) return self . read ()","title":"query()"},{"location":"api/abc/#pyinst.abc.OpticalFrequencySetter","text":"Bases: ABC Instrument with optical frequency/wavelength setting.","title":"OpticalFrequencySetter"},{"location":"api/abc/#pyinst.abc.OpticalFrequencySetter.min_frequency","text":"The minimum settable optical frequency value in THz. Source code in pyinst\\abc.py 635 636 637 638 639 @property @abstractmethod def min_frequency ( self ) -> float : \"\"\"The minimum settable optical frequency value in THz.\"\"\" return LIGHTSPEED / self . max_wavelength","title":"min_frequency()"},{"location":"api/abc/#pyinst.abc.OpticalFrequencySetter.max_frequency","text":"The maximum settable optical frequency value in THz. Source code in pyinst\\abc.py 641 642 643 644 645 @property @abstractmethod def max_frequency ( self ) -> float : \"\"\"The maximum settable optical frequency value in THz.\"\"\" return LIGHTSPEED / self . min_wavelength","title":"max_frequency()"},{"location":"api/abc/#pyinst.abc.OpticalFrequencySetter.min_wavelength","text":"The minimum settable optical wavelength value in nm. Source code in pyinst\\abc.py 647 648 649 650 651 @property @abstractmethod def min_wavelength ( self ) -> float : \"\"\"The minimum settable optical wavelength value in nm.\"\"\" return LIGHTSPEED / self . max_frequency","title":"min_wavelength()"},{"location":"api/abc/#pyinst.abc.OpticalFrequencySetter.max_wavelength","text":"The maximum settable optical wavelength value in nm. Source code in pyinst\\abc.py 653 654 655 656 657 @property @abstractmethod def max_wavelength ( self ) -> float : \"\"\"The maximum settable optical wavelength value in nm.\"\"\" return LIGHTSPEED / self . min_frequency","title":"max_wavelength()"},{"location":"api/abc/#pyinst.abc.OpticalFrequencySetter.get_frequency","text":"Queries the optical frequency setting of the instrument in THz. Returns: Type Description float The optical frequency setting value in THz. Source code in pyinst\\abc.py 659 660 661 662 663 664 665 666 667 @abstractmethod def get_frequency ( self ) -> float : \"\"\" Queries the optical frequency setting of the instrument in THz. Returns: The optical frequency setting value in THz. \"\"\" return round ( LIGHTSPEED / self . get_wavelength (), 6 )","title":"get_frequency()"},{"location":"api/abc/#pyinst.abc.OpticalFrequencySetter.set_frequency","text":"Set optical frequency. Parameters: Name Type Description Default frequency int | float The optical frequency setting in THz. required Source code in pyinst\\abc.py 669 670 671 672 673 674 675 676 677 @abstractmethod def set_frequency ( self , frequency : int | float ) -> None : \"\"\"Set optical frequency. Args: frequency: The optical frequency setting in THz. \"\"\" wavelength = round ( LIGHTSPEED / frequency , 6 ) self . set_wavelength ( wavelength )","title":"set_frequency()"},{"location":"api/abc/#pyinst.abc.OpticalFrequencySetter.get_wavelength","text":"Queries the optical wavelength setting of the instrument in nm. Returns: Type Description float The optical wavelength setting value in nm. Source code in pyinst\\abc.py 679 680 681 682 683 684 685 686 @abstractmethod def get_wavelength ( self ) -> float : \"\"\"Queries the optical wavelength setting of the instrument in nm. Returns: The optical wavelength setting value in nm. \"\"\" return round ( LIGHTSPEED / self . get_frequency (), 6 )","title":"get_wavelength()"},{"location":"api/abc/#pyinst.abc.OpticalFrequencySetter.set_wavelength","text":"Set optical wavelength. Parameters: Name Type Description Default wavelength int | float The optical wavelength setting in nm. required Source code in pyinst\\abc.py 688 689 690 691 692 693 694 695 696 @abstractmethod def set_wavelength ( self , wavelength : int | float ) -> None : \"\"\"Set optical wavelength. Args: wavelength: The optical wavelength setting in nm. \"\"\" frequency = round ( LIGHTSPEED / wavelength , 6 ) self . set_frequency ( frequency )","title":"set_wavelength()"},{"location":"api/abc/#pyinst.abc.TypeOPM","text":"Bases: OpticalFrequencySetter ABC to define the interfaces of an Optical Power Meter.","title":"TypeOPM"},{"location":"api/abc/#pyinst.abc.TypeOPM.min_avg_time","text":"The minimum averaging time in ms. Source code in pyinst\\abc.py 704 705 706 707 @property @abstractmethod def min_avg_time ( self ) -> float : \"\"\"The minimum averaging time in ms.\"\"\"","title":"min_avg_time()"},{"location":"api/abc/#pyinst.abc.TypeOPM.max_avg_time","text":"The maximum averaging time in ms. Source code in pyinst\\abc.py 709 710 711 712 @property @abstractmethod def max_avg_time ( self ) -> float : \"\"\"The maximum averaging time in ms.\"\"\"","title":"max_avg_time()"},{"location":"api/abc/#pyinst.abc.TypeOPM.min_pow_cal","text":"The minimum power calibration value in dB. Source code in pyinst\\abc.py 714 715 716 717 @property @abstractmethod def min_pow_cal ( self ) -> float : \"\"\"The minimum power calibration value in dB.\"\"\"","title":"min_pow_cal()"},{"location":"api/abc/#pyinst.abc.TypeOPM.max_pow_cal","text":"The maximum power calibration value in dB. Source code in pyinst\\abc.py 719 720 721 722 @property @abstractmethod def max_pow_cal ( self ) -> float : \"\"\"The maximum power calibration value in dB.\"\"\"","title":"max_pow_cal()"},{"location":"api/abc/#pyinst.abc.TypeOPM.get_power_value","text":"Fetch the value of measured optical power in current unit setting. The measured value includes the power calibration. Measured value (dBm) = the actual measured value (dBm) + power calibration (dB) Refer to get_pow_cal and set_pow_cal to operate with the power calibration. Note It is possible that some OPM models defined the power calibration opposite in sign, but it is normalized in pyinst. Please refer to the math function above. Returns: Type Description float The value of the optical power. Source code in pyinst\\abc.py 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 @abstractmethod def get_power_value ( self ) -> float : \"\"\"Fetch the value of measured optical power in current unit setting. The measured value includes the power calibration. Measured value (dBm) = the actual measured value (dBm) + power calibration (dB) Refer to `get_pow_cal` and `set_pow_cal` to operate with the power calibration. Note: It is possible that some OPM models defined the power calibration opposite in sign, but it is normalized in pyinst. Please refer to the math function above. Returns: The value of the optical power. \"\"\"","title":"get_power_value()"},{"location":"api/abc/#pyinst.abc.TypeOPM.get_power_unit","text":"Get optical power unit setting. Returns: Type Description OpticalPowerUnit The unit of the optical power. Source code in pyinst\\abc.py 743 744 745 746 747 748 749 @abstractmethod def get_power_unit ( self ) -> OpticalPowerUnit : \"\"\"Get optical power unit setting. Returns: The unit of the optical power. \"\"\"","title":"get_power_unit()"},{"location":"api/abc/#pyinst.abc.TypeOPM.set_power_unit","text":"Set the unit of optical power. Parameters: Name Type Description Default unit OpticalPowerUnit The unit of the optical power. required Source code in pyinst\\abc.py 751 752 753 754 755 756 757 @abstractmethod def set_power_unit ( self , unit : OpticalPowerUnit ) -> None : \"\"\"Set the unit of optical power. Args: unit: The unit of the optical power. \"\"\"","title":"set_power_unit()"},{"location":"api/abc/#pyinst.abc.TypeOPM.get_power","text":"Queries the measured optical power value and unit. Returns: Name Type Description value float The value of the optical power. unit OpticalPowerUnit The unit of the optical power. Source code in pyinst\\abc.py 759 760 761 762 763 764 765 766 def get_power ( self ) -> Tuple [ float , OpticalPowerUnit ]: \"\"\"Queries the measured optical power value and unit. Returns: value: The value of the optical power. unit: The unit of the optical power. \"\"\" return self . get_power_value (), self . get_power_unit ()","title":"get_power()"},{"location":"api/abc/#pyinst.abc.TypeOPM.get_dbm_value","text":"Returns the optical power value measured in dBm. If the power unit setting is W, a math conversion will be performed. Returns: Type Description float The value of the optical power in dBm. Source code in pyinst\\abc.py 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 def get_dbm_value ( self ) -> float : \"\"\"Returns the optical power value measured in dBm. If the power unit setting is W, a math conversion will be performed. Returns: The value of the optical power in dBm. \"\"\" unit = self . get_power_unit () value = self . get_power_value () if unit == OpticalPowerUnit . DBM : return value else : return w_to_dbm ( value )","title":"get_dbm_value()"},{"location":"api/abc/#pyinst.abc.TypeOPM.get_w_value","text":"Returns the optical power value measured in W. If the power unit setting is dBm, a math conversion will be performed. Returns: Type Description float The value of the optical power in W. Source code in pyinst\\abc.py 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 def get_w_value ( self ) -> float : \"\"\"Returns the optical power value measured in W. If the power unit setting is dBm, a math conversion will be performed. Returns: The value of the optical power in W. \"\"\" unit = self . get_power_unit () value = self . get_power_value () if unit == OpticalPowerUnit . W : return value else : return dbm_to_w ( value )","title":"get_w_value()"},{"location":"api/abc/#pyinst.abc.TypeOPM.get_pow_cal","text":"Get the power calibration offset in dB. Returns: Type Description float The power calibration offset in dB. Source code in pyinst\\abc.py 800 801 802 803 804 805 806 807 @abstractmethod def get_pow_cal ( self ) -> float : \"\"\" Get the power calibration offset in dB. Returns: The power calibration offset in dB. \"\"\"","title":"get_pow_cal()"},{"location":"api/abc/#pyinst.abc.TypeOPM.set_pow_cal","text":"Set the power calibration offset in dB. Parameters: Name Type Description Default value int | float The power calibration offset in dB. required Source code in pyinst\\abc.py 809 810 811 812 813 814 815 816 @abstractmethod def set_pow_cal ( self , value : int | float ) -> None : \"\"\" Set the power calibration offset in dB. Args: value: The power calibration offset in dB. \"\"\"","title":"set_pow_cal()"},{"location":"api/abc/#pyinst.abc.TypeOPM.get_avg_time","text":"Get the averaging time in ms. Returns: Type Description float The averaging time in ms. Source code in pyinst\\abc.py 818 819 820 821 822 823 824 825 @abstractmethod def get_avg_time ( self ) -> float : \"\"\" Get the averaging time in ms. Returns: The averaging time in ms. \"\"\"","title":"get_avg_time()"},{"location":"api/abc/#pyinst.abc.TypeOPM.set_avg_time","text":"Set the averaging time in ms. Parameters: Name Type Description Default value int | float The averaging time in ms. required Source code in pyinst\\abc.py 827 828 829 830 831 832 833 834 @abstractmethod def set_avg_time ( self , value : int | float ) -> None : \"\"\" Set the averaging time in ms. Args: value: The averaging time in ms. \"\"\"","title":"set_avg_time()"},{"location":"api/abc/#pyinst.abc.TypeVOA","text":"Bases: OpticalFrequencySetter ABC to define the interfaces of a Variable Optical Attenuator.","title":"TypeVOA"},{"location":"api/abc/#pyinst.abc.TypeVOA.min_att","text":"Minimum settable attenuation in dB. The minimum settable attenuation = 0 dB + the optical attenuation offset value. Source code in pyinst\\abc.py 844 845 846 847 848 849 850 851 @property @abstractmethod def min_att ( self ) -> float : \"\"\"Minimum settable attenuation in dB. The minimum settable attenuation = 0 dB + the optical attenuation offset value. \"\"\"","title":"min_att()"},{"location":"api/abc/#pyinst.abc.TypeVOA.max_att","text":"Maximum settable attenuation in dB. The maximum settable attenuation = The maximum attenuation + the optical attenuation offset value. Source code in pyinst\\abc.py 853 854 855 856 857 858 859 860 @property @abstractmethod def max_att ( self ) -> float : \"\"\"Maximum settable attenuation in dB. The maximum settable attenuation = The maximum attenuation + the optical attenuation offset value. \"\"\"","title":"max_att()"},{"location":"api/abc/#pyinst.abc.TypeVOA.min_att_offset","text":"Minimum attenuation offset value in dB. Source code in pyinst\\abc.py 862 863 864 865 @property @abstractmethod def min_att_offset ( self ) -> float : \"\"\"Minimum attenuation offset value in dB.\"\"\"","title":"min_att_offset()"},{"location":"api/abc/#pyinst.abc.TypeVOA.max_att_offset","text":"Maximum attenuation offset value in dB. Source code in pyinst\\abc.py 867 868 869 870 @property @abstractmethod def max_att_offset ( self ) -> float : \"\"\"Maximum attenuation offset value in dB.\"\"\"","title":"max_att_offset()"},{"location":"api/abc/#pyinst.abc.TypeVOA.enable","text":"Enable (disable) the optical output. Parameters: Name Type Description Default en bool True = Enable, False = Disable. True Source code in pyinst\\abc.py 872 873 874 875 876 877 878 879 @abstractmethod def enable ( self , en : bool = True ) -> None : \"\"\" Enable (disable) the optical output. Args: en: True = Enable, False = Disable. \"\"\"","title":"enable()"},{"location":"api/abc/#pyinst.abc.TypeVOA.disable","text":"Disable the optical output. Source code in pyinst\\abc.py 881 882 883 @abstractmethod def disable ( self ) -> None : \"\"\"Disable the optical output.\"\"\"","title":"disable()"},{"location":"api/abc/#pyinst.abc.TypeVOA.is_enabled","text":"Returns: Type Description bool Whether the optical output is enabled. Source code in pyinst\\abc.py 885 886 887 888 889 890 @abstractmethod def is_enabled ( self ) -> bool : \"\"\" Returns: Whether the optical output is enabled. \"\"\"","title":"is_enabled()"},{"location":"api/abc/#pyinst.abc.TypeVOA.get_att","text":"Get the current attenuation value in dB. Includes the attenuation offset. Queried attenuator = the actual attenuator value + attenuator offset Use get_att_offset and set_att_offset to operate with the attenuator offset. Note It is possible that some VOA models defined the attenuation offset opposite in sign. But it is normalized in pyinst to align with the math function above. Returns: Type Description float The attenuation value in dB. Source code in pyinst\\abc.py 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 @abstractmethod def get_att ( self ) -> float : \"\"\" Get the current attenuation value in dB. Includes the attenuation offset. Queried attenuator = the actual attenuator value + attenuator offset Use `get_att_offset` and `set_att_offset` to operate with the attenuator offset. Note: It is possible that some VOA models defined the attenuation offset opposite in sign. But it is normalized in pyinst to align with the math function above. Returns: The attenuation value in dB. \"\"\"","title":"get_att()"},{"location":"api/abc/#pyinst.abc.TypeVOA.set_att","text":"Set attenuation value in dB. Includes the attenuation offset. Refer to get_att for more information. Parameters: Name Type Description Default att int | float The attenuation value in dB. required Source code in pyinst\\abc.py 913 914 915 916 917 918 919 920 921 922 923 @abstractmethod def set_att ( self , att : int | float ) -> None : \"\"\" Set attenuation value in dB. Includes the attenuation offset. Refer to `get_att` for more information. Args: att: The attenuation value in dB. \"\"\"","title":"set_att()"},{"location":"api/abc/#pyinst.abc.TypeVOA.get_att_offset","text":"Get the attenuation offset value in dB. Returns: Type Description float The attenuation offset in dB. Source code in pyinst\\abc.py 925 926 927 928 929 930 931 932 @abstractmethod def get_att_offset ( self ) -> float : \"\"\" Get the attenuation offset value in dB. Returns: The attenuation offset in dB. \"\"\"","title":"get_att_offset()"},{"location":"api/abc/#pyinst.abc.TypeVOA.set_att_offset","text":"Set the attenuation offset value in dB. Parameters: Name Type Description Default offset int | float The attenuation offset in dB. required Source code in pyinst\\abc.py 934 935 936 937 938 939 940 941 @abstractmethod def set_att_offset ( self , offset : int | float ) -> None : \"\"\" Set the attenuation offset value in dB. Args: offset: The attenuation offset in dB. \"\"\"","title":"set_att_offset()"},{"location":"api/abc/#pyinst.abc.TypeOMA","text":"Bases: OpticalFrequencySetter ABC to define the interfaces of an Optical Modulation Analyzer. The operating logic is different between vendors/models, so limited methods are defined here.","title":"TypeOMA"},{"location":"api/abc/#pyinst.abc.TypeOMA.run","text":"Run (or stop) OMA. Parameters: Name Type Description Default _run bool True = run, False = stop. True Source code in pyinst\\abc.py 953 954 955 956 957 958 959 960 @abstractmethod def run ( self , _run : bool = True ) -> None : \"\"\" Run (or stop) OMA. Args: _run: True = run, False = stop. \"\"\"","title":"run()"},{"location":"api/abc/#pyinst.abc.TypeOMA.stop","text":"Stop OMA. Source code in pyinst\\abc.py 962 963 964 @abstractmethod def stop ( self ) -> None : \"\"\"Stop OMA.\"\"\"","title":"stop()"},{"location":"api/abc/#pyinst.abc.TypeOSA","text":"Bases: OpticalFrequencySetter ABC to define the interfaces of an Optical Spectrum Analyzer. The operating logic is different between vendors/models, so no common methods are defined here.","title":"TypeOSA"},{"location":"api/abc/#pyinst.abc.TypeOSA.run","text":"Start repeat sweep. Parameters: Name Type Description Default _run bool True = run, False = stop. True Source code in pyinst\\abc.py 976 977 978 979 980 981 982 983 @abstractmethod def run ( self , _run : bool = True ) -> None : \"\"\" Start repeat sweep. Args: _run: True = run, False = stop. \"\"\"","title":"run()"},{"location":"api/abc/#pyinst.abc.TypeOSA.stop","text":"Stop sweep. Source code in pyinst\\abc.py 985 986 987 @abstractmethod def stop ( self ) -> None : \"\"\"Stop sweep.\"\"\"","title":"stop()"},{"location":"api/abc/#pyinst.abc.TypeOSA.single","text":"Perform single sweep. Source code in pyinst\\abc.py 989 990 991 @abstractmethod def single ( self ) -> None : \"\"\"Perform single sweep.\"\"\"","title":"single()"},{"location":"api/abc/#pyinst.abc.TypeOSA.is_running","text":"Get the sweep state of the OSA. Returns: Type Description bool Whether the repeat sweep is running. Source code in pyinst\\abc.py 993 994 995 996 997 998 999 1000 @abstractmethod def is_running ( self ) -> bool : \"\"\" Get the sweep state of the OSA. Returns: Whether the repeat sweep is running. \"\"\"","title":"is_running()"},{"location":"api/abc/#pyinst.abc.TypeOSA.get_osnr","text":"Get the measured OSNR in dB. Returns: Type Description float The OSNR value in dB. Source code in pyinst\\abc.py 1002 1003 1004 1005 1006 1007 1008 @abstractmethod def get_osnr ( self ) -> float : \"\"\"Get the measured OSNR in dB. Returns: The OSNR value in dB. \"\"\"","title":"get_osnr()"},{"location":"api/abc/#pyinst.abc.TypeWM","text":"Bases: ABC ABC to define the interfaces of an Optical Wavelength Meter.","title":"TypeWM"},{"location":"api/abc/#pyinst.abc.TypeWM.get_frequency","text":"Queries the measured optical frequency in THz. Returns: Type Description float The measured optical frequency value. Source code in pyinst\\abc.py 1018 1019 1020 1021 1022 1023 1024 1025 1026 @abstractmethod def get_frequency ( self ) -> float : \"\"\" Queries the measured optical frequency in THz. Returns: The measured optical frequency value. \"\"\" return round ( LIGHTSPEED / self . get_wavelength (), 6 )","title":"get_frequency()"},{"location":"api/abc/#pyinst.abc.TypeWM.get_wavelength","text":"Queries the mearured optical wavelength in nm. Returns: Type Description float The measured optical wavelength value. Source code in pyinst\\abc.py 1028 1029 1030 1031 1032 1033 1034 1035 @abstractmethod def get_wavelength ( self ) -> float : \"\"\"Queries the mearured optical wavelength in nm. Returns: The measured optical wavelength value. \"\"\" return round ( LIGHTSPEED / self . get_frequency (), 6 )","title":"get_wavelength()"},{"location":"api/abc/#pyinst.abc.TypeWM.run","text":"Start repeat measurement. Parameters: Name Type Description Default _run bool True = run, False = stop. True Source code in pyinst\\abc.py 1037 1038 1039 1040 1041 1042 1043 1044 @abstractmethod def run ( self , _run : bool = True ) -> None : \"\"\" Start repeat measurement. Args: _run: True = run, False = stop. \"\"\"","title":"run()"},{"location":"api/abc/#pyinst.abc.TypeWM.stop","text":"Stop repeat measurement. Source code in pyinst\\abc.py 1046 1047 1048 @abstractmethod def stop ( self ) -> None : \"\"\"Stop repeat measurement.\"\"\"","title":"stop()"},{"location":"api/abc/#pyinst.abc.TypeWM.single","text":"Perform single measurement. Source code in pyinst\\abc.py 1050 1051 1052 @abstractmethod def single ( self ) -> None : \"\"\"Perform single measurement.\"\"\"","title":"single()"},{"location":"api/abc/#pyinst.abc.TypeWM.is_running","text":"Get the measurement state of the wavemeter. Returns: Type Description bool True = reapeat measurement, False = stopped. Source code in pyinst\\abc.py 1054 1055 1056 1057 1058 1059 1060 1061 @abstractmethod def is_running ( self ) -> bool : \"\"\" Get the measurement state of the wavemeter. Returns: True = reapeat measurement, False = stopped. \"\"\"","title":"is_running()"},{"location":"api/abc/#pyinst.abc.TypeOTF","text":"Bases: OpticalFrequencySetter ABC to define the interfaces of an Optical Tunable Filter.","title":"TypeOTF"},{"location":"api/abc/#pyinst.abc.TypeOTF.min_bandwidth_in_nm","text":"The minimum bandwidth in nm. Source code in pyinst\\abc.py 1069 1070 1071 1072 1073 @property @abstractmethod def min_bandwidth_in_nm ( self ) -> float : \"\"\"The minimum bandwidth in nm.\"\"\" return bw_in_ghz_to_nm ( self . min_bandwidth_in_ghz )","title":"min_bandwidth_in_nm()"},{"location":"api/abc/#pyinst.abc.TypeOTF.max_bandwidth_in_nm","text":"The maximum bandwidth in nm. Source code in pyinst\\abc.py 1075 1076 1077 1078 1079 @property @abstractmethod def max_bandwidth_in_nm ( self ) -> float : \"\"\"The maximum bandwidth in nm.\"\"\" return bw_in_ghz_to_nm ( self . max_bandwidth_in_ghz )","title":"max_bandwidth_in_nm()"},{"location":"api/abc/#pyinst.abc.TypeOTF.min_bandwidth_in_ghz","text":"The minimum bandwidth in GHz. Source code in pyinst\\abc.py 1081 1082 1083 1084 1085 @property @abstractmethod def min_bandwidth_in_ghz ( self ) -> float : \"\"\"The minimum bandwidth in GHz.\"\"\" return bw_in_nm_to_ghz ( self . min_bandwidth_in_nm )","title":"min_bandwidth_in_ghz()"},{"location":"api/abc/#pyinst.abc.TypeOTF.max_bandwidth_in_ghz","text":"The maximum bandwidth in GHz. Source code in pyinst\\abc.py 1087 1088 1089 1090 1091 @property @abstractmethod def max_bandwidth_in_ghz ( self ) -> float : \"\"\"The maximum bandwidth in GHz.\"\"\" return bw_in_nm_to_ghz ( self . max_bandwidth_in_nm )","title":"max_bandwidth_in_ghz()"},{"location":"api/abc/#pyinst.abc.TypeOTF.get_bandwidth","text":"Get the filter bandwidth value in specified unit. Parameters: Name Type Description Default unit OpticalBandwidthUnit The unit for the bandwidth value. required Returns: Type Description float The bandwidth value in specified unit. Source code in pyinst\\abc.py 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 def get_bandwidth ( self , unit : OpticalBandwidthUnit ) -> float : \"\"\" Get the filter bandwidth value in specified unit. Args: unit: The unit for the bandwidth value. Returns: The bandwidth value in specified unit. \"\"\" unit = OpticalBandwidthUnit ( unit ) if unit == OpticalBandwidthUnit . GHZ : return self . get_bandwidth_in_ghz () else : return self . get_bandwidth_in_nm ()","title":"get_bandwidth()"},{"location":"api/abc/#pyinst.abc.TypeOTF.set_bandwidth","text":"Set the filter bandwidth in specified unit. Parameters: Name Type Description Default value int | float The bandwidth value in specified unit. required unit OpticalBandwidthUnit The unit of the bandwidth value. required Source code in pyinst\\abc.py 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 def set_bandwidth ( self , value : int | float , unit : OpticalBandwidthUnit ) -> None : \"\"\" Set the filter bandwidth in specified unit. Args: value: The bandwidth value in specified unit. unit: The unit of the bandwidth value. \"\"\" unit = OpticalBandwidthUnit ( unit ) if unit == OpticalBandwidthUnit . GHZ : return self . set_bandwidth_in_ghz ( value ) else : return self . set_bandwidth_in_nm ( value )","title":"set_bandwidth()"},{"location":"api/abc/#pyinst.abc.TypeOTF.get_bandwidth_in_nm","text":"Get the filter bandwidth in nm. Returns: Type Description float The bandwidth value in nm. Source code in pyinst\\abc.py 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 @abstractmethod def get_bandwidth_in_nm ( self ) -> float : \"\"\" Get the filter bandwidth in nm. Returns: The bandwidth value in nm. \"\"\" bw_ghz = self . get_bandwidth_in_ghz () return round ( bw_in_ghz_to_nm ( bw_ghz ), 6 )","title":"get_bandwidth_in_nm()"},{"location":"api/abc/#pyinst.abc.TypeOTF.set_bandwidth_in_nm","text":"Set the filter bandwidth in nm. Parameters: Name Type Description Default value int | float The bandwidth value in nm. required Source code in pyinst\\abc.py 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 @abstractmethod def set_bandwidth_in_nm ( self , value : int | float ) -> None : \"\"\" Set the filter bandwidth in nm. Args: value: The bandwidth value in nm. \"\"\" bw_ghz = round ( bw_in_nm_to_ghz ( value ), 6 ) self . set_bandwidth_in_ghz ( bw_ghz )","title":"set_bandwidth_in_nm()"},{"location":"api/abc/#pyinst.abc.TypeOTF.get_bandwidth_in_ghz","text":"Get the filter bandwidth in GHz. Returns: Type Description float The bandwidth value in GHz. Source code in pyinst\\abc.py 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 @abstractmethod def get_bandwidth_in_ghz ( self ) -> float : \"\"\" Get the filter bandwidth in GHz. Returns: The bandwidth value in GHz. \"\"\" bw_nm = self . get_bandwidth_in_nm () return round ( bw_in_nm_to_ghz ( bw_nm ), 6 )","title":"get_bandwidth_in_ghz()"},{"location":"api/abc/#pyinst.abc.TypeOTF.set_bandwidth_in_ghz","text":"Set the filter bandwidth in GHz. Parameters: Name Type Description Default value int | float The bandwidth value in GHz. required Source code in pyinst\\abc.py 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 @abstractmethod def set_bandwidth_in_ghz ( self , value : int | float ) -> None : \"\"\" Set the filter bandwidth in GHz. Args: value: The bandwidth value in GHz. \"\"\" bw_nm = round ( bw_in_ghz_to_nm ( value ), 6 ) self . set_bandwidth_in_nm ( bw_nm )","title":"set_bandwidth_in_ghz()"},{"location":"api/abc/#pyinst.abc.TypeTS","text":"Bases: ABC ABC to define the interfaces of a Temperature Source. A temperature source is an instrument that has the ability to control environment temperature, including chamber, TEC (Thermo Electric Cooler), thermo-stream, and so on. Each TypeTS class has a ts_type property to indicate the type of the thermostream. It is a member of TemperatureSourceType enum.","title":"TypeTS"},{"location":"api/abc/#pyinst.abc.TypeTS.ts_type","text":"The type of the temperature source. Source code in pyinst\\abc.py 1181 1182 1183 1184 @property def ts_type ( self ) -> TemperatureSourceType : \"\"\"The type of the temperature source.\"\"\" return TemperatureSourceType . UNDEFINED","title":"ts_type()"},{"location":"api/abc/#pyinst.abc.TypeTS.set_target_temp","text":"Set the target temperature. Parameters: Name Type Description Default value int | float The target temperature value. required Source code in pyinst\\abc.py 1186 1187 1188 1189 1190 1191 1192 1193 @abstractmethod def set_target_temp ( self , value : int | float ) -> None : \"\"\" Set the target temperature. Args: value: The target temperature value. \"\"\"","title":"set_target_temp()"},{"location":"api/abc/#pyinst.abc.TypeTS.get_target_temp","text":"Get the target temperature setting. Returns: Type Description float The target temperature setting value. Source code in pyinst\\abc.py 1195 1196 1197 1198 1199 1200 1201 1202 @abstractmethod def get_target_temp ( self ) -> float : \"\"\" Get the target temperature setting. Returns: The target temperature setting value. \"\"\"","title":"get_target_temp()"},{"location":"api/abc/#pyinst.abc.TypeTS.get_current_temp","text":"Queries the current monitored temperature. Returns: Type Description float The current temperature monitor value. Source code in pyinst\\abc.py 1204 1205 1206 1207 1208 1209 1210 1211 @abstractmethod def get_current_temp ( self ) -> float : \"\"\" Queries the current monitored temperature. Returns: The current temperature monitor value. \"\"\"","title":"get_current_temp()"},{"location":"api/abc/#pyinst.abc.TypeTS.set_temp_unit","text":"Set the temperature unit. Parameters: Name Type Description Default unit TemperatureUnit The temperature unit. required Source code in pyinst\\abc.py 1213 1214 1215 1216 1217 1218 1219 1220 @abstractmethod def set_temp_unit ( self , unit : TemperatureUnit ) -> None : \"\"\" Set the temperature unit. Args: unit: The temperature unit. \"\"\"","title":"set_temp_unit()"},{"location":"api/abc/#pyinst.abc.TypeTS.get_temp_unit","text":"Get the temperature unit setting. Returns: Type Description TemperatureUnit The temperature unit. Source code in pyinst\\abc.py 1222 1223 1224 1225 1226 1227 1228 1229 @abstractmethod def get_temp_unit ( self ) -> TemperatureUnit : \"\"\" Get the temperature unit setting. Returns: The temperature unit. \"\"\"","title":"get_temp_unit()"},{"location":"api/abc/#pyinst.abc.TypeSW","text":"Bases: ABC ABC to define the interfaces of an Optical Switch.","title":"TypeSW"},{"location":"api/abc/#pyinst.abc.TypeSW.set_channel","text":"Switch to the specified channel route. Parameters: Name Type Description Default channel int The channel number. required Source code in pyinst\\abc.py 1237 1238 1239 1240 1241 1242 1243 1244 @abstractmethod def set_channel ( self , channel : int ) -> None : \"\"\" Switch to the specified channel route. Args: channel: The channel number. \"\"\"","title":"set_channel()"},{"location":"api/abc/#pyinst.abc.TypeSW.get_channel","text":"Queries the current channel route of the switch. Returns: Type Description int The channel number of current route. Source code in pyinst\\abc.py 1246 1247 1248 1249 1250 1251 1252 1253 @abstractmethod def get_channel ( self ) -> int : \"\"\" Queries the current channel route of the switch. Returns: The channel number of current route. \"\"\"","title":"get_channel()"},{"location":"api/abc/#pyinst.abc.TypeMSW","text":"Bases: ABC ABC to define the interfaces of an Optical Matrix Switch.","title":"TypeMSW"},{"location":"api/abc/#pyinst.abc.TypeMSW.connect","text":"Sets a new optical connection. Note that this method will delete any existing connections using port1 or port2. Use check to confirm whether either port is already in use. Parameters: Name Type Description Default port1 int The valid port at one end of the path. required port2 int The valid port at the other end of the path. required enable bool Whether to enable the connection. True Source code in pyinst\\abc.py 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 @abstractmethod def connect ( self , port1 : int , port2 : int , enable : bool = True ) -> None : \"\"\" Sets a new optical connection. Note that this method will delete any existing connections using port1 or port2. Use `check` to confirm whether either port is already in use. Args: port1: The valid port at one end of the path. port2: The valid port at the other end of the path. enable: Whether to enable the connection. \"\"\"","title":"connect()"},{"location":"api/abc/#pyinst.abc.TypeMSW.connected_with","text":"Returns connection information of the specified port. If the port is connected, return the port number at the other end of the connection. If no connection exists for the port, return None. Parameters: Name Type Description Default port int The port number to check connection information. required Returns: Type Description Optional [ int ] Connection information for the specified port. Optional [ int ] None = No connection exists. Optional [ int ] Optional [ int ] int N = Port number at other end of the connection. Source code in pyinst\\abc.py 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 @abstractmethod def connected_with ( self , port : int ) -> Optional [ int ]: \"\"\" Returns connection information of the specified port. If the port is connected, return the port number at the other end of the connection. If no connection exists for the port, return None. Args: port: The port number to check connection information. Returns: Connection information for the specified port. None = No connection exists. int N = Port number at other end of the connection. \"\"\"","title":"connected_with()"},{"location":"api/abc/#pyinst.abc.TypeMSW.clear","text":"Clears a configured optical connection connected to the specified port. Parameters: Name Type Description Default port int The port at either end of the configured connection. required Source code in pyinst\\abc.py 1296 1297 1298 1299 1300 1301 1302 1303 @abstractmethod def clear ( self , port : int ) -> None : \"\"\" Clears a configured optical connection connected to the specified port. Args: port: The port at either end of the configured connection. \"\"\"","title":"clear()"},{"location":"api/abc/#pyinst.abc.TypeMSW.clear_all","text":"Clears all configured optical connections. Source code in pyinst\\abc.py 1305 1306 1307 @abstractmethod def clear_all ( self ) -> None : \"\"\"Clears all configured optical connections.\"\"\"","title":"clear_all()"},{"location":"api/abc/#pyinst.abc.TypeMSW.check","text":"To check if port1 and port2 are both not in use. Parameters: Name Type Description Default port1 int The port at one end of the path. required port2 int The port at the other end of the path. required Returns: Type Description bool True = Both ports available (not in use). bool False = Conflict; one or both ports already in use. Source code in pyinst\\abc.py 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 @abstractmethod def check ( self , port1 : int , port2 : int ) -> bool : \"\"\" To check if port1 and port2 are both not in use. Args: port1: The port at one end of the path. port2: The port at the other end of the path. Returns: True = Both ports available (not in use). False = Conflict; one or both ports already in use. \"\"\"","title":"check()"},{"location":"api/abc/#pyinst.abc.TypeMSW.enable","text":"Sets the connection state of a configured optical connection. Parameters: Name Type Description Default port int The port at either end of the connection. required enable bool True = Enable | False = Disable. True Source code in pyinst\\abc.py 1324 1325 1326 1327 1328 1329 1330 1331 1332 @abstractmethod def enable ( self , port : int , enable : bool = True ) -> None : \"\"\" Sets the connection state of a configured optical connection. Args: port: The port at either end of the connection. enable: True = Enable | False = Disable. \"\"\"","title":"enable()"},{"location":"api/abc/#pyinst.abc.TypeMSW.disable","text":"Disable the connection of a configured optical connection. Parameters: Name Type Description Default port int The port at either end of the connection. required Source code in pyinst\\abc.py 1334 1335 1336 1337 1338 1339 1340 1341 @abstractmethod def disable ( self , port : int ) -> None : \"\"\" Disable the connection of a configured optical connection. Args: port: The port at either end of the connection. \"\"\"","title":"disable()"},{"location":"api/abc/#pyinst.abc.TypeMSW.is_enabled","text":"Returns the connection state of a configured optical connection. Returns: Type Description bool True = Enabled | False = Disabled Source code in pyinst\\abc.py 1343 1344 1345 1346 1347 1348 1349 1350 @abstractmethod def is_enabled ( self , port : int ) -> bool : \"\"\" Returns the connection state of a configured optical connection. Returns: True = Enabled | False = Disabled \"\"\"","title":"is_enabled()"},{"location":"api/abc/#pyinst.abc.TypePS","text":"Bases: ABC ABC to define the interfaces of a Power Supply.","title":"TypePS"},{"location":"api/abc/#pyinst.abc.TypePS.min_voltage","text":"The minimum programmable voltage level in V. Source code in pyinst\\abc.py 1358 1359 1360 1361 @property @abstractmethod def min_voltage ( self ) -> float : \"\"\"The minimum programmable voltage level in V.\"\"\"","title":"min_voltage()"},{"location":"api/abc/#pyinst.abc.TypePS.max_voltage","text":"The maximum programmable voltage level in V. Source code in pyinst\\abc.py 1363 1364 1365 1366 @property @abstractmethod def max_voltage ( self ) -> float : \"\"\"The maximum programmable voltage level in V.\"\"\"","title":"max_voltage()"},{"location":"api/abc/#pyinst.abc.TypePS.min_current","text":"The minimum programmable current level in A. Source code in pyinst\\abc.py 1368 1369 1370 1371 @property @abstractmethod def min_current ( self ) -> float : \"\"\"The minimum programmable current level in A.\"\"\"","title":"min_current()"},{"location":"api/abc/#pyinst.abc.TypePS.max_current","text":"The maximum programmable current level in A. Source code in pyinst\\abc.py 1373 1374 1375 1376 @property @abstractmethod def max_current ( self ) -> float : \"\"\"The maximum programmable current level in A.\"\"\"","title":"max_current()"},{"location":"api/abc/#pyinst.abc.TypePS.enable","text":"Enables (or disables) the outputs of the power supply. Parameters: Name Type Description Default en bool True = Enable, False = Disable. True Source code in pyinst\\abc.py 1378 1379 1380 1381 1382 1383 1384 1385 @abstractmethod def enable ( self , en : bool = True ) -> None : \"\"\" Enables (or disables) the outputs of the power supply. Args: en: `True` = Enable, `False` = Disable. \"\"\"","title":"enable()"},{"location":"api/abc/#pyinst.abc.TypePS.disable","text":"Disables the output of the power supply. Source code in pyinst\\abc.py 1387 1388 1389 @abstractmethod def disable ( self ) -> None : \"\"\"Disables the output of the power supply.\"\"\"","title":"disable()"},{"location":"api/abc/#pyinst.abc.TypePS.is_enabled","text":"Queries whether the output of the power supply is enabled. Returns: Type Description bool True = Enabled, False = Disabled Source code in pyinst\\abc.py 1391 1392 1393 1394 1395 1396 1397 1398 @abstractmethod def is_enabled ( self ) -> bool : \"\"\" Queries whether the output of the power supply is enabled. Returns: `True` = Enabled, `False` = Disabled \"\"\"","title":"is_enabled()"},{"location":"api/abc/#pyinst.abc.TypePS.set_voltage_limit","text":"Sets the immediate voltage level of the power supply. Parameters: Name Type Description Default value int | float The voltage level in V. required Source code in pyinst\\abc.py 1400 1401 1402 1403 1404 1405 1406 1407 @abstractmethod def set_voltage_limit ( self , value : int | float ) -> None : \"\"\" Sets the immediate voltage level of the power supply. Args: value: The voltage level in V. \"\"\"","title":"set_voltage_limit()"},{"location":"api/abc/#pyinst.abc.TypePS.get_voltage_limit","text":"Queries the immediate voltage level of the power supply. Returns: Type Description float The voltage level in V. Source code in pyinst\\abc.py 1409 1410 1411 1412 1413 1414 1415 1416 @abstractmethod def get_voltage_limit ( self ) -> float : \"\"\" Queries the immediate voltage level of the power supply. Returns: The voltage level in V. \"\"\"","title":"get_voltage_limit()"},{"location":"api/abc/#pyinst.abc.TypePS.measure_voltage","text":"Queries the voltage measured at the sense terminals of the power supply. Returns: Type Description float The voltage measured in V. Source code in pyinst\\abc.py 1418 1419 1420 1421 1422 1423 1424 1425 @abstractmethod def measure_voltage ( self ) -> float : \"\"\"Queries the voltage measured at the sense terminals of the power supply. Returns: The voltage measured in V. \"\"\"","title":"measure_voltage()"},{"location":"api/abc/#pyinst.abc.TypePS.set_current_limit","text":"Sets the immediate current level of the power supply. Parameters: Name Type Description Default value int | float The current level in A. required Source code in pyinst\\abc.py 1427 1428 1429 1430 1431 1432 1433 1434 @abstractmethod def set_current_limit ( self , value : int | float ) -> None : \"\"\" Sets the immediate current level of the power supply. Args: value: The current level in A. \"\"\"","title":"set_current_limit()"},{"location":"api/abc/#pyinst.abc.TypePS.get_current_limit","text":"Queries the immediate current level of the power supply. Returns: Type Description float The current level in A. Source code in pyinst\\abc.py 1436 1437 1438 1439 1440 1441 1442 1443 @abstractmethod def get_current_limit ( self ) -> float : \"\"\" Queries the immediate current level of the power supply. Returns: The current level in A. \"\"\"","title":"get_current_limit()"},{"location":"api/abc/#pyinst.abc.TypePS.measure_current","text":"Queries the current measured across the current sense resistor inside the power supply. Returns: Type Description float The current measured in A. Source code in pyinst\\abc.py 1445 1446 1447 1448 1449 1450 1451 1452 @abstractmethod def measure_current ( self ) -> float : \"\"\"Queries the current measured across the current sense resistor inside the power supply. Returns: The current measured in A. \"\"\"","title":"measure_current()"},{"location":"api/abc/#pyinst.abc.TypePSwithOvpOcpFunctions","text":"Bases: TypePS ABC to define the interfaces of a Power Supply with OCP & OVP functions.","title":"TypePSwithOvpOcpFunctions"},{"location":"api/abc/#pyinst.abc.TypePSwithOvpOcpFunctions.set_ocp_level","text":"Sets the current level at which the overcurrent protection (OCP) circuit will trip. If the peak output current exceeds the OCP level, then the output current is programmed to zero. You can use is_ocp_tripped() to query if the OCP circuit is tripped. An overcurrent condition can be cleared with the clear_ocp() method after the condition that caused the OCP trip is removed. Parameters: Name Type Description Default level int | float The OCP level in A. required Source code in pyinst\\abc.py 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 @abstractmethod def set_ocp_level ( self , level : int | float ) -> None : \"\"\" Sets the current level at which the overcurrent protection (OCP) circuit will trip. If the peak output current exceeds the OCP level, then the output current is programmed to zero. You can use `is_ocp_tripped()` to query if the OCP circuit is tripped. An overcurrent condition can be cleared with the `clear_ocp()` method after the condition that caused the OCP trip is removed. Args: level: The OCP level in A. \"\"\"","title":"set_ocp_level()"},{"location":"api/abc/#pyinst.abc.TypePSwithOvpOcpFunctions.get_ocp_level","text":"Returns the overcurrent protection trip level presently programmed. See set_ocp_level() for more details. Returns: Type Description float The OCP level in A. Source code in pyinst\\abc.py 1475 1476 1477 1478 1479 1480 1481 1482 1483 @abstractmethod def get_ocp_level ( self ) -> float : \"\"\"Returns the overcurrent protection trip level presently programmed. See `set_ocp_level()` for more details. Returns: The OCP level in A. \"\"\"","title":"get_ocp_level()"},{"location":"api/abc/#pyinst.abc.TypePSwithOvpOcpFunctions.enable_ocp","text":"Enables (or disables) the overcurrent protection function of the power supply. Parameters: Name Type Description Default enable bool True = Enable, False = Disable. True Source code in pyinst\\abc.py 1485 1486 1487 1488 1489 1490 1491 1492 @abstractmethod def enable_ocp ( self , enable : bool = True ) -> None : \"\"\"Enables (or disables) the overcurrent protection function of the power supply. Args: enable: `True` = Enable, `False` = Disable. \"\"\"","title":"enable_ocp()"},{"location":"api/abc/#pyinst.abc.TypePSwithOvpOcpFunctions.disable_ocp","text":"Disables the overcurrent protection function of the power supply. Source code in pyinst\\abc.py 1494 1495 1496 1497 @abstractmethod def disable_ocp ( self ) -> None : \"\"\"Disables the overcurrent protection function of the power supply. \"\"\"","title":"disable_ocp()"},{"location":"api/abc/#pyinst.abc.TypePSwithOvpOcpFunctions.is_ocp_enabled","text":"Queries whether the overcurrent protection function of the power supply is enabled. Returns: Type Description bool Whether the OCP function is enabled. Source code in pyinst\\abc.py 1499 1500 1501 1502 1503 1504 1505 1506 @abstractmethod def is_ocp_enabled ( self ) -> bool : \"\"\"Queries whether the overcurrent protection function of the power supply is enabled. Returns: Whether the OCP function is enabled. \"\"\"","title":"is_ocp_enabled()"},{"location":"api/abc/#pyinst.abc.TypePSwithOvpOcpFunctions.is_ocp_tripped","text":"Queries if the overcurrent protection circuit is tripped and not cleared. Returns: Type Description bool If the overcurrent protection circuit is tripped and not cleared. Source code in pyinst\\abc.py 1508 1509 1510 1511 1512 1513 1514 1515 @abstractmethod def is_ocp_tripped ( self ) -> bool : \"\"\"Queries if the overcurrent protection circuit is tripped and not cleared. Returns: If the overcurrent protection circuit is tripped and not cleared. \"\"\"","title":"is_ocp_tripped()"},{"location":"api/abc/#pyinst.abc.TypePSwithOvpOcpFunctions.clear_ocp","text":"This method causes the overcurrent protection circuit to be cleared. Before using this method, lower the output current below the trip OCP point, or raise the OCP trip level above the output setting. Note Note that the overcurrent condition caused by an external source must be removed first before proceeding this method. Source code in pyinst\\abc.py 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 @abstractmethod def clear_ocp ( self ) -> None : \"\"\"This method causes the overcurrent protection circuit to be cleared. Before using this method, lower the output current below the trip OCP point, or raise the OCP trip level above the output setting. Note: Note that the overcurrent condition caused by an external source must be removed first before proceeding this method. \"\"\"","title":"clear_ocp()"},{"location":"api/abc/#pyinst.abc.TypePSwithOvpOcpFunctions.set_ovp_level","text":"Sets the voltage level at which the overvoltage protection (OVP) circuit will trip. If the peak output voltage exceeds the OVP level, then the power supply output is shorted by an internal SCR. You can use is_ovp_tripped() to query if the OVP circuit is tripped. An overvoltage condition can be cleared with the clear_ovp() method after the condition that caused the OVP trip is removed. Parameters: Name Type Description Default level int | float The OVP level in V. required Source code in pyinst\\abc.py 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 @abstractmethod def set_ovp_level ( self , level : int | float ) -> None : \"\"\" Sets the voltage level at which the overvoltage protection (OVP) circuit will trip. If the peak output voltage exceeds the OVP level, then the power supply output is shorted by an internal SCR. You can use `is_ovp_tripped()` to query if the OVP circuit is tripped. An overvoltage condition can be cleared with the `clear_ovp()` method after the condition that caused the OVP trip is removed. Args: level: The OVP level in V. \"\"\"","title":"set_ovp_level()"},{"location":"api/abc/#pyinst.abc.TypePSwithOvpOcpFunctions.get_ovp_level","text":"Returns the overvoltage protection trip level presently programmed. See set_ovp_level() for more details. Returns: Type Description float The OVP level in V. Source code in pyinst\\abc.py 1543 1544 1545 1546 1547 1548 1549 1550 1551 @abstractmethod def get_ovp_level ( self ) -> float : \"\"\"Returns the overvoltage protection trip level presently programmed. See `set_ovp_level()` for more details. Returns: The OVP level in V. \"\"\"","title":"get_ovp_level()"},{"location":"api/abc/#pyinst.abc.TypePSwithOvpOcpFunctions.enable_ovp","text":"Enables (or disables) the overvoltage protection function of the power supply. Parameters: Name Type Description Default enable bool True = Enable, False = Disable. True Source code in pyinst\\abc.py 1553 1554 1555 1556 1557 1558 1559 1560 @abstractmethod def enable_ovp ( self , enable : bool = True ) -> None : \"\"\"Enables (or disables) the overvoltage protection function of the power supply. Args: enable: `True` = Enable, `False` = Disable. \"\"\"","title":"enable_ovp()"},{"location":"api/abc/#pyinst.abc.TypePSwithOvpOcpFunctions.disable_ovp","text":"Disables the overvoltage protection function of the power supply. Source code in pyinst\\abc.py 1562 1563 1564 1565 @abstractmethod def disable_ovp ( self ) -> None : \"\"\"Disables the overvoltage protection function of the power supply. \"\"\"","title":"disable_ovp()"},{"location":"api/abc/#pyinst.abc.TypePSwithOvpOcpFunctions.is_ovp_enabled","text":"Queries whether the overvoltage protection function of the power supply is enabled. Returns: Type Description bool Whether the OVP function is enabled. Source code in pyinst\\abc.py 1567 1568 1569 1570 1571 1572 1573 1574 @abstractmethod def is_ovp_enabled ( self ) -> bool : \"\"\"Queries whether the overvoltage protection function of the power supply is enabled. Returns: Whether the OVP function is enabled. \"\"\"","title":"is_ovp_enabled()"},{"location":"api/abc/#pyinst.abc.TypePSwithOvpOcpFunctions.is_ovp_tripped","text":"Queries if the overvoltage protection circuit is tripped and not cleared. Returns: Type Description bool If the overvoltage protection circuit is tripped and not cleared. Source code in pyinst\\abc.py 1576 1577 1578 1579 1580 1581 1582 1583 @abstractmethod def is_ovp_tripped ( self ) -> bool : \"\"\"Queries if the overvoltage protection circuit is tripped and not cleared. Returns: If the overvoltage protection circuit is tripped and not cleared. \"\"\"","title":"is_ovp_tripped()"},{"location":"api/abc/#pyinst.abc.TypePSwithOvpOcpFunctions.clear_ovp","text":"This method causes the overvoltage protection circuit to be cleared. Before sending this method, lower the output voltage below the trip OVP point, or raise the OVP trip level above the output setting. Note Note that the overvoltage condition caused by an external source must be removed first before proceeding this method. Source code in pyinst\\abc.py 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 @abstractmethod def clear_ovp ( self ) -> None : \"\"\"This method causes the overvoltage protection circuit to be cleared. Before sending this method, lower the output voltage below the trip OVP point, or raise the OVP trip level above the output setting. Note: Note that the overvoltage condition caused by an external source must be removed first before proceeding this method. \"\"\"","title":"clear_ovp()"},{"location":"api/abc/#pyinst.abc.TypePDLE","text":"Bases: OpticalFrequencySetter ABC to define the interfaces of a PDL Emulator.","title":"TypePDLE"},{"location":"api/abc/#pyinst.abc.TypePDLE.min_pdl","text":"The minimum settable PDL value. Source code in pyinst\\abc.py 1603 1604 1605 1606 @property @abstractmethod def min_pdl ( self ) -> float : \"\"\"The minimum settable PDL value.\"\"\"","title":"min_pdl()"},{"location":"api/abc/#pyinst.abc.TypePDLE.max_pdl","text":"The maximum settable PDL value. Source code in pyinst\\abc.py 1608 1609 1610 1611 @property @abstractmethod def max_pdl ( self ) -> float : \"\"\"The maximum settable PDL value.\"\"\"","title":"max_pdl()"},{"location":"api/abc/#pyinst.abc.TypePDLE.get_pdl_value","text":"Returns: Type Description float The PDL setting value in dB. Source code in pyinst\\abc.py 1613 1614 1615 1616 1617 1618 @abstractmethod def get_pdl_value ( self ) -> float : \"\"\" Returns: The PDL setting value in dB. \"\"\"","title":"get_pdl_value()"},{"location":"api/abc/#pyinst.abc.TypePDLE.set_pdl_value","text":"Parameters: Name Type Description Default value int | float The PDL setting value in dB. required Source code in pyinst\\abc.py 1620 1621 1622 1623 1624 1625 @abstractmethod def set_pdl_value ( self , value : int | float ) -> None : \"\"\" Args: value: The PDL setting value in dB. \"\"\"","title":"set_pdl_value()"},{"location":"api/abc/#pyinst.abc.TypePOLC","text":"Bases: OpticalFrequencySetter ABC to define the interfaces of a Polarization Controller/Scrambler.","title":"TypePOLC"},{"location":"api/abc/#pyinst.abc.TypePOLC.start_scrambling","text":"Start scrambling with the specified mode and rate. Parameters: Name Type Description Default mode str Scrambling mode. Valid options depends on specific model. required rate int | float Scrambling rate. Different mode may have different units. required **params Additional scrambling params if any. {} Source code in pyinst\\abc.py 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 @abstractmethod def start_scrambling ( self , mode : str , rate : int | float , ** params ) -> None : \"\"\" Start scrambling with the specified mode and rate. Args: mode: Scrambling mode. Valid options depends on specific model. rate: Scrambling rate. Different mode may have different units. **params: Additional scrambling params if any. \"\"\"","title":"start_scrambling()"},{"location":"api/abc/#pyinst.abc.TypePOLC.stop_scrambling","text":"Stop scrambling. Source code in pyinst\\abc.py 1644 1645 1646 @abstractmethod def stop_scrambling ( self ) -> None : \"\"\"Stop scrambling.\"\"\"","title":"stop_scrambling()"},{"location":"api/abc/#pyinst.abc.TypePMDE","text":"Bases: OpticalFrequencySetter ABC to define the interfaces of a PMD Emulator.","title":"TypePMDE"},{"location":"api/abc/#pyinst.abc.TypePMDE.set_pmd_value","text":"Set PMD (DGD) and SOPMD (Second Order PMD) target value. Parameters: Name Type Description Default pmd int | float The DGD value in ps. required sopmd int | float The 2nd order pmd in ps**2. required Source code in pyinst\\abc.py 1654 1655 1656 1657 1658 1659 1660 1661 1662 @abstractmethod def set_pmd_value ( self , pmd : int | float , sopmd : int | float ) -> None : \"\"\" Set PMD (DGD) and SOPMD (Second Order PMD) target value. Args: pmd: The DGD value in ps. sopmd: The 2nd order pmd in ps**2. \"\"\"","title":"set_pmd_value()"},{"location":"api/abc/#pyinst.abc.TypePMDE.get_pmd_value","text":"Get PMD (DGD) and SOPMD (Second Order PMD) target value. Returns: Name Type Description pmd float The DGD value in ps. sopmd float The 2nd order pmd in ps**2. Source code in pyinst\\abc.py 1664 1665 1666 1667 1668 1669 1670 1671 1672 @abstractmethod def get_pmd_value ( self ) -> Tuple [ float , float ]: \"\"\" Get PMD (DGD) and SOPMD (Second Order PMD) target value. Returns: pmd: The DGD value in ps. sopmd: The 2nd order pmd in ps**2. \"\"\"","title":"get_pmd_value()"},{"location":"api/constants/","text":"Provides user-friendly naming to values used in different functions. LIGHTSPEED = 299792.458 module-attribute \u00a4 VI_OPEN_TIMEOUT = 0 module-attribute \u00a4 VI_TIMEOUT = 2000 module-attribute \u00a4 VI_QUERY_DELAY = 0.001 module-attribute \u00a4 VI_READ_TERMINATION = ' \\n ' module-attribute \u00a4 VI_WRITE_TERMINATION = ' \\n ' module-attribute \u00a4 SERIAL_READ_TERMINATION = ' \\n ' module-attribute \u00a4 SERIAL_WRITE_TERMINATION = ' \\n ' module-attribute \u00a4 SERIAL_READ_TIMEOUT = 2000 module-attribute \u00a4 SERIAL_WRITE_TIMEOUT = 2000 module-attribute \u00a4 SERIAL_QUERY_DELAY = 0.1 module-attribute \u00a4 InstrumentType \u00a4 Bases: IntFlag The flags of instrument types. Source code in pyinst\\constants.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 @unique class InstrumentType ( IntFlag ): \"\"\"The flags of instrument types.\"\"\" OPM = 1 << 0 ; \"Optical Power Meter\" VOA = 1 << 1 ; \"Variable Optical Attenuator\" OMA = 1 << 2 ; \"Optical Modulation Analyzer\" OSA = 1 << 3 ; \"Optical Spectrum Analyzer\" WM = 1 << 4 ; \"Optical Wavelength Meter\" OTF = 1 << 5 ; \"Optical Tunable Filter\" TS = 1 << 6 ; \"Temperature Source\" SW = 1 << 7 ; \"Optical Switch\" MSW = 1 << 8 ; \"Optical Matrix Switch\" PS = 1 << 9 ; \"Power Supply\" PDLE = 1 << 10 ; \"PDL Emulator/Source\" POLC = 1 << 11 ; \"Polarization Controller/Scrambler\" PMDE = 1 << 12 ; \"PMD Emulator/Source\" OPM = 1 << 0 class-attribute \u00a4 Optical Power Meter VOA = 1 << 1 class-attribute \u00a4 Variable Optical Attenuator OMA = 1 << 2 class-attribute \u00a4 Optical Modulation Analyzer OSA = 1 << 3 class-attribute \u00a4 Optical Spectrum Analyzer WM = 1 << 4 class-attribute \u00a4 Optical Wavelength Meter OTF = 1 << 5 class-attribute \u00a4 Optical Tunable Filter TS = 1 << 6 class-attribute \u00a4 Temperature Source SW = 1 << 7 class-attribute \u00a4 Optical Switch MSW = 1 << 8 class-attribute \u00a4 Optical Matrix Switch PS = 1 << 9 class-attribute \u00a4 Power Supply PDLE = 1 << 10 class-attribute \u00a4 PDL Emulator/Source POLC = 1 << 11 class-attribute \u00a4 Polarization Controller/Scrambler PMDE = 1 << 12 class-attribute \u00a4 PMD Emulator/Source TemperatureSourceType \u00a4 Bases: IntEnum Source code in pyinst\\constants.py 70 71 72 73 74 75 @unique class TemperatureSourceType ( IntEnum ): UNDEFINED = 0 CHAMBER = 1 TEC = 2 THERMO_STREAM = 3 UNDEFINED = 0 class-attribute \u00a4 CHAMBER = 1 class-attribute \u00a4 TEC = 2 class-attribute \u00a4 THERMO_STREAM = 3 class-attribute \u00a4 OpticalPowerUnit \u00a4 Bases: IntEnum Source code in pyinst\\constants.py 78 79 80 81 @unique class OpticalPowerUnit ( IntEnum ): DBM = 0 W = 1 DBM = 0 class-attribute \u00a4 W = 1 class-attribute \u00a4 TemperatureUnit \u00a4 Bases: IntEnum Source code in pyinst\\constants.py 84 85 86 87 @unique class TemperatureUnit ( IntEnum ): F = 0 C = 1 F = 0 class-attribute \u00a4 C = 1 class-attribute \u00a4 OpticalBandwidthUnit \u00a4 Bases: IntEnum Source code in pyinst\\constants.py 90 91 92 93 @unique class OpticalBandwidthUnit ( IntEnum ): GHZ = 0 NM = 1 GHZ = 0 class-attribute \u00a4 NM = 1 class-attribute \u00a4 SerialParity \u00a4 Bases: Enum Source code in pyinst\\constants.py 96 97 98 99 100 101 102 @unique class SerialParity ( Enum ): NONE = 'N' EVEN = 'E' ODD = 'O' MARK = 'M' SPACE = 'S' NONE = 'N' class-attribute \u00a4 EVEN = 'E' class-attribute \u00a4 ODD = 'O' class-attribute \u00a4 MARK = 'M' class-attribute \u00a4 SPACE = 'S' class-attribute \u00a4 SerialStopBits \u00a4 Bases: Enum Source code in pyinst\\constants.py 105 106 107 108 109 @unique class SerialStopBits ( Enum ): ONE = 1 ONE_POINT_FIVE = 1.5 TWO = 2 ONE = 1 class-attribute \u00a4 ONE_POINT_FIVE = 1.5 class-attribute \u00a4 TWO = 2 class-attribute \u00a4 SerialByteSize \u00a4 Bases: Enum Source code in pyinst\\constants.py 112 113 114 115 116 117 @unique class SerialByteSize ( Enum ): FIVEBITS = 5 SIXBITS = 6 SEVENBITS = 7 EIGHTBITS = 8 FIVEBITS = 5 class-attribute \u00a4 SIXBITS = 6 class-attribute \u00a4 SEVENBITS = 7 class-attribute \u00a4 EIGHTBITS = 8 class-attribute \u00a4","title":"Constants"},{"location":"api/constants/#pyinst.constants.LIGHTSPEED","text":"","title":"LIGHTSPEED"},{"location":"api/constants/#pyinst.constants.VI_OPEN_TIMEOUT","text":"","title":"VI_OPEN_TIMEOUT"},{"location":"api/constants/#pyinst.constants.VI_TIMEOUT","text":"","title":"VI_TIMEOUT"},{"location":"api/constants/#pyinst.constants.VI_QUERY_DELAY","text":"","title":"VI_QUERY_DELAY"},{"location":"api/constants/#pyinst.constants.VI_READ_TERMINATION","text":"","title":"VI_READ_TERMINATION"},{"location":"api/constants/#pyinst.constants.VI_WRITE_TERMINATION","text":"","title":"VI_WRITE_TERMINATION"},{"location":"api/constants/#pyinst.constants.SERIAL_READ_TERMINATION","text":"","title":"SERIAL_READ_TERMINATION"},{"location":"api/constants/#pyinst.constants.SERIAL_WRITE_TERMINATION","text":"","title":"SERIAL_WRITE_TERMINATION"},{"location":"api/constants/#pyinst.constants.SERIAL_READ_TIMEOUT","text":"","title":"SERIAL_READ_TIMEOUT"},{"location":"api/constants/#pyinst.constants.SERIAL_WRITE_TIMEOUT","text":"","title":"SERIAL_WRITE_TIMEOUT"},{"location":"api/constants/#pyinst.constants.SERIAL_QUERY_DELAY","text":"","title":"SERIAL_QUERY_DELAY"},{"location":"api/constants/#pyinst.constants.InstrumentType","text":"Bases: IntFlag The flags of instrument types. Source code in pyinst\\constants.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 @unique class InstrumentType ( IntFlag ): \"\"\"The flags of instrument types.\"\"\" OPM = 1 << 0 ; \"Optical Power Meter\" VOA = 1 << 1 ; \"Variable Optical Attenuator\" OMA = 1 << 2 ; \"Optical Modulation Analyzer\" OSA = 1 << 3 ; \"Optical Spectrum Analyzer\" WM = 1 << 4 ; \"Optical Wavelength Meter\" OTF = 1 << 5 ; \"Optical Tunable Filter\" TS = 1 << 6 ; \"Temperature Source\" SW = 1 << 7 ; \"Optical Switch\" MSW = 1 << 8 ; \"Optical Matrix Switch\" PS = 1 << 9 ; \"Power Supply\" PDLE = 1 << 10 ; \"PDL Emulator/Source\" POLC = 1 << 11 ; \"Polarization Controller/Scrambler\" PMDE = 1 << 12 ; \"PMD Emulator/Source\"","title":"InstrumentType"},{"location":"api/constants/#pyinst.constants.InstrumentType.OPM","text":"Optical Power Meter","title":"OPM"},{"location":"api/constants/#pyinst.constants.InstrumentType.VOA","text":"Variable Optical Attenuator","title":"VOA"},{"location":"api/constants/#pyinst.constants.InstrumentType.OMA","text":"Optical Modulation Analyzer","title":"OMA"},{"location":"api/constants/#pyinst.constants.InstrumentType.OSA","text":"Optical Spectrum Analyzer","title":"OSA"},{"location":"api/constants/#pyinst.constants.InstrumentType.WM","text":"Optical Wavelength Meter","title":"WM"},{"location":"api/constants/#pyinst.constants.InstrumentType.OTF","text":"Optical Tunable Filter","title":"OTF"},{"location":"api/constants/#pyinst.constants.InstrumentType.TS","text":"Temperature Source","title":"TS"},{"location":"api/constants/#pyinst.constants.InstrumentType.SW","text":"Optical Switch","title":"SW"},{"location":"api/constants/#pyinst.constants.InstrumentType.MSW","text":"Optical Matrix Switch","title":"MSW"},{"location":"api/constants/#pyinst.constants.InstrumentType.PS","text":"Power Supply","title":"PS"},{"location":"api/constants/#pyinst.constants.InstrumentType.PDLE","text":"PDL Emulator/Source","title":"PDLE"},{"location":"api/constants/#pyinst.constants.InstrumentType.POLC","text":"Polarization Controller/Scrambler","title":"POLC"},{"location":"api/constants/#pyinst.constants.InstrumentType.PMDE","text":"PMD Emulator/Source","title":"PMDE"},{"location":"api/constants/#pyinst.constants.TemperatureSourceType","text":"Bases: IntEnum Source code in pyinst\\constants.py 70 71 72 73 74 75 @unique class TemperatureSourceType ( IntEnum ): UNDEFINED = 0 CHAMBER = 1 TEC = 2 THERMO_STREAM = 3","title":"TemperatureSourceType"},{"location":"api/constants/#pyinst.constants.TemperatureSourceType.UNDEFINED","text":"","title":"UNDEFINED"},{"location":"api/constants/#pyinst.constants.TemperatureSourceType.CHAMBER","text":"","title":"CHAMBER"},{"location":"api/constants/#pyinst.constants.TemperatureSourceType.TEC","text":"","title":"TEC"},{"location":"api/constants/#pyinst.constants.TemperatureSourceType.THERMO_STREAM","text":"","title":"THERMO_STREAM"},{"location":"api/constants/#pyinst.constants.OpticalPowerUnit","text":"Bases: IntEnum Source code in pyinst\\constants.py 78 79 80 81 @unique class OpticalPowerUnit ( IntEnum ): DBM = 0 W = 1","title":"OpticalPowerUnit"},{"location":"api/constants/#pyinst.constants.OpticalPowerUnit.DBM","text":"","title":"DBM"},{"location":"api/constants/#pyinst.constants.OpticalPowerUnit.W","text":"","title":"W"},{"location":"api/constants/#pyinst.constants.TemperatureUnit","text":"Bases: IntEnum Source code in pyinst\\constants.py 84 85 86 87 @unique class TemperatureUnit ( IntEnum ): F = 0 C = 1","title":"TemperatureUnit"},{"location":"api/constants/#pyinst.constants.TemperatureUnit.F","text":"","title":"F"},{"location":"api/constants/#pyinst.constants.TemperatureUnit.C","text":"","title":"C"},{"location":"api/constants/#pyinst.constants.OpticalBandwidthUnit","text":"Bases: IntEnum Source code in pyinst\\constants.py 90 91 92 93 @unique class OpticalBandwidthUnit ( IntEnum ): GHZ = 0 NM = 1","title":"OpticalBandwidthUnit"},{"location":"api/constants/#pyinst.constants.OpticalBandwidthUnit.GHZ","text":"","title":"GHZ"},{"location":"api/constants/#pyinst.constants.OpticalBandwidthUnit.NM","text":"","title":"NM"},{"location":"api/constants/#pyinst.constants.SerialParity","text":"Bases: Enum Source code in pyinst\\constants.py 96 97 98 99 100 101 102 @unique class SerialParity ( Enum ): NONE = 'N' EVEN = 'E' ODD = 'O' MARK = 'M' SPACE = 'S'","title":"SerialParity"},{"location":"api/constants/#pyinst.constants.SerialParity.NONE","text":"","title":"NONE"},{"location":"api/constants/#pyinst.constants.SerialParity.EVEN","text":"","title":"EVEN"},{"location":"api/constants/#pyinst.constants.SerialParity.ODD","text":"","title":"ODD"},{"location":"api/constants/#pyinst.constants.SerialParity.MARK","text":"","title":"MARK"},{"location":"api/constants/#pyinst.constants.SerialParity.SPACE","text":"","title":"SPACE"},{"location":"api/constants/#pyinst.constants.SerialStopBits","text":"Bases: Enum Source code in pyinst\\constants.py 105 106 107 108 109 @unique class SerialStopBits ( Enum ): ONE = 1 ONE_POINT_FIVE = 1.5 TWO = 2","title":"SerialStopBits"},{"location":"api/constants/#pyinst.constants.SerialStopBits.ONE","text":"","title":"ONE"},{"location":"api/constants/#pyinst.constants.SerialStopBits.ONE_POINT_FIVE","text":"","title":"ONE_POINT_FIVE"},{"location":"api/constants/#pyinst.constants.SerialStopBits.TWO","text":"","title":"TWO"},{"location":"api/constants/#pyinst.constants.SerialByteSize","text":"Bases: Enum Source code in pyinst\\constants.py 112 113 114 115 116 117 @unique class SerialByteSize ( Enum ): FIVEBITS = 5 SIXBITS = 6 SEVENBITS = 7 EIGHTBITS = 8","title":"SerialByteSize"},{"location":"api/constants/#pyinst.constants.SerialByteSize.FIVEBITS","text":"","title":"FIVEBITS"},{"location":"api/constants/#pyinst.constants.SerialByteSize.SIXBITS","text":"","title":"SIXBITS"},{"location":"api/constants/#pyinst.constants.SerialByteSize.SEVENBITS","text":"","title":"SEVENBITS"},{"location":"api/constants/#pyinst.constants.SerialByteSize.EIGHTBITS","text":"","title":"EIGHTBITS"},{"location":"api/functions/","text":"","title":"Functions"},{"location":"api/models/","text":"Instrument Model classes are types to drive specific instrument model. An Instrument Model class always starts with a prefix Model , for example: ModelAQ6370 , ModelOTF980 . All Instrument Model classes can be directly imported from pyinst name space. The Instrument Model is immediately opened on object creation. The first parameter of __init__ function is always resource_name . For VISA compliant instruments, it is the VISA resource name or alias. For other instruments connected with serial port, it is the port name. For other instruments connected with USB, it is the S/N of the instrument/USB chip. For more details, please refer to pyInst documentation. Examples: >>> from pyinst import ModelN7744A >>> opm = ModelN7744A ( 'GPIB1::1::INSTR' , slot = 2 ) >>> opm . get_power_value () -10.85 >>> opm . close () # release instrument resource Note An Instrument Model object is a function component in logic, does not correspond with the physical topography of the real-world instrument. For example, for OPM N7744A, it has 4 slots of OPM function components. Each slot can be considered as an independent ModelN7744A object. Instrument Model classes also support context management, so you can use the \"with\" statement to ensure that the instrument resource is closed after useage. Examples: >>> with ModelN7744A ( 'GPIB1::1::INSTR' , slot = 2 ) as opm : >>> opm . get_power_value () >>> -10.85 BaseModel815x_VOA \u00a4 Bases: VisaInstrument , TypeVOA Base class of Keysight 815x variable optical attenuators. Source code in pyinst\\models.py 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 class BaseModel815x_VOA ( VisaInstrument , TypeVOA ): \"\"\"Base class of Keysight 815x variable optical attenuators.\"\"\" def __init__ ( self , resource_name : str , slot : int , channel : int , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: slot number in the frame. channel: channel number. kwargs: directly passed to `VisaInstrument.__init__` \"\"\" super () . __init__ ( resource_name , ** kwargs ) self . _slot = slot self . _channel = channel @property def min_frequency ( self ) -> float : return super () . min_frequency @property def max_frequency ( self ) -> float : return super () . max_frequency @property def min_wavelength ( self ) -> float : cmd = \":INPut {slot:d} :CHANnel {channel:d} :WAVelength? MIN\" . format ( slot = self . _slot , channel = self . _channel ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl @property def max_wavelength ( self ) -> float : cmd = \":INPut {slot:d} :CHANnel {channel:d} :WAVelength? MAX\" . format ( slot = self . _slot , channel = self . _channel ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl @property def min_att ( self ) -> float : cmd = \":INPut {slot:d} :CHANnel {channel:d} :ATTenuation? MIN\" . format ( slot = self . _slot , channel = self . _channel ) att = float ( self . query ( cmd )) return att @property def max_att ( self ) -> float : cmd = \":INPut {slot:d} :CHANnel {channel:d} :ATTenuation? MAX\" . format ( slot = self . _slot , channel = self . _channel ) att = float ( self . query ( cmd )) return att @property def min_att_offset ( self ) -> float : cmd = \":INPut {slot:d} :CHANnel {channel:d} :OFFSet? MIN\" . format ( slot = self . _slot , channel = self . _channel ) offset = float ( self . query ( cmd )) return offset @property def max_att_offset ( self ) -> float : cmd = \":INPut {slot:d} :CHANnel {channel:d} :OFFSet? MAX\" . format ( slot = self . _slot , channel = self . _channel ) offset = float ( self . query ( cmd )) return offset def get_frequency ( self ) -> float : return super () . get_frequency () def set_frequency ( self , frequency : int | float ) -> None : return super () . set_frequency ( frequency ) def get_wavelength ( self ) -> float : cmd = \":INPut {slot:d} :CHANnel {channel:d} :WAVelength?\" . format ( slot = self . _slot , channel = self . _channel ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl def set_wavelength ( self , wavelength : int | float ) -> None : if not self . min_wavelength <= wavelength <= self . max_wavelength : raise ValueError ( \"param wavelength out of range: {wl} \" . format ( wl = wavelength )) cmd = \":INPut {slot:d} :CHANnel {channel:d} :WAVelength {wl:.4f} NM\" . format ( slot = self . _slot , channel = self . _channel , wl = wavelength ) self . command ( cmd ) def enable ( self , en : bool = True ) -> None : if not isinstance ( en , bool ): raise TypeError ( \"param en should be bool\" ) cmd = \":OUTPut {slot:d} :CHANnel {channel:d} :STATe {state:d} \" . format ( slot = self . _slot , channel = self . _channel , state = en ) self . command ( cmd ) def disable ( self ) -> None : self . enable ( False ) def is_enabled ( self ) -> bool : cmd = \":OUTPut {slot:d} :CHANnel {channel:d} :STATe?\" . format ( slot = self . _slot , channel = self . _channel ) status = bool ( int ( self . query ( cmd ))) return status def get_att ( self ) -> float : cmd = \":INPut {slot:d} :CHANnel {channel:d} :ATTenuation?\" . format ( slot = self . _slot , channel = self . _channel ) att = float ( self . query ( cmd )) return att def set_att ( self , att : int | float ) -> None : if not self . min_att <= att <= self . max_att : raise ValueError ( \"param att out of range: {att} \" . format ( att = att )) cmd = \":INPut {slot:d} :CHANnel {channel:d} :ATTenuation {att:.3f} DB\" . format ( slot = self . _slot , channel = self . _channel , att = att ) self . command ( cmd ) def get_att_offset ( self ) -> float : cmd = \":INPut {slot:d} :CHANnel {channel:d} :OFFSet?\" . format ( slot = self . _slot , channel = self . _channel ) offset = float ( self . query ( cmd )) return offset def set_att_offset ( self , offset : int | float ) -> None : if not self . min_att_offset <= offset <= self . max_att_offset : raise ValueError ( \"param offset out of range: {offset} \" . format ( offset = offset )) cmd = \":INPut {slot:d} :CHANnel {channel:d} :OFFSet {offset:.3f} DB\" . format ( slot = self . _slot , channel = self . _channel , offset = offset ) self . command ( cmd ) __init__ ( resource_name , slot , channel , ** kwargs ) \u00a4 Parameters: Name Type Description Default resource_name str Resource name or alias of the VISA resource to open. required slot int slot number in the frame. required channel int channel number. required kwargs directly passed to VisaInstrument.__init__ required Source code in pyinst\\models.py 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 def __init__ ( self , resource_name : str , slot : int , channel : int , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: slot number in the frame. channel: channel number. kwargs: directly passed to `VisaInstrument.__init__` \"\"\" super () . __init__ ( resource_name , ** kwargs ) self . _slot = slot self . _channel = channel BaseModel816x_OPM \u00a4 Bases: VisaInstrument , TypeOPM Base class of Keysight 816x optical power meters. Source code in pyinst\\models.py 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 1791 1792 1793 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 class BaseModel816x_OPM ( VisaInstrument , TypeOPM ): \"\"\"Base class of Keysight 816x optical power meters.\"\"\" def __init__ ( self , resource_name : str , slot : int , channel : int , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: slot number in the frame. channel: channel number. kwargs: directly passed to `VisaInstrument.__init__`. \"\"\" super () . __init__ ( resource_name , ** kwargs ) self . _slot = slot self . _channel = channel @property def min_frequency ( self ) -> float : return super () . min_frequency @property def max_frequency ( self ) -> float : return super () . max_frequency @property def min_wavelength ( self ) -> float : cmd = \":SENSe {slot:d} :CHANnel {channel:d} :POWer:WAVelength? MIN\" . format ( slot = self . _slot , channel = self . _channel ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl @property def max_wavelength ( self ) -> float : cmd = \":SENSe {slot:d} :CHANnel {channel:d} :POWer:WAVelength? MAX\" . format ( slot = self . _slot , channel = self . _channel ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl @property def min_avg_time ( self ) -> float : return 0.1 # 100us @property def max_avg_time ( self ) -> float : return 10000 # 10s @property def min_pow_cal ( self ) -> float : return - 200 @property def max_pow_cal ( self ) -> float : return 200 def get_frequency ( self ) -> float : return super () . get_frequency () def set_frequency ( self , frequency : int | float ) -> None : return super () . set_frequency ( frequency ) def get_wavelength ( self ) -> float : cmd = \":SENSe {slot:d} :CHANnel {channel:d} :POWer:WAVelength?\" . format ( slot = self . _slot , channel = self . _channel ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl def set_wavelength ( self , wavelength : int | float ) -> None : if not self . min_wavelength <= wavelength <= self . max_wavelength : raise ValueError ( \"param wavelength out of range: {wl} \" . format ( wl = wavelength )) cmd = \":SENSe {slot:d} :CHANnel {channel:d} :POWer:WAVelength {wl:.4f} NM\" . format ( slot = self . _slot , channel = self . _channel , wl = wavelength ) self . command ( cmd ) def get_power_value ( self ) -> float : cmd = \":FETCh {slot:d} :CHANnel {channel:d} :POWer?\" . format ( slot = self . _slot , channel = self . _channel ) value = float ( self . query ( cmd )) return value def get_power_unit ( self ) -> OpticalPowerUnit : cmd = \":SENSe {slot:d} :CHANnel {channel:d} :POWer:UNIT?\" . format ( slot = self . _slot , channel = self . _channel ) unit_int = int ( self . query ( cmd )) return OpticalPowerUnit ( unit_int ) def set_power_unit ( self , unit : OpticalPowerUnit ) -> None : unit = OpticalPowerUnit ( unit ) cmd = \":SENSe {slot:d} :CHANnel {channel:d} :POWer:UNIT {unit:d} \" . format ( slot = self . _slot , channel = self . _channel , unit = unit ) self . command ( cmd ) def get_pow_cal ( self ) -> float : cmd = \":SENSe {slot:d} :CHANnel {channel:d} :CORRection?\" . format ( slot = self . _slot , channel = self . _channel ) cal = float ( self . query ( cmd )) return cal def set_pow_cal ( self , value : int | float ) -> None : if not self . min_pow_cal <= value <= self . max_pow_cal : raise ValueError ( \"param value out of range: {value} \" . format ( value = value )) cmd = \":SENSe {slot:d} :CHANnel {channel:d} :CORRection {value:.4f} DB\" . format ( slot = self . _slot , channel = self . _channel , value = value ) self . command ( cmd ) def get_avg_time ( self ) -> float : cmd = \":SENSe {slot:d} :CHANnel {channel:d} :POWer:ATIMe?\" . format ( slot = self . _slot , channel = self . _channel ) avg_t = float ( self . query ( cmd )) * 1000 return avg_t def set_avg_time ( self , value : int | float ) -> None : if not self . min_avg_time <= value <= self . max_avg_time : raise ValueError ( \"param value out of range: {value} \" . format ( value = value )) cmd = \":SENSe {slot:d} :CHANnel {channel:d} :POWer:ATIMe {value:.4f} \" . format ( slot = self . _slot , channel = self . _channel , value = value ) self . command ( cmd ) __init__ ( resource_name , slot , channel , ** kwargs ) \u00a4 Parameters: Name Type Description Default resource_name str Resource name or alias of the VISA resource to open. required slot int slot number in the frame. required channel int channel number. required kwargs directly passed to VisaInstrument.__init__ . required Source code in pyinst\\models.py 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 def __init__ ( self , resource_name : str , slot : int , channel : int , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: slot number in the frame. channel: channel number. kwargs: directly passed to `VisaInstrument.__init__`. \"\"\" super () . __init__ ( resource_name , ** kwargs ) self . _slot = slot self . _channel = channel BaseModelAQ2200_OPM \u00a4 Bases: VisaInstrument , TypeOPM Base Model of AQ2200 Series, application type Sensor. Source code in pyinst\\models.py 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 class BaseModelAQ2200_OPM ( VisaInstrument , TypeOPM ): \"\"\"Base Model of AQ2200 Series, application type Sensor.\"\"\" def __init__ ( self , resource_name : str , slot : int , channel : int , ** kwargs ) -> None : \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: slot number in the frame channel: channel number kwargs: directly passed to `VisaInstrument.__init__` \"\"\" super ( BaseModelAQ2200_OPM , self ) . __init__ ( resource_name , read_termination = '' , ** kwargs ) self . _slot = slot self . _channel = channel @property def min_frequency ( self ) -> float : return super () . min_frequency @property def max_frequency ( self ) -> float : return super () . max_frequency @property def min_wavelength ( self ) -> float : cmd = \":SENS {slot:d} :CHAN {slot:d} :POW:WAV? MIN\" . format ( slot = self . _slot , channel = self . _channel ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl @property def max_wavelength ( self ) -> float : cmd = \":SENS {slot:d} :CHAN {slot:d} :POW:WAV? MAX\" . format ( slot = self . _slot , channel = self . _channel ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl @property def min_avg_time ( self ) -> float : return 0.1 # 100us @property def max_avg_time ( self ) -> float : return 10000 # 10s @property def avg_time_table ( self ) -> tuple : \"\"\" AQ-2200 Series OPM only support discrete averaging values. This table contains all the valid averaging time value. If the averaging time value set with self.set_avg_time() is not valid, a warning will be displayed and the value will fall back to the closest value in this table. No exception will be raised. \"\"\" return ( 0.1 , 0.2 , 0.5 , 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 , 500 , 1000 , 2000 , 5000 , 10000 , ) @property def min_pow_cal ( self ) -> float : return - 180 @property def max_pow_cal ( self ) -> float : return 200 def get_frequency ( self ) -> float : return super () . get_frequency () def set_frequency ( self , frequency : int | float ) -> None : return super () . set_frequency ( frequency ) def get_wavelength ( self ) -> float : cmd = \":SENS {slot:d} :CHAN {channel:d} :POW:WAV?\" . format ( slot = self . _slot , channel = self . _channel ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl def set_wavelength ( self , wavelength : int | float ) -> None : if not self . min_wavelength <= wavelength <= self . max_wavelength : raise ValueError ( \"param wavelength out of range: {wl} \" . format ( wl = wavelength )) cmd = \":SENS {slot:d} :CHAN {channel:d} :POW:WAV {wl} NM\" . format ( slot = self . _slot , channel = self . _channel , wl = wavelength ) self . command ( cmd ) def get_power_value ( self ) -> float : cmd = \":FETC {slot} :CHAN {channel} :POW?\" . format ( slot = self . _slot , channel = self . _channel ) power = float ( self . query ( cmd )) return power def get_power_unit ( self ) -> OpticalPowerUnit : cmd = \":SENS {slot:d} :CHAN {channel:d} :POW:UNIT?\" . format ( slot = self . _slot , channel = self . _channel ) unit_int = int ( self . query ( cmd )) return OpticalPowerUnit ( unit_int ) def set_power_unit ( self , unit : OpticalPowerUnit ) -> None : unit = OpticalPowerUnit ( unit ) cmd = \":SENS {slot:d} :CHAN {channel:d} :POW:UNIT {unit:d} \" . format ( slot = self . _slot , channel = self . _channel , unit = unit ) self . command ( cmd ) def get_pow_cal ( self ) -> float : cmd = \":SENS {slot:d} :CHAN {channel:d} :CORR?\" . format ( slot = self . _slot , channel = self . _channel ) cal = float ( self . query ( cmd )) return cal def set_pow_cal ( self , value : int | float ) -> None : if not self . min_pow_cal <= value <= self . max_pow_cal : raise ValueError ( \"param value out of range: {value} \" . format ( value = value )) cmd = \":SENS {slot:d} :CHAN {channel:d} :CORR {value:.4f} DB\" . format ( slot = self . _slot , channel = self . _channel , value = value ) self . command ( cmd ) def get_avg_time ( self ) -> float : cmd = \":SENS {slot:d} :CHAN {channel:d} :POW:ATIM?\" . format ( slot = self . _slot , channel = self . _channel ) avg_t = float ( self . query ( cmd )) * 1000 return avg_t def set_avg_time ( self , value : int | float ) -> None : if not self . min_avg_time <= value <= self . max_avg_time : raise ValueError ( \"param value out of range: {value} \" . format ( value = value )) value = round ( value , 1 ) if value in self . avg_time_table : valid_value = value else : l = list ( self . avg_time_table ) l . sort ( key = lambda x : abs ( x - value )) valid_value = l [ 0 ] warnings . warn ( \"Averaging time value {value} not valid. \" \"Fall back to the closest valid value {valid_value} .\" . format ( value = value , valid_value = valid_value ), InstrWarning ) if valid_value < 1 : v = round ( valid_value * 1000 ) u = \"US\" else : v = valid_value u = \"MS\" cmd = \":SENS {slot:d} :CHAN {channel:d} :POW:ATIM {value:d}{unit} \" . format ( slot = self . _slot , channel = self . _channel , value = v , unit = u ) self . command ( cmd ) __init__ ( resource_name , slot , channel , ** kwargs ) \u00a4 Parameters: Name Type Description Default resource_name str Resource name or alias of the VISA resource to open. required slot int slot number in the frame required channel int channel number required kwargs directly passed to VisaInstrument.__init__ required Source code in pyinst\\models.py 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 def __init__ ( self , resource_name : str , slot : int , channel : int , ** kwargs ) -> None : \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: slot number in the frame channel: channel number kwargs: directly passed to `VisaInstrument.__init__` \"\"\" super ( BaseModelAQ2200_OPM , self ) . __init__ ( resource_name , read_termination = '' , ** kwargs ) self . _slot = slot self . _channel = channel avg_time_table () property \u00a4 AQ-2200 Series OPM only support discrete averaging values. This table contains all the valid averaging time value. If the averaging time value set with self.set_avg_time() is not valid, a warning will be displayed and the value will fall back to the closest value in this table. No exception will be raised. Source code in pyinst\\models.py 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 @property def avg_time_table ( self ) -> tuple : \"\"\" AQ-2200 Series OPM only support discrete averaging values. This table contains all the valid averaging time value. If the averaging time value set with self.set_avg_time() is not valid, a warning will be displayed and the value will fall back to the closest value in this table. No exception will be raised. \"\"\" return ( 0.1 , 0.2 , 0.5 , 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 , 500 , 1000 , 2000 , 5000 , 10000 , ) BaseModelAQ2200_VOA \u00a4 Bases: VisaInstrument , TypeVOA The base class of AQ2200 Series, application type ATTN, without built-in OPM. Source code in pyinst\\models.py 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 class BaseModelAQ2200_VOA ( VisaInstrument , TypeVOA ): \"\"\"The base class of AQ2200 Series, application type ATTN, without built-in OPM.\"\"\" def __init__ ( self , resource_name : str , slot : int , channel : int , ** kwargs ) -> None : \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: The slot number in the frame. channel: The channel number. **kwargs: Directly passed to `VisaInstrument.__init__` \"\"\" super () . __init__ ( resource_name , read_termination = '' , ** kwargs ) self . _slot = slot self . _channel = channel @property def min_frequency ( self ) -> float : \"\"\"The minimum settable optical frequency value in THz.\"\"\" return super () . min_frequency @property def max_frequency ( self ) -> float : \"\"\"The maximum settable optical frequency value in THz.\"\"\" return super () . max_frequency @property def min_wavelength ( self ) -> float : \"\"\"The minimum settable optical wavelength value in nm.\"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :WAV? MIN\" . format ( slot = self . _slot , channel = self . _channel ) wl_str = self . query ( cmd ) wl = float ( wl_str ) * 10 ** 9 return wl @property def max_wavelength ( self ) -> float : \"\"\"The maximum settable optical wavelength value in nm.\"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :WAV? MAX\" . format ( slot = self . _slot , channel = self . _channel ) wl_str = self . query ( cmd ) wl = float ( wl_str ) * 10 ** 9 return wl @property def min_att ( self ) -> float : \"\"\"Minimum settable attenuation in dB. The minimum settable attenuation = 0 dB + the optical attenuation offset value. \"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :ATT? MIN\" . format ( slot = self . _slot , channel = self . _channel ) att = float ( self . query ( cmd )) return att @property def max_att ( self ) -> float : \"\"\"Maximum settable attenuation in dB. The maximum settable attenuation = The maximum attenuation + the optical attenuation offset value. \"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :ATT? MAX\" . format ( slot = self . _slot , channel = self . _channel ) att = float ( self . query ( cmd )) return att @property def min_att_offset ( self ) -> float : \"\"\"Minimum attenuation offset value in dB.\"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :OFFS? MIN\" . format ( slot = self . _slot , channel = self . _channel ) offset = float ( self . query ( cmd )) return offset @property def max_att_offset ( self ) -> float : \"\"\"Maximum attenuation offset value in dB.\"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :OFFS? MAX\" . format ( slot = self . _slot , channel = self . _channel ) offset = float ( self . query ( cmd )) return offset def get_frequency ( self ) -> float : \"\"\" Queries the optical frequency setting of the instrument in THz. Returns: The optical frequency setting value in THz. \"\"\" return super () . get_frequency () def set_frequency ( self , frequency : int | float ) -> None : \"\"\"Set optical frequency. Args: frequency: The optical frequency setting in THz. \"\"\" return super () . set_frequency ( frequency ) def get_wavelength ( self ) -> float : \"\"\"Queries the optical wavelength setting of the instrument in nm. Returns: The optical wavelength setting value in nm. \"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :WAV?\" . format ( slot = self . _slot , channel = self . _channel ) wl_str = self . query ( cmd ) wl = float ( wl_str ) * 10 ** 9 return wl def set_wavelength ( self , wavelength : int | float ) -> None : \"\"\"Set optical wavelength. Args: wavelength: The optical wavelength setting in nm. \"\"\" if not self . min_wavelength <= wavelength <= self . max_wavelength : raise ValueError ( f 'Parameter wavelength is out of range: { wavelength !r} ' ) cmd = \":INP {slot:d} :CHAN {channel:d} :WAV {wl:f} NM\" . format ( slot = self . _slot , channel = self . _channel , wl = wavelength ) self . command ( cmd ) def enable ( self , en : bool = True ) -> None : \"\"\" Enable (disable) the optical output. Args: en: True = Enable, False = Disable. \"\"\" if not isinstance ( en , bool ): raise TypeError ( f \"Parameter en must be a bool, not ' { type ( en ) . __name__ } '.\" ) cmd = \":OUTP {slot:d} :CHAN {channel:d} {en:d} \" . format ( slot = self . _slot , channel = self . _channel , en = en ) self . command ( cmd ) def disable ( self ) -> None : \"\"\"Disable the optical output.\"\"\" self . enable ( False ) def is_enabled ( self ) -> bool : \"\"\" Returns: Whether the optical output is enabled. \"\"\" cmd = \":OUTP {slot:d} :CHAN {channel:d} ?\" . format ( slot = self . _slot , channel = self . _channel ) return bool ( int ( self . query ( cmd ))) def get_att ( self ) -> float : \"\"\" Get the current attenuation value in dB. Includes the attenuation offset. Queried attenuator = the actual attenuator value + attenuator offset Use `get_att_offset` and `set_att_offset` to operate with the attenuator offset. Returns: The attenuation value in dB. \"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :ATT?\" . format ( slot = self . _slot , channel = self . _channel ) att = float ( self . query ( cmd )) return att def set_att ( self , att : int | float ) -> None : \"\"\" Set attenuation value in dB. Includes the attenuation offset. Refer to `get_att` for more information. Args: att: The attenuation value in dB. \"\"\" if not self . min_att <= att <= self . max_att : raise ValueError ( f 'Parameter att is out of range: { att !r} ' ) cmd = \":INP {slot:d} :CHAN {channel:d} :ATT {att:.3f} dB\" . format ( slot = self . _slot , channel = self . _channel , att = att ) self . command ( cmd ) def get_att_offset ( self ) -> float : \"\"\" Get the attenuation offset value in dB. Returns: The attenuation offset in dB. \"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :OFFS?\" . format ( slot = self . _slot , channel = self . _channel ) offset = float ( self . query ( cmd )) return offset def set_att_offset ( self , offset : int | float ) -> None : \"\"\" Set the attenuation offset value in dB. Args: offset: The attenuation offset in dB. \"\"\" if not self . min_att_offset <= offset <= self . max_att_offset : raise ValueError ( f \"Parameter offset is out of range: { offset !r} \" ) cmd = \":INP {slot:d} :CHAN {channel:d} :OFFS {offset:.3f} dB\" . format ( slot = self . _slot , channel = self . _channel , offset = offset ) self . command ( cmd ) __init__ ( resource_name , slot , channel , ** kwargs ) \u00a4 Parameters: Name Type Description Default resource_name str Resource name or alias of the VISA resource to open. required slot int The slot number in the frame. required channel int The channel number. required **kwargs Directly passed to VisaInstrument.__init__ {} Source code in pyinst\\models.py 950 951 952 953 954 955 956 957 958 959 960 def __init__ ( self , resource_name : str , slot : int , channel : int , ** kwargs ) -> None : \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: The slot number in the frame. channel: The channel number. **kwargs: Directly passed to `VisaInstrument.__init__` \"\"\" super () . __init__ ( resource_name , read_termination = '' , ** kwargs ) self . _slot = slot self . _channel = channel disable () \u00a4 Disable the optical output. Source code in pyinst\\models.py 1075 1076 1077 def disable ( self ) -> None : \"\"\"Disable the optical output.\"\"\" self . enable ( False ) enable ( en = True ) \u00a4 Enable (disable) the optical output. Parameters: Name Type Description Default en bool True = Enable, False = Disable. True Source code in pyinst\\models.py 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 def enable ( self , en : bool = True ) -> None : \"\"\" Enable (disable) the optical output. Args: en: True = Enable, False = Disable. \"\"\" if not isinstance ( en , bool ): raise TypeError ( f \"Parameter en must be a bool, not ' { type ( en ) . __name__ } '.\" ) cmd = \":OUTP {slot:d} :CHAN {channel:d} {en:d} \" . format ( slot = self . _slot , channel = self . _channel , en = en ) self . command ( cmd ) get_att () \u00a4 Get the current attenuation value in dB. Includes the attenuation offset. Queried attenuator = the actual attenuator value + attenuator offset Use get_att_offset and set_att_offset to operate with the attenuator offset. Returns: Type Description float The attenuation value in dB. Source code in pyinst\\models.py 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 def get_att ( self ) -> float : \"\"\" Get the current attenuation value in dB. Includes the attenuation offset. Queried attenuator = the actual attenuator value + attenuator offset Use `get_att_offset` and `set_att_offset` to operate with the attenuator offset. Returns: The attenuation value in dB. \"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :ATT?\" . format ( slot = self . _slot , channel = self . _channel ) att = float ( self . query ( cmd )) return att get_att_offset () \u00a4 Get the attenuation offset value in dB. Returns: Type Description float The attenuation offset in dB. Source code in pyinst\\models.py 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 def get_att_offset ( self ) -> float : \"\"\" Get the attenuation offset value in dB. Returns: The attenuation offset in dB. \"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :OFFS?\" . format ( slot = self . _slot , channel = self . _channel ) offset = float ( self . query ( cmd )) return offset get_frequency () \u00a4 Queries the optical frequency setting of the instrument in THz. Returns: Type Description float The optical frequency setting value in THz. Source code in pyinst\\models.py 1024 1025 1026 1027 1028 1029 1030 1031 def get_frequency ( self ) -> float : \"\"\" Queries the optical frequency setting of the instrument in THz. Returns: The optical frequency setting value in THz. \"\"\" return super () . get_frequency () get_wavelength () \u00a4 Queries the optical wavelength setting of the instrument in nm. Returns: Type Description float The optical wavelength setting value in nm. Source code in pyinst\\models.py 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 def get_wavelength ( self ) -> float : \"\"\"Queries the optical wavelength setting of the instrument in nm. Returns: The optical wavelength setting value in nm. \"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :WAV?\" . format ( slot = self . _slot , channel = self . _channel ) wl_str = self . query ( cmd ) wl = float ( wl_str ) * 10 ** 9 return wl is_enabled () \u00a4 Returns: Type Description bool Whether the optical output is enabled. Source code in pyinst\\models.py 1079 1080 1081 1082 1083 1084 1085 def is_enabled ( self ) -> bool : \"\"\" Returns: Whether the optical output is enabled. \"\"\" cmd = \":OUTP {slot:d} :CHAN {channel:d} ?\" . format ( slot = self . _slot , channel = self . _channel ) return bool ( int ( self . query ( cmd ))) max_att () property \u00a4 Maximum settable attenuation in dB. The maximum settable attenuation = The maximum attenuation + the optical attenuation offset value. Source code in pyinst\\models.py 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 @property def max_att ( self ) -> float : \"\"\"Maximum settable attenuation in dB. The maximum settable attenuation = The maximum attenuation + the optical attenuation offset value. \"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :ATT? MAX\" . format ( slot = self . _slot , channel = self . _channel ) att = float ( self . query ( cmd )) return att max_att_offset () property \u00a4 Maximum attenuation offset value in dB. Source code in pyinst\\models.py 1017 1018 1019 1020 1021 1022 @property def max_att_offset ( self ) -> float : \"\"\"Maximum attenuation offset value in dB.\"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :OFFS? MAX\" . format ( slot = self . _slot , channel = self . _channel ) offset = float ( self . query ( cmd )) return offset max_frequency () property \u00a4 The maximum settable optical frequency value in THz. Source code in pyinst\\models.py 967 968 969 970 @property def max_frequency ( self ) -> float : \"\"\"The maximum settable optical frequency value in THz.\"\"\" return super () . max_frequency max_wavelength () property \u00a4 The maximum settable optical wavelength value in nm. Source code in pyinst\\models.py 980 981 982 983 984 985 986 @property def max_wavelength ( self ) -> float : \"\"\"The maximum settable optical wavelength value in nm.\"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :WAV? MAX\" . format ( slot = self . _slot , channel = self . _channel ) wl_str = self . query ( cmd ) wl = float ( wl_str ) * 10 ** 9 return wl min_att () property \u00a4 Minimum settable attenuation in dB. The minimum settable attenuation = 0 dB + the optical attenuation offset value. Source code in pyinst\\models.py 988 989 990 991 992 993 994 995 996 997 @property def min_att ( self ) -> float : \"\"\"Minimum settable attenuation in dB. The minimum settable attenuation = 0 dB + the optical attenuation offset value. \"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :ATT? MIN\" . format ( slot = self . _slot , channel = self . _channel ) att = float ( self . query ( cmd )) return att min_att_offset () property \u00a4 Minimum attenuation offset value in dB. Source code in pyinst\\models.py 1010 1011 1012 1013 1014 1015 @property def min_att_offset ( self ) -> float : \"\"\"Minimum attenuation offset value in dB.\"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :OFFS? MIN\" . format ( slot = self . _slot , channel = self . _channel ) offset = float ( self . query ( cmd )) return offset min_frequency () property \u00a4 The minimum settable optical frequency value in THz. Source code in pyinst\\models.py 962 963 964 965 @property def min_frequency ( self ) -> float : \"\"\"The minimum settable optical frequency value in THz.\"\"\" return super () . min_frequency min_wavelength () property \u00a4 The minimum settable optical wavelength value in nm. Source code in pyinst\\models.py 972 973 974 975 976 977 978 @property def min_wavelength ( self ) -> float : \"\"\"The minimum settable optical wavelength value in nm.\"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :WAV? MIN\" . format ( slot = self . _slot , channel = self . _channel ) wl_str = self . query ( cmd ) wl = float ( wl_str ) * 10 ** 9 return wl set_att ( att ) \u00a4 Set attenuation value in dB. Includes the attenuation offset. Refer to get_att for more information. Parameters: Name Type Description Default att int | float The attenuation value in dB. required Source code in pyinst\\models.py 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 def set_att ( self , att : int | float ) -> None : \"\"\" Set attenuation value in dB. Includes the attenuation offset. Refer to `get_att` for more information. Args: att: The attenuation value in dB. \"\"\" if not self . min_att <= att <= self . max_att : raise ValueError ( f 'Parameter att is out of range: { att !r} ' ) cmd = \":INP {slot:d} :CHAN {channel:d} :ATT {att:.3f} dB\" . format ( slot = self . _slot , channel = self . _channel , att = att ) self . command ( cmd ) set_att_offset ( offset ) \u00a4 Set the attenuation offset value in dB. Parameters: Name Type Description Default offset int | float The attenuation offset in dB. required Source code in pyinst\\models.py 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 def set_att_offset ( self , offset : int | float ) -> None : \"\"\" Set the attenuation offset value in dB. Args: offset: The attenuation offset in dB. \"\"\" if not self . min_att_offset <= offset <= self . max_att_offset : raise ValueError ( f \"Parameter offset is out of range: { offset !r} \" ) cmd = \":INP {slot:d} :CHAN {channel:d} :OFFS {offset:.3f} dB\" . format ( slot = self . _slot , channel = self . _channel , offset = offset ) self . command ( cmd ) set_frequency ( frequency ) \u00a4 Set optical frequency. Parameters: Name Type Description Default frequency int | float The optical frequency setting in THz. required Source code in pyinst\\models.py 1033 1034 1035 1036 1037 1038 1039 def set_frequency ( self , frequency : int | float ) -> None : \"\"\"Set optical frequency. Args: frequency: The optical frequency setting in THz. \"\"\" return super () . set_frequency ( frequency ) set_wavelength ( wavelength ) \u00a4 Set optical wavelength. Parameters: Name Type Description Default wavelength int | float The optical wavelength setting in nm. required Source code in pyinst\\models.py 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 def set_wavelength ( self , wavelength : int | float ) -> None : \"\"\"Set optical wavelength. Args: wavelength: The optical wavelength setting in nm. \"\"\" if not self . min_wavelength <= wavelength <= self . max_wavelength : raise ValueError ( f 'Parameter wavelength is out of range: { wavelength !r} ' ) cmd = \":INP {slot:d} :CHAN {channel:d} :WAV {wl:f} NM\" . format ( slot = self . _slot , channel = self . _channel , wl = wavelength ) self . command ( cmd ) BaseModelAQ2200_VOA_with_OPM \u00a4 Bases: BaseModelAQ2200_VOA , TypeOPM The base class of AQ2200 Series, application type ATTN, with built-in OPM. Source code in pyinst\\models.py 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 class BaseModelAQ2200_VOA_with_OPM ( BaseModelAQ2200_VOA , TypeOPM ): \"\"\"The base class of AQ2200 Series, application type ATTN, with built-in OPM. \"\"\" @property def min_avg_time ( self ) -> float : \"\"\"The minimum averaging time in ms.\"\"\" return 10.0 # 10ms @property def max_avg_time ( self ) -> float : \"\"\"The maximum averaging time in ms.\"\"\" return 10000.0 # 10s @property def min_pow_cal ( self ) -> float : \"\"\"The minimum power calibration value in dB.\"\"\" cmd = \":OUTP {slot:d} :CHAN {channel:d} :POW:OFFS? MIN\" . format ( slot = self . _slot , channel = self . _channel ) cal = float ( self . query ( cmd )) return cal @property def max_pow_cal ( self ) -> float : \"\"\"The maximum power calibration value in dB.\"\"\" cmd = \":OUTP {slot:d} :CHAN {channel:d} :POW:OFFS? MAX\" . format ( slot = self . _slot , channel = self . _channel ) cal = float ( self . query ( cmd )) return cal def get_power_value ( self ) -> float : \"\"\"Fetch the value of measured optical power in current unit setting. The measured value includes the power calibration. Measured value (dBm) = the actual measured value (dBm) + power calibration (dB) Refer to `get_pow_cal` and `set_pow_cal` to operate with the power calibration. Returns: The value of the optical power. \"\"\" cmd = \":FETC {slot} :CHAN {channel} :POW?\" . format ( slot = self . _slot , channel = self . _channel ) power = float ( self . query ( cmd )) return power def get_power_unit ( self ) -> OpticalPowerUnit : \"\"\"Get optical power unit setting. Returns: The unit of the optical power. \"\"\" cmd = \":OUTP {slot:d} :CHAN {channel:d} :POW:UNIT?\" . format ( slot = self . _slot , channel = self . _channel ) unit_int = int ( self . query ( cmd )) unit = OpticalPowerUnit ( unit_int ) return unit def set_power_unit ( self , unit : OpticalPowerUnit ) -> None : \"\"\"Set the unit of optical power. Args: unit: The unit of the optical power. \"\"\" unit = OpticalPowerUnit ( unit ) cmd = \":OUTP {slot:d} :CHAN {channel:d} :POW:UNIT {unit:d} \" . format ( slot = self . _slot , channel = self . _channel , unit = unit ) self . command ( cmd ) def get_pow_cal ( self ) -> float : \"\"\" Get the power calibration offset in dB. Returns: The power calibration offset in dB. \"\"\" cmd = \":OUTP {slot:d} :CHAN {channel:d} :POW:OFFS?\" . format ( slot = self . _slot , channel = self . _channel ) cal = float ( self . query ( cmd )) return cal def set_pow_cal ( self , value : int | float ) -> None : \"\"\" Set the power calibration offset in dB. Args: value: The power calibration offset in dB. \"\"\" if not self . min_pow_cal <= value <= self . max_pow_cal : raise ValueError ( f \"Parameter value is out of range: { value !r} \" ) cmd = \":OUTP {slot:d} :CHAN {channel:d} :POW:OFFS {value:.3f} DB\" . format ( slot = self . _slot , channel = self . _channel , value = value ) self . command ( cmd ) def get_avg_time ( self ) -> float : \"\"\" Get the averaging time in ms. Returns: The averaging time in ms. \"\"\" cmd = \":OUTP {slot:d} :CHAN {channel:d} :ATIM?\" . format ( slot = self . _slot , channel = self . _channel ) avg_t = float ( self . query ( cmd )) * 1000 return avg_t def set_avg_time ( self , value : int | float ) -> None : \"\"\" Set the averaging time in ms. Args: value: The averaging time in ms. \"\"\" if not self . min_avg_time <= value <= self . max_avg_time : raise ValueError ( f \"Parameter value is out of range: { value !r} \" ) cmd = \":OUTP {slot:d} :CHAN {channel:d} :ATIM {value:d} MS\" . format ( slot = self . _slot , channel = self . _channel , value = value ) self . command ( cmd ) get_avg_time () \u00a4 Get the averaging time in ms. Returns: Type Description float The averaging time in ms. Source code in pyinst\\models.py 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 def get_avg_time ( self ) -> float : \"\"\" Get the averaging time in ms. Returns: The averaging time in ms. \"\"\" cmd = \":OUTP {slot:d} :CHAN {channel:d} :ATIM?\" . format ( slot = self . _slot , channel = self . _channel ) avg_t = float ( self . query ( cmd )) * 1000 return avg_t get_pow_cal () \u00a4 Get the power calibration offset in dB. Returns: Type Description float The power calibration offset in dB. Source code in pyinst\\models.py 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 def get_pow_cal ( self ) -> float : \"\"\" Get the power calibration offset in dB. Returns: The power calibration offset in dB. \"\"\" cmd = \":OUTP {slot:d} :CHAN {channel:d} :POW:OFFS?\" . format ( slot = self . _slot , channel = self . _channel ) cal = float ( self . query ( cmd )) return cal get_power_unit () \u00a4 Get optical power unit setting. Returns: Type Description OpticalPowerUnit The unit of the optical power. Source code in pyinst\\models.py 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 def get_power_unit ( self ) -> OpticalPowerUnit : \"\"\"Get optical power unit setting. Returns: The unit of the optical power. \"\"\" cmd = \":OUTP {slot:d} :CHAN {channel:d} :POW:UNIT?\" . format ( slot = self . _slot , channel = self . _channel ) unit_int = int ( self . query ( cmd )) unit = OpticalPowerUnit ( unit_int ) return unit get_power_value () \u00a4 Fetch the value of measured optical power in current unit setting. The measured value includes the power calibration. Measured value (dBm) = the actual measured value (dBm) + power calibration (dB) Refer to get_pow_cal and set_pow_cal to operate with the power calibration. Returns: Type Description float The value of the optical power. Source code in pyinst\\models.py 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 def get_power_value ( self ) -> float : \"\"\"Fetch the value of measured optical power in current unit setting. The measured value includes the power calibration. Measured value (dBm) = the actual measured value (dBm) + power calibration (dB) Refer to `get_pow_cal` and `set_pow_cal` to operate with the power calibration. Returns: The value of the optical power. \"\"\" cmd = \":FETC {slot} :CHAN {channel} :POW?\" . format ( slot = self . _slot , channel = self . _channel ) power = float ( self . query ( cmd )) return power max_avg_time () property \u00a4 The maximum averaging time in ms. Source code in pyinst\\models.py 1154 1155 1156 1157 @property def max_avg_time ( self ) -> float : \"\"\"The maximum averaging time in ms.\"\"\" return 10000.0 # 10s max_pow_cal () property \u00a4 The maximum power calibration value in dB. Source code in pyinst\\models.py 1166 1167 1168 1169 1170 1171 @property def max_pow_cal ( self ) -> float : \"\"\"The maximum power calibration value in dB.\"\"\" cmd = \":OUTP {slot:d} :CHAN {channel:d} :POW:OFFS? MAX\" . format ( slot = self . _slot , channel = self . _channel ) cal = float ( self . query ( cmd )) return cal min_avg_time () property \u00a4 The minimum averaging time in ms. Source code in pyinst\\models.py 1149 1150 1151 1152 @property def min_avg_time ( self ) -> float : \"\"\"The minimum averaging time in ms.\"\"\" return 10.0 # 10ms min_pow_cal () property \u00a4 The minimum power calibration value in dB. Source code in pyinst\\models.py 1159 1160 1161 1162 1163 1164 @property def min_pow_cal ( self ) -> float : \"\"\"The minimum power calibration value in dB.\"\"\" cmd = \":OUTP {slot:d} :CHAN {channel:d} :POW:OFFS? MIN\" . format ( slot = self . _slot , channel = self . _channel ) cal = float ( self . query ( cmd )) return cal set_avg_time ( value ) \u00a4 Set the averaging time in ms. Parameters: Name Type Description Default value int | float The averaging time in ms. required Source code in pyinst\\models.py 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 def set_avg_time ( self , value : int | float ) -> None : \"\"\" Set the averaging time in ms. Args: value: The averaging time in ms. \"\"\" if not self . min_avg_time <= value <= self . max_avg_time : raise ValueError ( f \"Parameter value is out of range: { value !r} \" ) cmd = \":OUTP {slot:d} :CHAN {channel:d} :ATIM {value:d} MS\" . format ( slot = self . _slot , channel = self . _channel , value = value ) self . command ( cmd ) set_pow_cal ( value ) \u00a4 Set the power calibration offset in dB. Parameters: Name Type Description Default value int | float The power calibration offset in dB. required Source code in pyinst\\models.py 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 def set_pow_cal ( self , value : int | float ) -> None : \"\"\" Set the power calibration offset in dB. Args: value: The power calibration offset in dB. \"\"\" if not self . min_pow_cal <= value <= self . max_pow_cal : raise ValueError ( f \"Parameter value is out of range: { value !r} \" ) cmd = \":OUTP {slot:d} :CHAN {channel:d} :POW:OFFS {value:.3f} DB\" . format ( slot = self . _slot , channel = self . _channel , value = value ) self . command ( cmd ) set_power_unit ( unit ) \u00a4 Set the unit of optical power. Parameters: Name Type Description Default unit OpticalPowerUnit The unit of the optical power. required Source code in pyinst\\models.py 1200 1201 1202 1203 1204 1205 1206 1207 1208 def set_power_unit ( self , unit : OpticalPowerUnit ) -> None : \"\"\"Set the unit of optical power. Args: unit: The unit of the optical power. \"\"\" unit = OpticalPowerUnit ( unit ) cmd = \":OUTP {slot:d} :CHAN {channel:d} :POW:UNIT {unit:d} \" . format ( slot = self . _slot , channel = self . _channel , unit = unit ) self . command ( cmd ) BaseModelEspecOld \u00a4 Bases: BaseInstrument , TypeTS The base class for old chamber models by Espec MC-711 MT3065 Note Before communication, some configuration must be performed on the chamber: - Device ID: Correspond with the dev_id in the __init__ method. Defaults to 0. Source code in pyinst\\models.py 3524 3525 3526 3527 3528 3529 3530 3531 3532 3533 3534 3535 3536 3537 3538 3539 3540 3541 3542 3543 3544 3545 3546 3547 3548 3549 3550 3551 3552 3553 3554 3555 3556 3557 3558 3559 3560 3561 3562 3563 3564 3565 3566 3567 3568 3569 3570 3571 3572 3573 3574 3575 3576 3577 3578 3579 3580 3581 3582 3583 3584 3585 3586 3587 3588 3589 3590 3591 3592 3593 3594 3595 3596 3597 3598 3599 3600 3601 3602 3603 3604 3605 3606 3607 3608 3609 3610 3611 3612 3613 3614 3615 3616 3617 3618 3619 3620 3621 3622 3623 3624 3625 3626 3627 3628 3629 3630 3631 3632 3633 3634 3635 3636 3637 3638 3639 3640 3641 3642 3643 3644 3645 class BaseModelEspecOld ( BaseInstrument , TypeTS ): \"\"\"The base class for old chamber models by Espec: - MC-711 - MT3065 Note: Before communication, some configuration must be performed on the chamber: - Device ID: Correspond with the dev_id in the `__init__` method. Defaults to 0. \"\"\" brand = \"Espec\" params = [ { \"name\" : \"dev_id\" , \"type\" : \"int\" , \"min\" : 0 , \"max\" : 15 } ] def __init__ ( self , resource_name : str , dev_id : int = 0 , baud_rate : int = 19200 , read_timeout : int | float = 0.5 , ** kwargs ): \"\"\" Args: resource_name: Serial port name. dev_id: The device ID of the chamber. baudrate: Baud rate such as 9600 or 115200 etc.. read_timeout: Timeout in milliseconds for read operations. **kwargs: Directly passed to `serial.Serial()`. \"\"\" super ( BaseModelEspecOld , self ) . __init__ () if dev_id not in range ( 16 ): raise ValueError ( 'Device ID must be between 0 and 15' ) self . __dev_id = dev_id self . __serial = serial . Serial ( port = resource_name , baudrate = baud_rate , timeout = read_timeout , ** kwargs ) self . __serial . setRTS () self . __serial . setDTR () self . __serial . reset_input_buffer () self . __resource_name = resource_name @property def resource_name ( self ) -> str : return self . __resource_name @property def ts_type ( self ) -> TemperatureSourceType : return TemperatureSourceType . CHAMBER def close ( self ): self . __serial . close () def write_cmd ( self , cmd : bytes ): pre = b ' \\x05 ' b_id = ' {dev_id:02X} ' . format ( dev_id = self . __dev_id ) . encode () cmd_body = b_id + cmd checksum = ' {:02X} ' . format ( sum ( cmd_body ))[ - 2 :] . encode () t = pre + cmd_body + checksum self . __serial . reset_input_buffer () self . __serial . write ( t ) def read_reply ( self ): r = self . __serial . read ( 10240 ) if not r : raise ValueError ( 'No reply. Please check the connection and device ID setting.' ) return r # def check_connection(self) -> ConnectionStatus: # try: # self.get_target_temp() # return ConnectionStatus(True) # except Exception as e: # return ConnectionStatus(False, e.args[0] if e.args else None) def run ( self , en : bool = True ) -> None : \"\"\"TODO\"\"\" def stop ( self ) -> None : self . run ( False ) def is_running ( self ) -> bool : \"\"\"TODO\"\"\" def set_target_temp ( self , value : int | float ) -> None : value = round ( value * 10 ) if value < 0 : value = 65536 + value cmd = 'FFWW0D119705 {temp:04X} 0000000000000000' . format ( temp = value ) . encode () self . write_cmd ( cmd ) time . sleep ( 0.5 ) r = self . read_reply () if not r . startswith ( b ' \\x06 ' ): raise ValueError ( 'Unexpected reply: %r ' % r ) def get_target_temp ( self ) -> float : cmd = b 'FFWR0D111401' self . write_cmd ( cmd ) time . sleep ( 0.5 ) r = self . read_reply () if not r . startswith ( b ' \\x02 ' ): raise ValueError ( 'Unexpected reply: %r ' % r ) raw_val = int ( r [ 5 : 9 ] . decode (), 16 ) signed_val = ( raw_val - 65536 ) if raw_val >= 65536 / 2 else raw_val return signed_val / 10 def get_current_temp ( self ) -> float : cmd = b 'FFWR0D111701' self . write_cmd ( cmd ) time . sleep ( 0.5 ) r = self . read_reply () if not r . startswith ( b ' \\x02 ' ): raise ValueError ( 'Unexpected reply: %r ' % r ) raw_val = int ( r [ 5 : 9 ] . decode (), 16 ) signed_val = ( raw_val - 65536 ) if raw_val >= 65536 / 2 else raw_val return signed_val / 10 def set_temp_unit ( self , unit : TemperatureUnit ) -> None : if unit != TemperatureUnit . C : raise ValueError ( 'The temperature unit of this Chamber is fixed to C.' ) def get_temp_unit ( self ) -> TemperatureUnit : return TemperatureUnit . C __init__ ( resource_name , dev_id = 0 , baud_rate = 19200 , read_timeout = 0.5 , ** kwargs ) \u00a4 Parameters: Name Type Description Default resource_name str Serial port name. required dev_id int The device ID of the chamber. 0 baudrate Baud rate such as 9600 or 115200 etc.. required read_timeout int | float Timeout in milliseconds for read operations. 0.5 **kwargs Directly passed to serial.Serial() . {} Source code in pyinst\\models.py 3546 3547 3548 3549 3550 3551 3552 3553 3554 3555 3556 3557 3558 3559 3560 3561 3562 3563 def __init__ ( self , resource_name : str , dev_id : int = 0 , baud_rate : int = 19200 , read_timeout : int | float = 0.5 , ** kwargs ): \"\"\" Args: resource_name: Serial port name. dev_id: The device ID of the chamber. baudrate: Baud rate such as 9600 or 115200 etc.. read_timeout: Timeout in milliseconds for read operations. **kwargs: Directly passed to `serial.Serial()`. \"\"\" super ( BaseModelEspecOld , self ) . __init__ () if dev_id not in range ( 16 ): raise ValueError ( 'Device ID must be between 0 and 15' ) self . __dev_id = dev_id self . __serial = serial . Serial ( port = resource_name , baudrate = baud_rate , timeout = read_timeout , ** kwargs ) self . __serial . setRTS () self . __serial . setDTR () self . __serial . reset_input_buffer () self . __resource_name = resource_name is_running () \u00a4 TODO Source code in pyinst\\models.py 3604 3605 def is_running ( self ) -> bool : \"\"\"TODO\"\"\" run ( en = True ) \u00a4 TODO Source code in pyinst\\models.py 3598 3599 def run ( self , en : bool = True ) -> None : \"\"\"TODO\"\"\" BaseModelN77xx \u00a4 Bases: VisaInstrument Base class for Keysight N77xx Series: N7744A, N7745A, N7747A and N7748A Optical Multiport Power Meters N7751A and N7752A Variable Optical Attenuators and 2-Channel Optical Power Meter N7761A, N7762A and N7764A Variable Optical Attenuators Source code in pyinst\\models.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 class BaseModelN77xx ( VisaInstrument ): \"\"\" Base class for Keysight N77xx Series: - N7744A, N7745A, N7747A and N7748A Optical Multiport Power Meters - N7751A and N7752A Variable Optical Attenuators and 2-Channel Optical Power Meter - N7761A, N7762A and N7764A Variable Optical Attenuators \"\"\" def __init__ ( self , resource_name : str , slot : int , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: The slot number in the frame. **kwargs: Directly passed to `VisaInstrument.__init__` \"\"\" if not 1 <= slot <= self . _max_slot : raise ValueError ( f 'Parameter slot is out of range: { slot !r} . The max slot number is { self . _max_slot } .' ) self . __slot = slot super () . __init__ ( resource_name , ** kwargs ) @property @abstractmethod def _max_slot ( self ): \"\"\"The max valid slot number for the specific instrument model. Defined by specific Instrument Model classes. \"\"\" @property def _slot ( self ): return self . __slot __init__ ( resource_name , slot , ** kwargs ) \u00a4 Parameters: Name Type Description Default resource_name str Resource name or alias of the VISA resource to open. required slot int The slot number in the frame. required **kwargs Directly passed to VisaInstrument.__init__ {} Source code in pyinst\\models.py 81 82 83 84 85 86 87 88 89 90 91 def __init__ ( self , resource_name : str , slot : int , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: The slot number in the frame. **kwargs: Directly passed to `VisaInstrument.__init__` \"\"\" if not 1 <= slot <= self . _max_slot : raise ValueError ( f 'Parameter slot is out of range: { slot !r} . The max slot number is { self . _max_slot } .' ) self . __slot = slot super () . __init__ ( resource_name , ** kwargs ) BaseModelN77xx_OPM \u00a4 Bases: BaseModelN77xx , TypeOPM Source code in pyinst\\models.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 class BaseModelN77xx_OPM ( BaseModelN77xx , TypeOPM ): @property def min_frequency ( self ) -> float : \"\"\"The minimum settable optical frequency value in THz.\"\"\" return super () . min_frequency @property def max_frequency ( self ) -> float : \"\"\"The maximum settable optical frequency value in THz.\"\"\" return super () . max_frequency @property def min_wavelength ( self ) -> float : \"\"\"The minimum settable optical wavelength value in nm.\"\"\" cmd = \":SENS {slot:d} :POW:WAV? MIN\" . format ( slot = self . _slot ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl @property def max_wavelength ( self ) -> float : \"\"\"The maximum settable optical wavelength value in nm.\"\"\" cmd = \":SENS {slot:d} :POW:WAV? MAX\" . format ( slot = self . _slot ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl @property def min_avg_time ( self ) -> float : \"\"\"The minimum averaging time in ms.\"\"\" return 0.001 # 1us @property def max_avg_time ( self ) -> float : \"\"\"The maximum averaging time in ms.\"\"\" return 10000.0 # 10s @property def min_pow_cal ( self ) -> float : \"\"\"The minimum power calibration value in dB.\"\"\" return - 200.0 # dB @property def max_pow_cal ( self ) -> float : \"\"\"The maximum power calibration value in dB.\"\"\" return 200.0 # dB def get_frequency ( self ) -> float : \"\"\" Queries the optical frequency setting of the instrument in THz. Returns: The optical frequency setting value in THz. \"\"\" return super () . get_frequency () def set_frequency ( self , frequency : int | float ) -> None : \"\"\"Set optical frequency. Args: frequency: The optical frequency setting in THz. \"\"\" return super () . set_frequency ( frequency ) def get_wavelength ( self ) -> float : \"\"\"Queries the optical wavelength setting of the instrument in nm. Returns: The optical wavelength setting value in nm. \"\"\" cmd = \":SENS {slot:d} :POW:WAV?\" . format ( slot = self . _slot ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl def set_wavelength ( self , wavelength : int | float ) -> None : \"\"\"Set optical wavelength. Args: wavelength: The optical wavelength setting in nm. \"\"\" if not self . min_wavelength <= wavelength <= self . max_wavelength : raise ValueError ( f \"Parameter wavelength is out of range: { wavelength !r} \" ) cmd = \":SENS {slot:d} :POW:WAV {value:f} NM\" . format ( slot = self . _slot , value = wavelength ) self . command ( cmd ) def get_power_value ( self ) -> float : \"\"\"Fetch the value of measured optical power in current unit setting. The measured value includes the power calibration. Measured value (dBm) = the actual measured value (dBm) + power calibration (dB) Refer to `get_pow_cal` and `set_pow_cal` to operate with the power calibration. Returns: The value of the optical power. \"\"\" cmd = \":FETC {slot:d} :POW?\" . format ( slot = self . _slot ) power_value = float ( self . query ( cmd )) return power_value def get_power_unit ( self ) -> OpticalPowerUnit : \"\"\"Get optical power unit setting. Returns: The unit of the optical power. \"\"\" cmd = \":SENS {slot:d} :POW:UNIT?\" . format ( slot = self . _slot ) unit_int = int ( self . query ( cmd )) return OpticalPowerUnit ( unit_int ) def set_power_unit ( self , unit : OpticalPowerUnit ) -> None : \"\"\"Set the unit of optical power. Args: unit: The unit of the optical power. \"\"\" unit = OpticalPowerUnit ( unit ) cmd = \":SENS {slot:d} :POW:UNIT {unit:d} \" . format ( slot = self . _slot , unit = unit ) self . command ( cmd ) def get_pow_cal ( self ) -> float : \"\"\" Get the power calibration offset in dB. Note: The power calibration value defined here is opposite in sign with the instrument display value. This is to unify the definition of power calibration across different models of OPMs. Please refer to `get_power_value` for the math equation. Returns: The power calibration offset in dB. \"\"\" cmd = \":SENS {slot:d} :CORR?\" . format ( slot = self . _slot ) cal = - float ( self . query ( cmd )) return cal def set_pow_cal ( self , value : int | float ) -> None : \"\"\" Set the power calibration offset in dB. Args: value: The power calibration offset in dB. \"\"\" if not self . min_pow_cal <= value <= self . max_pow_cal : raise ValueError ( \"param value out of range: {value} \" . format ( value = value )) cmd = \":SENS {slot} :CORR {value} DB\" . format ( slot = self . _slot , value =- value ) self . command ( cmd ) def get_avg_time ( self ) -> float : \"\"\" Get the averaging time in ms. Returns: The averaging time in ms. \"\"\" cmd = \":SENS {slot:d} :POW:ATIM?\" . format ( slot = self . _slot ) avg_t = float ( self . query ( cmd )) * 10 ** 3 return avg_t def set_avg_time ( self , value : int | float ) -> None : \"\"\" Set the averaging time in ms. Args: value: The averaging time in ms. \"\"\" if not self . min_avg_time <= value <= self . max_avg_time : raise ValueError ( \"param value out of range: {value} \" . format ( value = value )) cmd = \":SENS {slot} :POW:ATIM {value} MS\" . format ( slot = self . _slot , value = value ) self . command ( cmd ) get_avg_time () \u00a4 Get the averaging time in ms. Returns: Type Description float The averaging time in ms. Source code in pyinst\\models.py 255 256 257 258 259 260 261 262 263 264 def get_avg_time ( self ) -> float : \"\"\" Get the averaging time in ms. Returns: The averaging time in ms. \"\"\" cmd = \":SENS {slot:d} :POW:ATIM?\" . format ( slot = self . _slot ) avg_t = float ( self . query ( cmd )) * 10 ** 3 return avg_t get_frequency () \u00a4 Queries the optical frequency setting of the instrument in THz. Returns: Type Description float The optical frequency setting value in THz. Source code in pyinst\\models.py 152 153 154 155 156 157 158 159 def get_frequency ( self ) -> float : \"\"\" Queries the optical frequency setting of the instrument in THz. Returns: The optical frequency setting value in THz. \"\"\" return super () . get_frequency () get_pow_cal () \u00a4 Get the power calibration offset in dB. Note The power calibration value defined here is opposite in sign with the instrument display value. This is to unify the definition of power calibration across different models of OPMs. Please refer to get_power_value for the math equation. Returns: Type Description float The power calibration offset in dB. Source code in pyinst\\models.py 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def get_pow_cal ( self ) -> float : \"\"\" Get the power calibration offset in dB. Note: The power calibration value defined here is opposite in sign with the instrument display value. This is to unify the definition of power calibration across different models of OPMs. Please refer to `get_power_value` for the math equation. Returns: The power calibration offset in dB. \"\"\" cmd = \":SENS {slot:d} :CORR?\" . format ( slot = self . _slot ) cal = - float ( self . query ( cmd )) return cal get_power_unit () \u00a4 Get optical power unit setting. Returns: Type Description OpticalPowerUnit The unit of the optical power. Source code in pyinst\\models.py 206 207 208 209 210 211 212 213 214 def get_power_unit ( self ) -> OpticalPowerUnit : \"\"\"Get optical power unit setting. Returns: The unit of the optical power. \"\"\" cmd = \":SENS {slot:d} :POW:UNIT?\" . format ( slot = self . _slot ) unit_int = int ( self . query ( cmd )) return OpticalPowerUnit ( unit_int ) get_power_value () \u00a4 Fetch the value of measured optical power in current unit setting. The measured value includes the power calibration. Measured value (dBm) = the actual measured value (dBm) + power calibration (dB) Refer to get_pow_cal and set_pow_cal to operate with the power calibration. Returns: Type Description float The value of the optical power. Source code in pyinst\\models.py 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def get_power_value ( self ) -> float : \"\"\"Fetch the value of measured optical power in current unit setting. The measured value includes the power calibration. Measured value (dBm) = the actual measured value (dBm) + power calibration (dB) Refer to `get_pow_cal` and `set_pow_cal` to operate with the power calibration. Returns: The value of the optical power. \"\"\" cmd = \":FETC {slot:d} :POW?\" . format ( slot = self . _slot ) power_value = float ( self . query ( cmd )) return power_value get_wavelength () \u00a4 Queries the optical wavelength setting of the instrument in nm. Returns: Type Description float The optical wavelength setting value in nm. Source code in pyinst\\models.py 169 170 171 172 173 174 175 176 177 def get_wavelength ( self ) -> float : \"\"\"Queries the optical wavelength setting of the instrument in nm. Returns: The optical wavelength setting value in nm. \"\"\" cmd = \":SENS {slot:d} :POW:WAV?\" . format ( slot = self . _slot ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl max_avg_time () property \u00a4 The maximum averaging time in ms. Source code in pyinst\\models.py 137 138 139 140 @property def max_avg_time ( self ) -> float : \"\"\"The maximum averaging time in ms.\"\"\" return 10000.0 # 10s max_frequency () property \u00a4 The maximum settable optical frequency value in THz. Source code in pyinst\\models.py 113 114 115 116 @property def max_frequency ( self ) -> float : \"\"\"The maximum settable optical frequency value in THz.\"\"\" return super () . max_frequency max_pow_cal () property \u00a4 The maximum power calibration value in dB. Source code in pyinst\\models.py 147 148 149 150 @property def max_pow_cal ( self ) -> float : \"\"\"The maximum power calibration value in dB.\"\"\" return 200.0 # dB max_wavelength () property \u00a4 The maximum settable optical wavelength value in nm. Source code in pyinst\\models.py 125 126 127 128 129 130 @property def max_wavelength ( self ) -> float : \"\"\"The maximum settable optical wavelength value in nm.\"\"\" cmd = \":SENS {slot:d} :POW:WAV? MAX\" . format ( slot = self . _slot ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl min_avg_time () property \u00a4 The minimum averaging time in ms. Source code in pyinst\\models.py 132 133 134 135 @property def min_avg_time ( self ) -> float : \"\"\"The minimum averaging time in ms.\"\"\" return 0.001 # 1us min_frequency () property \u00a4 The minimum settable optical frequency value in THz. Source code in pyinst\\models.py 108 109 110 111 @property def min_frequency ( self ) -> float : \"\"\"The minimum settable optical frequency value in THz.\"\"\" return super () . min_frequency min_pow_cal () property \u00a4 The minimum power calibration value in dB. Source code in pyinst\\models.py 142 143 144 145 @property def min_pow_cal ( self ) -> float : \"\"\"The minimum power calibration value in dB.\"\"\" return - 200.0 # dB min_wavelength () property \u00a4 The minimum settable optical wavelength value in nm. Source code in pyinst\\models.py 118 119 120 121 122 123 @property def min_wavelength ( self ) -> float : \"\"\"The minimum settable optical wavelength value in nm.\"\"\" cmd = \":SENS {slot:d} :POW:WAV? MIN\" . format ( slot = self . _slot ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl set_avg_time ( value ) \u00a4 Set the averaging time in ms. Parameters: Name Type Description Default value int | float The averaging time in ms. required Source code in pyinst\\models.py 266 267 268 269 270 271 272 273 274 275 276 def set_avg_time ( self , value : int | float ) -> None : \"\"\" Set the averaging time in ms. Args: value: The averaging time in ms. \"\"\" if not self . min_avg_time <= value <= self . max_avg_time : raise ValueError ( \"param value out of range: {value} \" . format ( value = value )) cmd = \":SENS {slot} :POW:ATIM {value} MS\" . format ( slot = self . _slot , value = value ) self . command ( cmd ) set_frequency ( frequency ) \u00a4 Set optical frequency. Parameters: Name Type Description Default frequency int | float The optical frequency setting in THz. required Source code in pyinst\\models.py 161 162 163 164 165 166 167 def set_frequency ( self , frequency : int | float ) -> None : \"\"\"Set optical frequency. Args: frequency: The optical frequency setting in THz. \"\"\" return super () . set_frequency ( frequency ) set_pow_cal ( value ) \u00a4 Set the power calibration offset in dB. Parameters: Name Type Description Default value int | float The power calibration offset in dB. required Source code in pyinst\\models.py 243 244 245 246 247 248 249 250 251 252 253 def set_pow_cal ( self , value : int | float ) -> None : \"\"\" Set the power calibration offset in dB. Args: value: The power calibration offset in dB. \"\"\" if not self . min_pow_cal <= value <= self . max_pow_cal : raise ValueError ( \"param value out of range: {value} \" . format ( value = value )) cmd = \":SENS {slot} :CORR {value} DB\" . format ( slot = self . _slot , value =- value ) self . command ( cmd ) set_power_unit ( unit ) \u00a4 Set the unit of optical power. Parameters: Name Type Description Default unit OpticalPowerUnit The unit of the optical power. required Source code in pyinst\\models.py 216 217 218 219 220 221 222 223 224 def set_power_unit ( self , unit : OpticalPowerUnit ) -> None : \"\"\"Set the unit of optical power. Args: unit: The unit of the optical power. \"\"\" unit = OpticalPowerUnit ( unit ) cmd = \":SENS {slot:d} :POW:UNIT {unit:d} \" . format ( slot = self . _slot , unit = unit ) self . command ( cmd ) set_wavelength ( wavelength ) \u00a4 Set optical wavelength. Parameters: Name Type Description Default wavelength int | float The optical wavelength setting in nm. required Source code in pyinst\\models.py 179 180 181 182 183 184 185 186 187 188 def set_wavelength ( self , wavelength : int | float ) -> None : \"\"\"Set optical wavelength. Args: wavelength: The optical wavelength setting in nm. \"\"\" if not self . min_wavelength <= wavelength <= self . max_wavelength : raise ValueError ( f \"Parameter wavelength is out of range: { wavelength !r} \" ) cmd = \":SENS {slot:d} :POW:WAV {value:f} NM\" . format ( slot = self . _slot , value = wavelength ) self . command ( cmd ) BaseModelN77xx_VOA_with_OPM \u00a4 Bases: BaseModelN77xx , TypeVOA , TypeOPM Source code in pyinst\\models.py 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 class BaseModelN77xx_VOA_with_OPM ( BaseModelN77xx , TypeVOA , TypeOPM ): @property def min_frequency ( self ) -> float : \"\"\"The minimum settable optical frequency value in THz.\"\"\" return super () . min_frequency @property def max_frequency ( self ) -> float : \"\"\"The maximum settable optical frequency value in THz.\"\"\" return super () . max_frequency @property def min_wavelength ( self ) -> float : \"\"\"The minimum settable optical wavelength value in nm.\"\"\" cmd = \":INPut {slot:d} :WAVelength? MIN\" . format ( slot = self . _slot ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl @property def max_wavelength ( self ) -> float : \"\"\"The maximum settable optical wavelength value in nm.\"\"\" cmd = \":INPut {slot:d} :WAVelength? MAX\" . format ( slot = self . _slot ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl @property def min_avg_time ( self ) -> float : \"\"\"The minimum averaging time in ms.\"\"\" return 2.0 @property def max_avg_time ( self ) -> float : \"\"\"The maximum averaging time in ms.\"\"\" return 10000.0 @property def min_pow_cal ( self ) -> float : \"\"\"The minimum power calibration value in dB.\"\"\" return - 200.0 @property def max_pow_cal ( self ) -> float : \"\"\"The maximum power calibration value in dB.\"\"\" return 200.0 @property def min_att ( self ) -> float : \"\"\"Minimum settable attenuation in dB. The minimum settable attenuation = 0 dB + the optical attenuation offset value. \"\"\" cmd = \":INP {slot:d} :ATT? MIN\" . format ( slot = self . _slot ) att = float ( self . query ( cmd )) return att @property def max_att ( self ) -> float : \"\"\"Maximum settable attenuation in dB. The maximum settable attenuation = The maximum attenuation + the optical attenuation offset value. \"\"\" cmd = \":INP {slot:d} :ATT? MAX\" . format ( slot = self . _slot ) att = float ( self . query ( cmd )) return att @property def min_att_offset ( self ) -> float : \"\"\"Minimum attenuation offset value in dB.\"\"\" cmd = \":INP {slot} :OFFS? MIN\" . format ( slot = self . _slot ) offset = float ( self . query ( cmd )) return offset @property def max_att_offset ( self ) -> float : \"\"\"Maximum attenuation offset value in dB.\"\"\" cmd = \":INP {slot} :OFFS? MAX\" . format ( slot = self . _slot ) offset = float ( self . query ( cmd )) return offset def get_frequency ( self ) -> float : \"\"\" Queries the optical frequency setting of the instrument in THz. Returns: The optical frequency setting value in THz. \"\"\" return super () . get_frequency () def set_frequency ( self , frequency : int | float ) -> None : \"\"\"Set optical frequency. Args: frequency: The optical frequency setting in THz. \"\"\" return super () . set_frequency ( frequency ) def get_wavelength ( self ) -> float : \"\"\"Queries the optical wavelength setting of the instrument in nm. Returns: The optical wavelength setting value in nm. \"\"\" cmd = \":INPut {slot:d} :WAVelength?\" . format ( slot = self . _slot ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl def set_wavelength ( self , wavelength : int | float ) -> None : \"\"\"Set optical wavelength. Args: wavelength: The optical wavelength setting in nm. \"\"\" if not self . min_wavelength <= wavelength <= self . max_wavelength : raise ValueError ( f \"Parameter wavelength is out of range: { wavelength } \" ) cmd = \":INPut {slot:d} :WAVelength {wl} NM\" . format ( slot = self . _slot , wl = wavelength ) self . command ( cmd ) def get_power_value ( self ) -> float : \"\"\"Fetch the value of measured optical power in current unit setting. The measured value includes the power calibration. Measured value (dBm) = the actual measured value (dBm) + power calibration (dB) Refer to `get_pow_cal` and `set_pow_cal` to operate with the power calibration. Returns: The value of the optical power. \"\"\" cmd = \":FETC {slot:d} :POW?\" . format ( slot = self . _slot ) power_value = float ( self . query ( cmd )) return power_value def get_power_unit ( self ) -> OpticalPowerUnit : \"\"\"Get optical power unit setting. Returns: The unit of the optical power. \"\"\" cmd = \":OUTPut {slot:d} :POWer:UNit?\" . format ( slot = self . _slot ) unit_int = int ( self . query ( cmd )) return OpticalPowerUnit ( unit_int ) def set_power_unit ( self , unit : OpticalPowerUnit ) -> None : \"\"\"Set the unit of optical power. Args: unit: The unit of the optical power. \"\"\" unit = OpticalPowerUnit ( unit ) cmd = \":OUTPut {slot:d} :POWer:UNit {unit:d} \" . format ( slot = self . _slot , unit = unit ) self . command ( cmd ) def get_pow_cal ( self ) -> float : \"\"\" Get the power calibration offset in dB. Note: The power calibration value defined here is opposite in sign with the instrument display value. This is to unify the definition of power calibration across different models of OPMs. Please refer to `get_power_value` for the math equation. Returns: The power calibration offset in dB. \"\"\" cmd = \":OUTPut {slot:d} :POWer:OFFSet?\" . format ( slot = self . _slot ) cal = - float ( self . query ( cmd )) return cal def set_pow_cal ( self , value : int | float ) -> None : \"\"\" Set the power calibration offset in dB. Args: value: The power calibration offset in dB. \"\"\" if not self . min_pow_cal <= value <= self . max_pow_cal : raise ValueError ( f \"Parameter value is out of range: { value !r} \" ) cmd = \":OUTPut {slot:d} :POWer:OFFSet {value} DB\" . format ( slot = self . _slot , value =- value ) # opposite sign self . command ( cmd ) def get_avg_time ( self ) -> float : \"\"\" Get the averaging time in ms. Returns: The averaging time in ms. \"\"\" cmd = \":OUTPut {slot:d} :ATIMe?\" . format ( slot = self . _slot ) atime = float ( self . query ( cmd )) * 10 ** 3 return atime def set_avg_time ( self , value : int | float ) -> None : \"\"\" Set the averaging time in ms. Args: value: The averaging time in ms. \"\"\" if not self . min_avg_time <= value <= self . max_avg_time : raise ValueError ( f \"Parameter value is out of range: { value !r} \" ) cmd = \":OUTPut {slot:d} :ATIMe {value} MS\" . format ( slot = self . _slot , value = value ) self . command ( cmd ) def enable ( self , en : bool = True ) -> None : \"\"\" Enable (disable) the optical output. Args: en: True = Enable, False = Disable. \"\"\" if not isinstance ( en , bool ): raise TypeError ( f \"Parameter en must be a bool, not ' { type ( en ) . __name__ } '.\" ) cmd = \":OUTP {slot:d} {status:d} \" . format ( slot = self . _slot , status = en ) self . command ( cmd ) def disable ( self ) -> None : \"\"\"Disable the optical output.\"\"\" self . enable ( False ) def is_enabled ( self ) -> bool : \"\"\" Returns: Whether the optical output is enabled. \"\"\" cmd = \":OUTP {slot:d} ?\" . format ( slot = self . _slot ) status = bool ( int ( self . query ( cmd ))) return status def get_att ( self ) -> float : \"\"\" Get the current attenuation value in dB. Includes the attenuation offset. Queried attenuator = the actual attenuator value + attenuator offset Use `get_att_offset` and `set_att_offset` to operate with the attenuator offset. Returns: The attenuation value in dB. \"\"\" cmd = \":INP {slot:d} :ATT?\" . format ( slot = self . _slot ) att = float ( self . query ( cmd )) return att def set_att ( self , att : int | float ) -> None : \"\"\" Set attenuation value in dB. Includes the attenuation offset. Refer to `get_att` for more information. Args: att: The attenuation value in dB. \"\"\" if not self . min_att <= att <= self . max_att : raise ValueError ( f 'Parameter att is out of range: { att !r} ' ) cmd = \":INP {slot:d} :ATT {value:.3f} DB\" . format ( slot = self . _slot , value = att ) self . command ( cmd ) def get_att_offset ( self ) -> float : \"\"\" Get the attenuation offset value in dB. Returns: The attenuation offset in dB. \"\"\" cmd = \":INP {slot:d} :OFFS?\" . format ( slot = self . _slot ) offset = float ( self . query ( cmd )) return offset def set_att_offset ( self , offset : int | float ) -> None : \"\"\" Set the attenuation offset value in dB. Args: offset: The attenuation offset in dB. \"\"\" if not self . min_att_offset <= offset <= self . max_att_offset : raise ValueError ( f \"Parameter offset is out of range: { offset !r} \" ) self . command ( \":INP {slot:d} :OFFS {value:.3f} DB\" . format ( slot = self . _slot , value = offset )) disable () \u00a4 Disable the optical output. Source code in pyinst\\models.py 499 500 501 def disable ( self ) -> None : \"\"\"Disable the optical output.\"\"\" self . enable ( False ) enable ( en = True ) \u00a4 Enable (disable) the optical output. Parameters: Name Type Description Default en bool True = Enable, False = Disable. True Source code in pyinst\\models.py 487 488 489 490 491 492 493 494 495 496 497 def enable ( self , en : bool = True ) -> None : \"\"\" Enable (disable) the optical output. Args: en: True = Enable, False = Disable. \"\"\" if not isinstance ( en , bool ): raise TypeError ( f \"Parameter en must be a bool, not ' { type ( en ) . __name__ } '.\" ) cmd = \":OUTP {slot:d} {status:d} \" . format ( slot = self . _slot , status = en ) self . command ( cmd ) get_att () \u00a4 Get the current attenuation value in dB. Includes the attenuation offset. Queried attenuator = the actual attenuator value + attenuator offset Use get_att_offset and set_att_offset to operate with the attenuator offset. Returns: Type Description float The attenuation value in dB. Source code in pyinst\\models.py 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 def get_att ( self ) -> float : \"\"\" Get the current attenuation value in dB. Includes the attenuation offset. Queried attenuator = the actual attenuator value + attenuator offset Use `get_att_offset` and `set_att_offset` to operate with the attenuator offset. Returns: The attenuation value in dB. \"\"\" cmd = \":INP {slot:d} :ATT?\" . format ( slot = self . _slot ) att = float ( self . query ( cmd )) return att get_att_offset () \u00a4 Get the attenuation offset value in dB. Returns: Type Description float The attenuation offset in dB. Source code in pyinst\\models.py 545 546 547 548 549 550 551 552 553 554 def get_att_offset ( self ) -> float : \"\"\" Get the attenuation offset value in dB. Returns: The attenuation offset in dB. \"\"\" cmd = \":INP {slot:d} :OFFS?\" . format ( slot = self . _slot ) offset = float ( self . query ( cmd )) return offset get_avg_time () \u00a4 Get the averaging time in ms. Returns: Type Description float The averaging time in ms. Source code in pyinst\\models.py 464 465 466 467 468 469 470 471 472 473 def get_avg_time ( self ) -> float : \"\"\" Get the averaging time in ms. Returns: The averaging time in ms. \"\"\" cmd = \":OUTPut {slot:d} :ATIMe?\" . format ( slot = self . _slot ) atime = float ( self . query ( cmd )) * 10 ** 3 return atime get_frequency () \u00a4 Queries the optical frequency setting of the instrument in THz. Returns: Type Description float The optical frequency setting value in THz. Source code in pyinst\\models.py 361 362 363 364 365 366 367 368 def get_frequency ( self ) -> float : \"\"\" Queries the optical frequency setting of the instrument in THz. Returns: The optical frequency setting value in THz. \"\"\" return super () . get_frequency () get_pow_cal () \u00a4 Get the power calibration offset in dB. Note The power calibration value defined here is opposite in sign with the instrument display value. This is to unify the definition of power calibration across different models of OPMs. Please refer to get_power_value for the math equation. Returns: Type Description float The power calibration offset in dB. Source code in pyinst\\models.py 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 def get_pow_cal ( self ) -> float : \"\"\" Get the power calibration offset in dB. Note: The power calibration value defined here is opposite in sign with the instrument display value. This is to unify the definition of power calibration across different models of OPMs. Please refer to `get_power_value` for the math equation. Returns: The power calibration offset in dB. \"\"\" cmd = \":OUTPut {slot:d} :POWer:OFFSet?\" . format ( slot = self . _slot ) cal = - float ( self . query ( cmd )) return cal get_power_unit () \u00a4 Get optical power unit setting. Returns: Type Description OpticalPowerUnit The unit of the optical power. Source code in pyinst\\models.py 415 416 417 418 419 420 421 422 423 def get_power_unit ( self ) -> OpticalPowerUnit : \"\"\"Get optical power unit setting. Returns: The unit of the optical power. \"\"\" cmd = \":OUTPut {slot:d} :POWer:UNit?\" . format ( slot = self . _slot ) unit_int = int ( self . query ( cmd )) return OpticalPowerUnit ( unit_int ) get_power_value () \u00a4 Fetch the value of measured optical power in current unit setting. The measured value includes the power calibration. Measured value (dBm) = the actual measured value (dBm) + power calibration (dB) Refer to get_pow_cal and set_pow_cal to operate with the power calibration. Returns: Type Description float The value of the optical power. Source code in pyinst\\models.py 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 def get_power_value ( self ) -> float : \"\"\"Fetch the value of measured optical power in current unit setting. The measured value includes the power calibration. Measured value (dBm) = the actual measured value (dBm) + power calibration (dB) Refer to `get_pow_cal` and `set_pow_cal` to operate with the power calibration. Returns: The value of the optical power. \"\"\" cmd = \":FETC {slot:d} :POW?\" . format ( slot = self . _slot ) power_value = float ( self . query ( cmd )) return power_value get_wavelength () \u00a4 Queries the optical wavelength setting of the instrument in nm. Returns: Type Description float The optical wavelength setting value in nm. Source code in pyinst\\models.py 378 379 380 381 382 383 384 385 386 def get_wavelength ( self ) -> float : \"\"\"Queries the optical wavelength setting of the instrument in nm. Returns: The optical wavelength setting value in nm. \"\"\" cmd = \":INPut {slot:d} :WAVelength?\" . format ( slot = self . _slot ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl is_enabled () \u00a4 Returns: Type Description bool Whether the optical output is enabled. Source code in pyinst\\models.py 503 504 505 506 507 508 509 510 def is_enabled ( self ) -> bool : \"\"\" Returns: Whether the optical output is enabled. \"\"\" cmd = \":OUTP {slot:d} ?\" . format ( slot = self . _slot ) status = bool ( int ( self . query ( cmd ))) return status max_att () property \u00a4 Maximum settable attenuation in dB. The maximum settable attenuation = The maximum attenuation + the optical attenuation offset value. Source code in pyinst\\models.py 336 337 338 339 340 341 342 343 344 345 @property def max_att ( self ) -> float : \"\"\"Maximum settable attenuation in dB. The maximum settable attenuation = The maximum attenuation + the optical attenuation offset value. \"\"\" cmd = \":INP {slot:d} :ATT? MAX\" . format ( slot = self . _slot ) att = float ( self . query ( cmd )) return att max_att_offset () property \u00a4 Maximum attenuation offset value in dB. Source code in pyinst\\models.py 354 355 356 357 358 359 @property def max_att_offset ( self ) -> float : \"\"\"Maximum attenuation offset value in dB.\"\"\" cmd = \":INP {slot} :OFFS? MAX\" . format ( slot = self . _slot ) offset = float ( self . query ( cmd )) return offset max_avg_time () property \u00a4 The maximum averaging time in ms. Source code in pyinst\\models.py 310 311 312 313 @property def max_avg_time ( self ) -> float : \"\"\"The maximum averaging time in ms.\"\"\" return 10000.0 max_frequency () property \u00a4 The maximum settable optical frequency value in THz. Source code in pyinst\\models.py 286 287 288 289 @property def max_frequency ( self ) -> float : \"\"\"The maximum settable optical frequency value in THz.\"\"\" return super () . max_frequency max_pow_cal () property \u00a4 The maximum power calibration value in dB. Source code in pyinst\\models.py 320 321 322 323 @property def max_pow_cal ( self ) -> float : \"\"\"The maximum power calibration value in dB.\"\"\" return 200.0 max_wavelength () property \u00a4 The maximum settable optical wavelength value in nm. Source code in pyinst\\models.py 298 299 300 301 302 303 @property def max_wavelength ( self ) -> float : \"\"\"The maximum settable optical wavelength value in nm.\"\"\" cmd = \":INPut {slot:d} :WAVelength? MAX\" . format ( slot = self . _slot ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl min_att () property \u00a4 Minimum settable attenuation in dB. The minimum settable attenuation = 0 dB + the optical attenuation offset value. Source code in pyinst\\models.py 325 326 327 328 329 330 331 332 333 334 @property def min_att ( self ) -> float : \"\"\"Minimum settable attenuation in dB. The minimum settable attenuation = 0 dB + the optical attenuation offset value. \"\"\" cmd = \":INP {slot:d} :ATT? MIN\" . format ( slot = self . _slot ) att = float ( self . query ( cmd )) return att min_att_offset () property \u00a4 Minimum attenuation offset value in dB. Source code in pyinst\\models.py 347 348 349 350 351 352 @property def min_att_offset ( self ) -> float : \"\"\"Minimum attenuation offset value in dB.\"\"\" cmd = \":INP {slot} :OFFS? MIN\" . format ( slot = self . _slot ) offset = float ( self . query ( cmd )) return offset min_avg_time () property \u00a4 The minimum averaging time in ms. Source code in pyinst\\models.py 305 306 307 308 @property def min_avg_time ( self ) -> float : \"\"\"The minimum averaging time in ms.\"\"\" return 2.0 min_frequency () property \u00a4 The minimum settable optical frequency value in THz. Source code in pyinst\\models.py 281 282 283 284 @property def min_frequency ( self ) -> float : \"\"\"The minimum settable optical frequency value in THz.\"\"\" return super () . min_frequency min_pow_cal () property \u00a4 The minimum power calibration value in dB. Source code in pyinst\\models.py 315 316 317 318 @property def min_pow_cal ( self ) -> float : \"\"\"The minimum power calibration value in dB.\"\"\" return - 200.0 min_wavelength () property \u00a4 The minimum settable optical wavelength value in nm. Source code in pyinst\\models.py 291 292 293 294 295 296 @property def min_wavelength ( self ) -> float : \"\"\"The minimum settable optical wavelength value in nm.\"\"\" cmd = \":INPut {slot:d} :WAVelength? MIN\" . format ( slot = self . _slot ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl set_att ( att ) \u00a4 Set attenuation value in dB. Includes the attenuation offset. Refer to get_att for more information. Parameters: Name Type Description Default att int | float The attenuation value in dB. required Source code in pyinst\\models.py 530 531 532 533 534 535 536 537 538 539 540 541 542 543 def set_att ( self , att : int | float ) -> None : \"\"\" Set attenuation value in dB. Includes the attenuation offset. Refer to `get_att` for more information. Args: att: The attenuation value in dB. \"\"\" if not self . min_att <= att <= self . max_att : raise ValueError ( f 'Parameter att is out of range: { att !r} ' ) cmd = \":INP {slot:d} :ATT {value:.3f} DB\" . format ( slot = self . _slot , value = att ) self . command ( cmd ) set_att_offset ( offset ) \u00a4 Set the attenuation offset value in dB. Parameters: Name Type Description Default offset int | float The attenuation offset in dB. required Source code in pyinst\\models.py 556 557 558 559 560 561 562 563 564 565 def set_att_offset ( self , offset : int | float ) -> None : \"\"\" Set the attenuation offset value in dB. Args: offset: The attenuation offset in dB. \"\"\" if not self . min_att_offset <= offset <= self . max_att_offset : raise ValueError ( f \"Parameter offset is out of range: { offset !r} \" ) self . command ( \":INP {slot:d} :OFFS {value:.3f} DB\" . format ( slot = self . _slot , value = offset )) set_avg_time ( value ) \u00a4 Set the averaging time in ms. Parameters: Name Type Description Default value int | float The averaging time in ms. required Source code in pyinst\\models.py 475 476 477 478 479 480 481 482 483 484 485 def set_avg_time ( self , value : int | float ) -> None : \"\"\" Set the averaging time in ms. Args: value: The averaging time in ms. \"\"\" if not self . min_avg_time <= value <= self . max_avg_time : raise ValueError ( f \"Parameter value is out of range: { value !r} \" ) cmd = \":OUTPut {slot:d} :ATIMe {value} MS\" . format ( slot = self . _slot , value = value ) self . command ( cmd ) set_frequency ( frequency ) \u00a4 Set optical frequency. Parameters: Name Type Description Default frequency int | float The optical frequency setting in THz. required Source code in pyinst\\models.py 370 371 372 373 374 375 376 def set_frequency ( self , frequency : int | float ) -> None : \"\"\"Set optical frequency. Args: frequency: The optical frequency setting in THz. \"\"\" return super () . set_frequency ( frequency ) set_pow_cal ( value ) \u00a4 Set the power calibration offset in dB. Parameters: Name Type Description Default value int | float The power calibration offset in dB. required Source code in pyinst\\models.py 452 453 454 455 456 457 458 459 460 461 462 def set_pow_cal ( self , value : int | float ) -> None : \"\"\" Set the power calibration offset in dB. Args: value: The power calibration offset in dB. \"\"\" if not self . min_pow_cal <= value <= self . max_pow_cal : raise ValueError ( f \"Parameter value is out of range: { value !r} \" ) cmd = \":OUTPut {slot:d} :POWer:OFFSet {value} DB\" . format ( slot = self . _slot , value =- value ) # opposite sign self . command ( cmd ) set_power_unit ( unit ) \u00a4 Set the unit of optical power. Parameters: Name Type Description Default unit OpticalPowerUnit The unit of the optical power. required Source code in pyinst\\models.py 425 426 427 428 429 430 431 432 433 def set_power_unit ( self , unit : OpticalPowerUnit ) -> None : \"\"\"Set the unit of optical power. Args: unit: The unit of the optical power. \"\"\" unit = OpticalPowerUnit ( unit ) cmd = \":OUTPut {slot:d} :POWer:UNit {unit:d} \" . format ( slot = self . _slot , unit = unit ) self . command ( cmd ) set_wavelength ( wavelength ) \u00a4 Set optical wavelength. Parameters: Name Type Description Default wavelength int | float The optical wavelength setting in nm. required Source code in pyinst\\models.py 388 389 390 391 392 393 394 395 396 397 def set_wavelength ( self , wavelength : int | float ) -> None : \"\"\"Set optical wavelength. Args: wavelength: The optical wavelength setting in nm. \"\"\" if not self . min_wavelength <= wavelength <= self . max_wavelength : raise ValueError ( f \"Parameter wavelength is out of range: { wavelength } \" ) cmd = \":INPut {slot:d} :WAVelength {wl} NM\" . format ( slot = self . _slot , wl = wavelength ) self . command ( cmd ) BaseModelSantecBandwidthTunableFilter \u00a4 Bases: VisaInstrument , TypeOTF Source code in pyinst\\models.py 4018 4019 4020 4021 4022 4023 4024 4025 4026 4027 4028 4029 4030 4031 4032 4033 4034 4035 4036 4037 4038 4039 4040 4041 4042 4043 4044 4045 4046 4047 4048 4049 4050 4051 4052 4053 4054 4055 4056 4057 4058 4059 4060 4061 4062 4063 4064 4065 4066 4067 4068 4069 4070 4071 4072 4073 4074 4075 4076 4077 4078 4079 4080 4081 4082 4083 4084 4085 4086 4087 4088 4089 4090 4091 4092 4093 4094 4095 4096 4097 4098 4099 4100 4101 4102 4103 4104 4105 4106 4107 4108 4109 4110 4111 4112 4113 4114 class BaseModelSantecBandwidthTunableFilter ( VisaInstrument , TypeOTF ): def __init__ ( self , resource_name : str , read_termination : str = ' \\r\\n ' , write_termination : str = ' \\r\\n ' , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. read_termination: Read termination character. write_termination: Write termination character. \"\"\" super () . __init__ ( resource_name , read_termination = read_termination , write_termination = write_termination , ** kwargs ) @property def min_frequency ( self ) -> float : cmd = ':FREQuency? MIN' freq = float ( self . query ( cmd )) / 10 ** 12 return freq @property def max_frequency ( self ) -> float : cmd = ':FREQuency? MAX' freq = float ( self . query ( cmd )) / 10 ** 12 return freq @property def min_wavelength ( self ) -> float : cmd = ':WAVelength? MIN' wl = float ( self . query ( cmd )) * 10 ** 9 return wl @property def max_wavelength ( self ) -> float : cmd = ':WAVelength? MAX' wl = float ( self . query ( cmd )) * 10 ** 9 return wl @property def min_bandwidth_in_nm ( self ) -> float : cmd = ':BANDwidth? MIN' bw = float ( self . query ( cmd )) * 10 ** 9 return bw @property def max_bandwidth_in_nm ( self ) -> float : cmd = ':BANDwidth? MAX' bw = float ( self . query ( cmd )) * 10 ** 9 return bw @property def min_bandwidth_in_ghz ( self ) -> float : return super () . min_bandwidth_in_ghz @property def max_bandwidth_in_ghz ( self ) -> float : return super () . max_bandwidth_in_ghz def get_wavelength ( self ) -> float : cmd = ':WAVelength?' wl = float ( self . query ( cmd )) * 10 ** 9 return wl def set_wavelength ( self , wavelength : int | float ) -> None : if not self . min_wavelength <= wavelength <= self . max_wavelength : raise ValueError ( 'Parameter wavelength out of range: {wl!r} ' . format ( wl = wavelength )) cmd = ':WAVelength {wl:.3f} nm' . format ( wl = wavelength ) self . command ( cmd ) def get_frequency ( self ) -> float : cmd = ':FREQuency?' freq = float ( self . query ( cmd )) / 10 ** 12 return freq def set_frequency ( self , frequency : int | float ) -> None : if not self . min_frequency <= frequency <= self . max_frequency : raise ValueError ( 'Parameter frequency out of range: {freq!r} ' . format ( freq = frequency )) cmd = ':FREQuency {freq:.5f} THz' . format ( freq = frequency ) self . command ( cmd ) def get_bandwidth_in_nm ( self ) -> float : cmd = ':BANDwidth?' bw = float ( self . query ( cmd )) * 10 ** 9 return bw def set_bandwidth_in_nm ( self , value : int | float ) -> None : if not self . min_bandwidth_in_nm <= value <= self . max_bandwidth_in_nm : raise ValueError ( 'Parameter value out of range: {val!r} ' . format ( val = value )) cmd = ':BANDwidth {value:.3f} nm' . format ( value ) self . command ( cmd ) def get_bandwidth_in_ghz ( self ) -> float : return super () . get_bandwidth_in_ghz () def set_bandwidth_in_ghz ( self , value : int | float ) -> None : return super () . set_bandwidth_in_ghz ( value ) __init__ ( resource_name , read_termination = ' \\r\\n ' , write_termination = ' \\r\\n ' , ** kwargs ) \u00a4 Parameters: Name Type Description Default resource_name str Resource name or alias of the VISA resource to open. required read_termination str Read termination character. '\\r\\n' write_termination str Write termination character. '\\r\\n' Source code in pyinst\\models.py 4020 4021 4022 4023 4024 4025 4026 4027 4028 4029 4030 4031 def __init__ ( self , resource_name : str , read_termination : str = ' \\r\\n ' , write_termination : str = ' \\r\\n ' , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. read_termination: Read termination character. write_termination: Write termination character. \"\"\" super () . __init__ ( resource_name , read_termination = read_termination , write_termination = write_termination , ** kwargs ) BaseModelVSA89600 \u00a4 Bases: VisaInstrument Base class of instrument models based on Keysight 89600 VSA software. Source code in pyinst\\models.py 1858 1859 1860 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 2167 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 class BaseModelVSA89600 ( VisaInstrument ): \"\"\" Base class of instrument models based on Keysight 89600 VSA software. \"\"\" def __init__ ( self , resource_name , encoding = 'latin1' , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. encoding: Encoding of VISA IO string. Default to `\"latin1\"` since there are some particular caractors. kwargs: directly passed to `VisaInstrument.__init__`. \"\"\" super ( BaseModelVSA89600 , self ) . __init__ ( resource_name , encoding = encoding , ** kwargs ) self . __custom_measurement_demod_filters = { \"None\" , \"Rectangular\" , \"RootRaisedCosine\" , \"Gaussian\" , \"LowPass\" } self . __custom_reference_demod_filters = { \"Rectangular\" , \"RaisedCosine\" , \"RootRaisedCosine\" , \"Gaussian\" , \"HalfSine\" } @property def CUSTOM_DEMOD_MEASUREMENT_FILTERS ( self ) -> set : \"\"\"Options for measurement filter types. Refer to `get_custom_demod_measurement_filter` and `set_custom_demod_measurement_filter`. \"\"\" return self . __custom_measurement_demod_filters @property def CUSTOM_DEMOD_REFERENCE_FILTERS ( self ) -> set : \"\"\"Options for reference filter types. Refer to `get_custom_demod_reference_filter` and `set_custom_demod_reference_filter`. \"\"\" return self . __custom_reference_demod_filters # Methods def run ( self , state : bool = True ) -> None : \"\"\"Resume or stop the measurement. - state == True: Causes the measurement to transition to the Running state. - state == False: Immediately stops the measurement, clearing all measurement data. \"\"\" if state : self . command ( \":INITiate:RESume\" ) else : self . command ( \":INITiate:ABORt\" ) def stop ( self ) -> None : \"\"\"Immediately stops the measurement, clearing all measurement data.\"\"\" self . run ( state = False ) def pause ( self ) -> None : \"\"\"Causes the measurement to transition to the Paused state.\"\"\" self . command ( \":INITiate:PAUSe\" ) def restart ( self ) -> None : \"\"\"Causes the measurement to restart. The Average count is reset to 0 and the measurement transitions to the Running State. \"\"\" self . command ( \":INITiate:RESTart\" ) def get_data_table_names ( self , trace : int ) -> List [ str ]: \"\"\" Returns a list of all names in the data table for the specified trace. Args: trace: index of trace, 1 based from A. For example, A->1, E->5 Returns: a list of all names in the data table. \"\"\" if not isinstance ( trace , int ): raise TypeError ( 'param trace should be int' ) if not trace >= 1 : raise ValueError ( 'param trace starts from 1' ) name_str = self . query ( \":TRACe {trace:d} :DATA:TABLe:NAME?\" . format ( trace = trace )) name_list = list ( map ( lambda x : x . strip ( '\"' ), name_str . split ( \",\" ))) return name_list def get_data_table_values ( self , trace : int ) -> List [ int | float | str ]: \"\"\"Gets a list of values from a data table. Enum values are returned as enum indexes. Args: trace: index of trace, 1 based from A. For example, A->1, E->5 Returns: a list of values from a data table. \"\"\" if not isinstance ( trace , int ): raise TypeError ( 'param trace should be int' ) if not trace >= 1 : raise ValueError ( 'param trace starts from 1' ) value_str = self . query ( \":TRACe {trace:d} :DATA:TABLe?\" . format ( trace = trace )) raw_values = value_str . split ( \",\" ) values = [] for r_val in raw_values : try : val = int ( r_val ) except ValueError : try : val = float ( r_val ) except : val = r_val values . append ( val ) return values def get_data_table_units ( self , trace : int ) -> List [ str ]: \"\"\" Get all the units of the specified trace. Args: trace: index of trace, 1 based from A. For example, A->1, E->5 Returns: list of trace item units. \"\"\" if not isinstance ( trace , int ): raise TypeError ( 'param trace should be int.' ) if not trace >= 1 : raise ValueError ( 'param trace starts from 1' ) unit_str = self . query ( ':TRACe {trace:d} :DATA:TABLe:UNIT?' . format ( trace = trace )) unit_list = list ( map ( lambda x : x . strip ( '\"' ), unit_str . split ( \",\" ))) return unit_list def get_data_table ( self , trace : int ) -> dict : \"\"\" Get formatted data including table item names, values, and units. Args: trace: index of trace, 1 based from A. For example, A->1, E->5 Returns: Mapping[name => (value, unit)] \"\"\" names = self . get_data_table_names ( trace ) values = self . get_data_table_values ( trace ) units = self . get_data_table_units ( trace ) if len ( names ) == len ( values ) == len ( units ): i_len = len ( names ) else : raise IndexError ( 'Numbers of names, values and units do not match.' ) data = {} for i in range ( i_len ): data [ names [ i ]] = ( values [ i ], units [ i ]) return data def get_custom_demod_measurement_filter ( self ) -> str : \"\"\"Gets the measurement filter applied during the digital demodulation measurement. Returns: `\"None\"` | `\"Rectangular\"` | `\"RootRaisedCosine\"` | `\"Gaussian\"` | `\"LowPass\"` \"\"\" cmd = \":CDEMod:FILTer?\" filter_type = self . query ( cmd ) . strip () . strip ( '\"' ) return filter_type def set_custom_demod_measurement_filter ( self , filter_type : str ) -> None : \"\"\"Sets the measurement filter applied during the digital demodulation measurement. Args: filter_type: `\"None\"` | `\"Rectangular\"` | `\"RootRaisedCosine\"` | `\"Gaussian\"` | `\"LowPass\"` \"\"\" if filter_type not in self . CUSTOM_DEMOD_MEASUREMENT_FILTERS : raise ValueError ( 'Invalid filter_type value: {filter!r} ' . format ( filter = filter_type )) cmd = \":CDEMod:FILTer \\\" {filter} \\\" \" . format ( filter = filter_type ) self . command ( cmd ) def get_custom_demod_reference_filter ( self ) -> str : \"\"\"Gets the reference filter applied during the digital demodulation measurement. Returns: `\"Rectangular\"` | `\"RaisedCosine\"` | `\"RootRaisedCosine\"` | `\"Gaussian\"` | `\"HalfSine\"` \"\"\" cmd = ':CDEMod:FILTer:REFerence?' filter_type = self . query ( cmd ) . strip () . strip ( '\"' ) return filter_type def set_custom_demod_reference_filter ( self , filter_type : str ) -> None : \"\"\"Sets the reference filter applied during the digital demodulation measurement. Args: filter_type: `\"Rectangular\"` | `\"RaisedCosine\"` | `\"RootRaisedCosine\"` | `\"Gaussian\"` | `\"HalfSine\"` \"\"\" if filter_type not in self . CUSTOM_DEMOD_REFERENCE_FILTERS : raise ValueError ( 'Invalid filter_type value: {filter!r} ' . format ( filter = filter_type )) cmd = \":CDEMod:FILTer:REFerence \\\" {filter} \\\" \" . format ( filter = filter_type ) self . command ( cmd ) def get_custom_demod_filter_abt ( self ) -> float : \"\"\" Gets the \u03b1 (alpha) or BT (bandwidth time product) parameter for measurement and reference filters. \"\"\" cmd = ':CDEMod:FILTer:ABT?' abt = float ( self . query ( cmd )) return abt def set_custom_demod_filter_abt ( self , abt : int | float ) -> None : \"\"\" Sets the \u03b1 (alpha) or BT (bandwidth time product) parameter for measurement and reference filters. Args: abt: alpha or BT value. \"\"\" cmd = ':CDEMod:FILTer:ABT {value:f} ' . format ( value = round ( abt , 6 )) self . command ( cmd ) def get_custom_demod_equalization_state ( self ) -> bool : \"\"\" Gets a value indicating whether the equalization filter is enabled. \"\"\" cmd = ':CDEMod:COMPensate:EQUalize?' state = bool ( int ( self . query ( cmd ))) return state def set_custom_demod_equalization_state ( self , enable : bool ) -> None : \"\"\" Sets a value indicating whether the equalization filter is enabled. Args: enable: True = enabled, False = disabled. \"\"\" if not isinstance ( enable , bool ): raise TypeError ( 'parameter enable should be bool.' ) cmd = ':CDEMod:COMPensate:EQUalize {state:d} ' . format ( state = enable ) self . command ( cmd ) def get_custom_demod_equalization_length ( self ) -> int : \"\"\"Gets the length of the equalization filter, in symbols. Returns: length of the equalization fileter in symbols. \"\"\" cmd = ':CDEMod:COMPensate:EQUalize:LENGth?' rpl = self . query ( cmd ) return int ( rpl ) def set_custom_demod_equalization_length ( self , symbols : int ) -> None : \"\"\"Sets the length of the equalization filter, in symbols. Args: symbols: length of the equalization fileter in symbols. \"\"\" if not symbols >= 3 : raise ValueError ( 'param symbols should >= 3: {symbols} ' . format ( symbols = symbols )) cmd = ':CDEMod:COMPensate:EQUalize:LENGth {value:d} ' . format ( value = symbols ) self . command ( cmd ) def get_custom_demod_equalization_convergence ( self ) -> float : \"\"\"Gets the convergence parameter for the Adaptive Equalizer. Returns: the convergence parameter \"\"\" cmd = \":CDEMod:COMPensate:EQUalize:CONVergence?\" param = float ( self . query ( cmd )) return param def set_custom_demod_equalization_convergence ( self , value : int | float ) -> None : \"\"\"Sets the convergence parameter for the Adaptive Equalizer. Args: value: the convergence parameter value \"\"\" if not 1E-8 <= value <= 1e-6 : raise ValueError ( 'Invalid value of EQ convergence: should between 1E-6 and 1E-8.' ) cmd = ':CDEMod:COMPensate:EQUalize:CONVergence {value:.4E} ' . format ( value = value ) self . command ( cmd ) def get_custom_demod_equalizer_run_mode ( self ) -> str : \"\"\" Gets the run mode of the Adaptive Equalizer. Returns: run mode: `\"Run\"` | `\"Hold\"` \"\"\" cmd = ':CDEMod:COMPensate:EQUalize:MODE?' mode = self . query ( cmd ) . strip () . strip ( '\"' ) return mode def set_custom_demod_equalizer_run_mode ( self , mode : str ) -> None : \"\"\" Sets the run mode of the Adaptive Equalizer. Args: mode: `\"Run\"` | `\"Hold\"` \"\"\" MODES = { \"Run\" , \"Hold\" } if mode not in MODES : raise ValueError ( 'Invalid value for Custom Demod EQ run mode: {vlaue!r} ' . format ( mode )) cmd = ':CDEMod:COMPensate:EQUalize:MODE {value} ' . format ( value = mode ) self . command ( cmd ) def reset_custom_demod_equalizer ( self ) -> None : \"\"\"Reset the equalizer filter\"\"\" cmd = ':CDEMod:COMPensate:EQUalize:RESet' self . command ( cmd ) def get_custom_demod_result_length ( self ) -> int : \"\"\"Gets the demodulation measurement result length (in symbols). Returns: result length in symbols \"\"\" cmd = ':CDEMod:RLENgth?' l = int ( self . query ( cmd )) return l def set_custom_demod_result_length ( self , length : int ) -> None : \"\"\"Gets the demodulation measurement result length (in symbols). Args: length: result length in symbols \"\"\" cmd = ':CDEMod:RLENgth {v:d} ' . format ( v = length ) self . command ( cmd ) CUSTOM_DEMOD_MEASUREMENT_FILTERS () property \u00a4 Options for measurement filter types. Refer to get_custom_demod_measurement_filter and set_custom_demod_measurement_filter . Source code in pyinst\\models.py 1874 1875 1876 1877 1878 1879 1880 1881 @property def CUSTOM_DEMOD_MEASUREMENT_FILTERS ( self ) -> set : \"\"\"Options for measurement filter types. Refer to `get_custom_demod_measurement_filter` and `set_custom_demod_measurement_filter`. \"\"\" return self . __custom_measurement_demod_filters CUSTOM_DEMOD_REFERENCE_FILTERS () property \u00a4 Options for reference filter types. Refer to get_custom_demod_reference_filter and set_custom_demod_reference_filter . Source code in pyinst\\models.py 1883 1884 1885 1886 1887 1888 1889 1890 @property def CUSTOM_DEMOD_REFERENCE_FILTERS ( self ) -> set : \"\"\"Options for reference filter types. Refer to `get_custom_demod_reference_filter` and `set_custom_demod_reference_filter`. \"\"\" return self . __custom_reference_demod_filters __init__ ( resource_name , encoding = 'latin1' , ** kwargs ) \u00a4 Parameters: Name Type Description Default resource_name Resource name or alias of the VISA resource to open. required encoding Encoding of VISA IO string. Default to \"latin1\" since there are some particular caractors. 'latin1' kwargs directly passed to VisaInstrument.__init__ . required Source code in pyinst\\models.py 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 def __init__ ( self , resource_name , encoding = 'latin1' , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. encoding: Encoding of VISA IO string. Default to `\"latin1\"` since there are some particular caractors. kwargs: directly passed to `VisaInstrument.__init__`. \"\"\" super ( BaseModelVSA89600 , self ) . __init__ ( resource_name , encoding = encoding , ** kwargs ) self . __custom_measurement_demod_filters = { \"None\" , \"Rectangular\" , \"RootRaisedCosine\" , \"Gaussian\" , \"LowPass\" } self . __custom_reference_demod_filters = { \"Rectangular\" , \"RaisedCosine\" , \"RootRaisedCosine\" , \"Gaussian\" , \"HalfSine\" } get_custom_demod_equalization_convergence () \u00a4 Gets the convergence parameter for the Adaptive Equalizer. Returns: Type Description float the convergence parameter Source code in pyinst\\models.py 2111 2112 2113 2114 2115 2116 2117 2118 2119 def get_custom_demod_equalization_convergence ( self ) -> float : \"\"\"Gets the convergence parameter for the Adaptive Equalizer. Returns: the convergence parameter \"\"\" cmd = \":CDEMod:COMPensate:EQUalize:CONVergence?\" param = float ( self . query ( cmd )) return param get_custom_demod_equalization_length () \u00a4 Gets the length of the equalization filter, in symbols. Returns: Type Description int length of the equalization fileter in symbols. Source code in pyinst\\models.py 2090 2091 2092 2093 2094 2095 2096 2097 2098 def get_custom_demod_equalization_length ( self ) -> int : \"\"\"Gets the length of the equalization filter, in symbols. Returns: length of the equalization fileter in symbols. \"\"\" cmd = ':CDEMod:COMPensate:EQUalize:LENGth?' rpl = self . query ( cmd ) return int ( rpl ) get_custom_demod_equalization_state () \u00a4 Gets a value indicating whether the equalization filter is enabled. Source code in pyinst\\models.py 2070 2071 2072 2073 2074 2075 2076 def get_custom_demod_equalization_state ( self ) -> bool : \"\"\" Gets a value indicating whether the equalization filter is enabled. \"\"\" cmd = ':CDEMod:COMPensate:EQUalize?' state = bool ( int ( self . query ( cmd ))) return state get_custom_demod_equalizer_run_mode () \u00a4 Gets the run mode of the Adaptive Equalizer. Returns: Type Description str run mode: \"Run\" | \"Hold\" Source code in pyinst\\models.py 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 def get_custom_demod_equalizer_run_mode ( self ) -> str : \"\"\" Gets the run mode of the Adaptive Equalizer. Returns: run mode: `\"Run\"` | `\"Hold\"` \"\"\" cmd = ':CDEMod:COMPensate:EQUalize:MODE?' mode = self . query ( cmd ) . strip () . strip ( '\"' ) return mode get_custom_demod_filter_abt () \u00a4 Gets the \u03b1 (alpha) or BT (bandwidth time product) parameter for measurement and reference filters. Source code in pyinst\\models.py 2052 2053 2054 2055 2056 2057 2058 def get_custom_demod_filter_abt ( self ) -> float : \"\"\" Gets the \u03b1 (alpha) or BT (bandwidth time product) parameter for measurement and reference filters. \"\"\" cmd = ':CDEMod:FILTer:ABT?' abt = float ( self . query ( cmd )) return abt get_custom_demod_measurement_filter () \u00a4 Gets the measurement filter applied during the digital demodulation measurement. Returns: Type Description str \"None\" | \"Rectangular\" | \"RootRaisedCosine\" | \"Gaussian\" | \"LowPass\" Source code in pyinst\\models.py 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 def get_custom_demod_measurement_filter ( self ) -> str : \"\"\"Gets the measurement filter applied during the digital demodulation measurement. Returns: `\"None\"` | `\"Rectangular\"` | `\"RootRaisedCosine\"` | `\"Gaussian\"` | `\"LowPass\"` \"\"\" cmd = \":CDEMod:FILTer?\" filter_type = self . query ( cmd ) . strip () . strip ( '\"' ) return filter_type get_custom_demod_reference_filter () \u00a4 Gets the reference filter applied during the digital demodulation measurement. Returns: Type Description str \"Rectangular\" | \"RaisedCosine\" | \"RootRaisedCosine\" | \"Gaussian\" | \"HalfSine\" Source code in pyinst\\models.py 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 def get_custom_demod_reference_filter ( self ) -> str : \"\"\"Gets the reference filter applied during the digital demodulation measurement. Returns: `\"Rectangular\"` | `\"RaisedCosine\"` | `\"RootRaisedCosine\"` | `\"Gaussian\"` | `\"HalfSine\"` \"\"\" cmd = ':CDEMod:FILTer:REFerence?' filter_type = self . query ( cmd ) . strip () . strip ( '\"' ) return filter_type get_custom_demod_result_length () \u00a4 Gets the demodulation measurement result length (in symbols). Returns: Type Description int result length in symbols Source code in pyinst\\models.py 2161 2162 2163 2164 2165 2166 2167 2168 2169 def get_custom_demod_result_length ( self ) -> int : \"\"\"Gets the demodulation measurement result length (in symbols). Returns: result length in symbols \"\"\" cmd = ':CDEMod:RLENgth?' l = int ( self . query ( cmd )) return l get_data_table ( trace ) \u00a4 Get formatted data including table item names, values, and units. Parameters: Name Type Description Default trace int index of trace, 1 based from A. For example, A->1, E->5 required Returns: Type Description dict Mapping[name => (value, unit)] Source code in pyinst\\models.py 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 def get_data_table ( self , trace : int ) -> dict : \"\"\" Get formatted data including table item names, values, and units. Args: trace: index of trace, 1 based from A. For example, A->1, E->5 Returns: Mapping[name => (value, unit)] \"\"\" names = self . get_data_table_names ( trace ) values = self . get_data_table_values ( trace ) units = self . get_data_table_units ( trace ) if len ( names ) == len ( values ) == len ( units ): i_len = len ( names ) else : raise IndexError ( 'Numbers of names, values and units do not match.' ) data = {} for i in range ( i_len ): data [ names [ i ]] = ( values [ i ], units [ i ]) return data get_data_table_names ( trace ) \u00a4 Returns a list of all names in the data table for the specified trace. Parameters: Name Type Description Default trace int index of trace, 1 based from A. For example, A->1, E->5 required Returns: Type Description List [ str ] a list of all names in the data table. Source code in pyinst\\models.py 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 def get_data_table_names ( self , trace : int ) -> List [ str ]: \"\"\" Returns a list of all names in the data table for the specified trace. Args: trace: index of trace, 1 based from A. For example, A->1, E->5 Returns: a list of all names in the data table. \"\"\" if not isinstance ( trace , int ): raise TypeError ( 'param trace should be int' ) if not trace >= 1 : raise ValueError ( 'param trace starts from 1' ) name_str = self . query ( \":TRACe {trace:d} :DATA:TABLe:NAME?\" . format ( trace = trace )) name_list = list ( map ( lambda x : x . strip ( '\"' ), name_str . split ( \",\" ))) return name_list get_data_table_units ( trace ) \u00a4 Get all the units of the specified trace. Parameters: Name Type Description Default trace int index of trace, 1 based from A. For example, A->1, E->5 required Returns: Type Description List [ str ] list of trace item units. Source code in pyinst\\models.py 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 def get_data_table_units ( self , trace : int ) -> List [ str ]: \"\"\" Get all the units of the specified trace. Args: trace: index of trace, 1 based from A. For example, A->1, E->5 Returns: list of trace item units. \"\"\" if not isinstance ( trace , int ): raise TypeError ( 'param trace should be int.' ) if not trace >= 1 : raise ValueError ( 'param trace starts from 1' ) unit_str = self . query ( ':TRACe {trace:d} :DATA:TABLe:UNIT?' . format ( trace = trace )) unit_list = list ( map ( lambda x : x . strip ( '\"' ), unit_str . split ( \",\" ))) return unit_list get_data_table_values ( trace ) \u00a4 Gets a list of values from a data table. Enum values are returned as enum indexes. Parameters: Name Type Description Default trace int index of trace, 1 based from A. For example, A->1, E->5 required Returns: Type Description List [ int | float | str ] a list of values from a data table. Source code in pyinst\\models.py 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 def get_data_table_values ( self , trace : int ) -> List [ int | float | str ]: \"\"\"Gets a list of values from a data table. Enum values are returned as enum indexes. Args: trace: index of trace, 1 based from A. For example, A->1, E->5 Returns: a list of values from a data table. \"\"\" if not isinstance ( trace , int ): raise TypeError ( 'param trace should be int' ) if not trace >= 1 : raise ValueError ( 'param trace starts from 1' ) value_str = self . query ( \":TRACe {trace:d} :DATA:TABLe?\" . format ( trace = trace )) raw_values = value_str . split ( \",\" ) values = [] for r_val in raw_values : try : val = int ( r_val ) except ValueError : try : val = float ( r_val ) except : val = r_val values . append ( val ) return values pause () \u00a4 Causes the measurement to transition to the Paused state. Source code in pyinst\\models.py 1910 1911 1912 def pause ( self ) -> None : \"\"\"Causes the measurement to transition to the Paused state.\"\"\" self . command ( \":INITiate:PAUSe\" ) reset_custom_demod_equalizer () \u00a4 Reset the equalizer filter Source code in pyinst\\models.py 2156 2157 2158 2159 def reset_custom_demod_equalizer ( self ) -> None : \"\"\"Reset the equalizer filter\"\"\" cmd = ':CDEMod:COMPensate:EQUalize:RESet' self . command ( cmd ) restart () \u00a4 Causes the measurement to restart. The Average count is reset to 0 and the measurement transitions to the Running State. Source code in pyinst\\models.py 1914 1915 1916 1917 1918 def restart ( self ) -> None : \"\"\"Causes the measurement to restart. The Average count is reset to 0 and the measurement transitions to the Running State. \"\"\" self . command ( \":INITiate:RESTart\" ) run ( state = True ) \u00a4 Resume or stop the measurement. state == True: Causes the measurement to transition to the Running state. state == False: Immediately stops the measurement, clearing all measurement data. Source code in pyinst\\models.py 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 def run ( self , state : bool = True ) -> None : \"\"\"Resume or stop the measurement. - state == True: Causes the measurement to transition to the Running state. - state == False: Immediately stops the measurement, clearing all measurement data. \"\"\" if state : self . command ( \":INITiate:RESume\" ) else : self . command ( \":INITiate:ABORt\" ) set_custom_demod_equalization_convergence ( value ) \u00a4 Sets the convergence parameter for the Adaptive Equalizer. Parameters: Name Type Description Default value int | float the convergence parameter value required Source code in pyinst\\models.py 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 def set_custom_demod_equalization_convergence ( self , value : int | float ) -> None : \"\"\"Sets the convergence parameter for the Adaptive Equalizer. Args: value: the convergence parameter value \"\"\" if not 1E-8 <= value <= 1e-6 : raise ValueError ( 'Invalid value of EQ convergence: should between 1E-6 and 1E-8.' ) cmd = ':CDEMod:COMPensate:EQUalize:CONVergence {value:.4E} ' . format ( value = value ) self . command ( cmd ) set_custom_demod_equalization_length ( symbols ) \u00a4 Sets the length of the equalization filter, in symbols. Parameters: Name Type Description Default symbols int length of the equalization fileter in symbols. required Source code in pyinst\\models.py 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 def set_custom_demod_equalization_length ( self , symbols : int ) -> None : \"\"\"Sets the length of the equalization filter, in symbols. Args: symbols: length of the equalization fileter in symbols. \"\"\" if not symbols >= 3 : raise ValueError ( 'param symbols should >= 3: {symbols} ' . format ( symbols = symbols )) cmd = ':CDEMod:COMPensate:EQUalize:LENGth {value:d} ' . format ( value = symbols ) self . command ( cmd ) set_custom_demod_equalization_state ( enable ) \u00a4 Sets a value indicating whether the equalization filter is enabled. Parameters: Name Type Description Default enable bool True = enabled, False = disabled. required Source code in pyinst\\models.py 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 def set_custom_demod_equalization_state ( self , enable : bool ) -> None : \"\"\" Sets a value indicating whether the equalization filter is enabled. Args: enable: True = enabled, False = disabled. \"\"\" if not isinstance ( enable , bool ): raise TypeError ( 'parameter enable should be bool.' ) cmd = ':CDEMod:COMPensate:EQUalize {state:d} ' . format ( state = enable ) self . command ( cmd ) set_custom_demod_equalizer_run_mode ( mode ) \u00a4 Sets the run mode of the Adaptive Equalizer. Parameters: Name Type Description Default mode str \"Run\" | \"Hold\" required Source code in pyinst\\models.py 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 def set_custom_demod_equalizer_run_mode ( self , mode : str ) -> None : \"\"\" Sets the run mode of the Adaptive Equalizer. Args: mode: `\"Run\"` | `\"Hold\"` \"\"\" MODES = { \"Run\" , \"Hold\" } if mode not in MODES : raise ValueError ( 'Invalid value for Custom Demod EQ run mode: {vlaue!r} ' . format ( mode )) cmd = ':CDEMod:COMPensate:EQUalize:MODE {value} ' . format ( value = mode ) self . command ( cmd ) set_custom_demod_filter_abt ( abt ) \u00a4 Sets the \u03b1 (alpha) or BT (bandwidth time product) parameter for measurement and reference filters. Parameters: Name Type Description Default abt int | float alpha or BT value. required Source code in pyinst\\models.py 2060 2061 2062 2063 2064 2065 2066 2067 2068 def set_custom_demod_filter_abt ( self , abt : int | float ) -> None : \"\"\" Sets the \u03b1 (alpha) or BT (bandwidth time product) parameter for measurement and reference filters. Args: abt: alpha or BT value. \"\"\" cmd = ':CDEMod:FILTer:ABT {value:f} ' . format ( value = round ( abt , 6 )) self . command ( cmd ) set_custom_demod_measurement_filter ( filter_type ) \u00a4 Sets the measurement filter applied during the digital demodulation measurement. Parameters: Name Type Description Default filter_type str \"None\" | \"Rectangular\" | \"RootRaisedCosine\" | \"Gaussian\" | \"LowPass\" required Source code in pyinst\\models.py 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 def set_custom_demod_measurement_filter ( self , filter_type : str ) -> None : \"\"\"Sets the measurement filter applied during the digital demodulation measurement. Args: filter_type: `\"None\"` | `\"Rectangular\"` | `\"RootRaisedCosine\"` | `\"Gaussian\"` | `\"LowPass\"` \"\"\" if filter_type not in self . CUSTOM_DEMOD_MEASUREMENT_FILTERS : raise ValueError ( 'Invalid filter_type value: {filter!r} ' . format ( filter = filter_type )) cmd = \":CDEMod:FILTer \\\" {filter} \\\" \" . format ( filter = filter_type ) self . command ( cmd ) set_custom_demod_reference_filter ( filter_type ) \u00a4 Sets the reference filter applied during the digital demodulation measurement. Parameters: Name Type Description Default filter_type str \"Rectangular\" | \"RaisedCosine\" | \"RootRaisedCosine\" | \"Gaussian\" | \"HalfSine\" required Source code in pyinst\\models.py 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 def set_custom_demod_reference_filter ( self , filter_type : str ) -> None : \"\"\"Sets the reference filter applied during the digital demodulation measurement. Args: filter_type: `\"Rectangular\"` | `\"RaisedCosine\"` | `\"RootRaisedCosine\"` | `\"Gaussian\"` | `\"HalfSine\"` \"\"\" if filter_type not in self . CUSTOM_DEMOD_REFERENCE_FILTERS : raise ValueError ( 'Invalid filter_type value: {filter!r} ' . format ( filter = filter_type )) cmd = \":CDEMod:FILTer:REFerence \\\" {filter} \\\" \" . format ( filter = filter_type ) self . command ( cmd ) set_custom_demod_result_length ( length ) \u00a4 Gets the demodulation measurement result length (in symbols). Parameters: Name Type Description Default length int result length in symbols required Source code in pyinst\\models.py 2171 2172 2173 2174 2175 2176 2177 2178 def set_custom_demod_result_length ( self , length : int ) -> None : \"\"\"Gets the demodulation measurement result length (in symbols). Args: length: result length in symbols \"\"\" cmd = ':CDEMod:RLENgth {v:d} ' . format ( v = length ) self . command ( cmd ) stop () \u00a4 Immediately stops the measurement, clearing all measurement data. Source code in pyinst\\models.py 1906 1907 1908 def stop ( self ) -> None : \"\"\"Immediately stops the measurement, clearing all measurement data.\"\"\" self . run ( state = False ) BaseModelVSA89600_OMA \u00a4 Bases: BaseModelVSA89600 , TypeOMA Base class for Keysight OMAs based on VSA 89600 software: M8290A and N4392A Optical Modulation Analyzers Source code in pyinst\\models.py 2181 2182 2183 2184 2185 2186 2187 2188 2189 2190 2191 2192 2193 2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 2212 2213 2214 2215 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 2250 2251 2252 2253 2254 2255 2256 2257 2258 2259 2260 2261 2262 2263 2264 2265 2266 2267 2268 2269 2270 2271 2272 2273 2274 2275 2276 2277 2278 2279 2280 2281 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 2293 class BaseModelVSA89600_OMA ( BaseModelVSA89600 , TypeOMA ): \"\"\"Base class for Keysight OMAs based on VSA 89600 software: - M8290A and N4392A Optical Modulation Analyzers \"\"\" @property def DEMOD_FORMATS ( self ): options = ( \"Qam16\" , \"Qam32\" , \"Qam64\" , \"Qam256\" , \"Qpsk\" , \"DifferentialQpsk\" , \"Pi4DifferentialQpsk\" , \"OffsetQpsk\" , \"Bpsk\" , \"Psk8\" , \"Msk\" , \"Msk2\" , \"Fsk2\" , \"Fsk4\" , \"DvbQam16\" , \"DvbQam32\" , \"DvbQam64\" , \"Vsb8\" , \"Vsb16\" , \"Edge\" , \"Fsk8\" , \"Fsk16\" , \"Qam128\" , \"DifferentialPsk8\" , \"Qam512\" , \"Qam1024\" , \"Apsk16\" , \"Apsk16Dvb\" , \"Apsk32\" , \"Apsk32Dvb\" , \"DvbQam128\" , \"DvbQam256\" , \"Pi8DifferentialPsk8\" , \"CpmFM\" , \"Star16Qam\" , \"Star32Qam\" , \"CustomApsk\" , \"ShapedOffsetQpsk\" ) return options @property def POLARIZATIONS ( self ): options = ( \"Single\" , \"Dual\" , \"Auto\" ) return options def get_frequency ( self ) -> float : cmd = \":OMA:SMartSEtup:CarrierFrequency:FRErequency?\" freq = float ( self . query ( cmd )) / 10 ** 12 return freq def get_wavelength ( self ) -> float : cmd = \":OMA:SMartSEtup:CarrierFrequency:WaVeLength?\" wl = float ( self . query ( cmd )) return wl def set_frequency ( self , frequency : int | float ) -> None : self . smart_setup ( freq = frequency , pre_set_layout = False ) def set_wavelength ( self , wavelength : int | float ) -> None : return super () . set_wavelength ( wavelength ) def smart_setup ( self , execute : bool = True , frequency : Optional [ int | float ] = None , symbol_rate : Optional [ int | float ] = None , fine_tune_symbol_rate : Optional [ bool ] = None , demodulation_format : Optional [ str ] = None , polarization : Optional [ str ] = None , pre_set_layout : Optional [ bool ] = None , compensate_cd : Optional [ bool ] = None , compensate_pmd : Optional [ bool ] = None ): \"\"\"Perform smart setup of the OMA. Use parameter `execute` to choose whether to execute the changed settings or not. If a setting parameter is not explicitly given (default as None), the old setting will be kept. Args: execute: Whether to execute smart setup with the new settings. If set to False, the settings of smart setup will be changed, but the OMA will not execute smart setup. frequency: The carrier frequency in THz. symbol_rate: The symbol rate in GHz. fine_tune_symbol_rate: Whether the system should try to fine tune the symbol rate. demodulation_format: The selected digital demodulation format. Refer to `DEMOD_FORMATS` for options. polarization: The expected polarization or if auto detection should be used. options: `\"Single\"` | `\"Dual\"` | `\"Auto\"`. pre_set_layout: Whether a preset of the trace layout should be performed. compensate_cd: A value indicating whether CD should be compensated. compensate_pmd: A value indicating whether PMD should be compensated. \"\"\" if frequency is not None : self . command ( ':OMA:SMartSEtup:CarrierFrequency:FRErequency {value:d} ' . format ( value = round ( frequency * 10 ** 12 ))) if symbol_rate is not None : self . command ( ':OMA:SMartSEtup:SYMBRate {value:d} ' . format ( value = round ( symbol_rate * 10 ** 9 ))) if fine_tune_symbol_rate is not None : if not isinstance ( fine_tune_symbol_rate , bool ): raise TypeError ( 'param fine_tune_symbol_rate should be bool: {val} ' . format ( val = fine_tune_symbol_rate )) self . command ( ':OMA:SMartSEtup:FINetuneSymbolRate {enable:d} ' . format ( enable = fine_tune_symbol_rate )) if demodulation_format is not None : if demodulation_format not in self . DEMOD_FORMATS : raise ValueError ( 'Invalid modulation demodulation format: {format!r} ' . format ( format = demodulation_format )) self . command ( ':OMA:SMartSEtup:FORMat \" {format} \"' . format ( format = demodulation_format )) if polarization is not None : if not polarization in self . POLARIZATIONS : raise ValueError ( 'Invalid polarization: {pol!r} ' . format ( pol = polarization )) self . command ( ':OMA:SMartSEtup:POLarization \" {pol} \"' . format ( pol = polarization )) if pre_set_layout is not None : if not isinstance ( pre_set_layout , bool ): raise TypeError ( 'param pre_set_layout should be bool.' ) self . command ( ':OMA:SMartSEtup:PREsetLAyout {enable:d} ' . format ( enable = pre_set_layout )) if compensate_cd is not None : if not isinstance ( compensate_cd , bool ): raise TypeError ( 'param compensate_cd should be bool.' ) self . command ( ':OMA:SMartSEtup:COmpensateCD {:d} ' . format ( compensate_cd )) if compensate_pmd is not None : if not isinstance ( compensate_pmd , bool ): raise TypeError ( 'param sompensate_pmd should be bool.' ) self . command ( ':OMA:SMartSEtup:COmpensatePMD {:d} ' . format ( compensate_pmd )) if execute : self . command ( ':OMA:SMartSEtup:PERformProposedActions' ) smart_setup ( execute = True , frequency = None , symbol_rate = None , fine_tune_symbol_rate = None , demodulation_format = None , polarization = None , pre_set_layout = None , compensate_cd = None , compensate_pmd = None ) \u00a4 Perform smart setup of the OMA. Use parameter execute to choose whether to execute the changed settings or not. If a setting parameter is not explicitly given (default as None), the old setting will be kept. Parameters: Name Type Description Default execute bool Whether to execute smart setup with the new settings. If set to False, the settings of smart setup will be changed, but the OMA will not execute smart setup. True frequency Optional [ int | float ] The carrier frequency in THz. None symbol_rate Optional [ int | float ] The symbol rate in GHz. None fine_tune_symbol_rate Optional [ bool ] Whether the system should try to fine tune the symbol rate. None demodulation_format Optional [ str ] The selected digital demodulation format. Refer to DEMOD_FORMATS for options. None polarization Optional [ str ] The expected polarization or if auto detection should be used. options: \"Single\" | \"Dual\" | \"Auto\" . None pre_set_layout Optional [ bool ] Whether a preset of the trace layout should be performed. None compensate_cd Optional [ bool ] A value indicating whether CD should be compensated. None compensate_pmd Optional [ bool ] A value indicating whether PMD should be compensated. None Source code in pyinst\\models.py 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 2250 2251 2252 2253 2254 2255 2256 2257 2258 2259 2260 2261 2262 2263 2264 2265 2266 2267 2268 2269 2270 2271 2272 2273 2274 2275 2276 2277 2278 2279 2280 2281 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 2293 def smart_setup ( self , execute : bool = True , frequency : Optional [ int | float ] = None , symbol_rate : Optional [ int | float ] = None , fine_tune_symbol_rate : Optional [ bool ] = None , demodulation_format : Optional [ str ] = None , polarization : Optional [ str ] = None , pre_set_layout : Optional [ bool ] = None , compensate_cd : Optional [ bool ] = None , compensate_pmd : Optional [ bool ] = None ): \"\"\"Perform smart setup of the OMA. Use parameter `execute` to choose whether to execute the changed settings or not. If a setting parameter is not explicitly given (default as None), the old setting will be kept. Args: execute: Whether to execute smart setup with the new settings. If set to False, the settings of smart setup will be changed, but the OMA will not execute smart setup. frequency: The carrier frequency in THz. symbol_rate: The symbol rate in GHz. fine_tune_symbol_rate: Whether the system should try to fine tune the symbol rate. demodulation_format: The selected digital demodulation format. Refer to `DEMOD_FORMATS` for options. polarization: The expected polarization or if auto detection should be used. options: `\"Single\"` | `\"Dual\"` | `\"Auto\"`. pre_set_layout: Whether a preset of the trace layout should be performed. compensate_cd: A value indicating whether CD should be compensated. compensate_pmd: A value indicating whether PMD should be compensated. \"\"\" if frequency is not None : self . command ( ':OMA:SMartSEtup:CarrierFrequency:FRErequency {value:d} ' . format ( value = round ( frequency * 10 ** 12 ))) if symbol_rate is not None : self . command ( ':OMA:SMartSEtup:SYMBRate {value:d} ' . format ( value = round ( symbol_rate * 10 ** 9 ))) if fine_tune_symbol_rate is not None : if not isinstance ( fine_tune_symbol_rate , bool ): raise TypeError ( 'param fine_tune_symbol_rate should be bool: {val} ' . format ( val = fine_tune_symbol_rate )) self . command ( ':OMA:SMartSEtup:FINetuneSymbolRate {enable:d} ' . format ( enable = fine_tune_symbol_rate )) if demodulation_format is not None : if demodulation_format not in self . DEMOD_FORMATS : raise ValueError ( 'Invalid modulation demodulation format: {format!r} ' . format ( format = demodulation_format )) self . command ( ':OMA:SMartSEtup:FORMat \" {format} \"' . format ( format = demodulation_format )) if polarization is not None : if not polarization in self . POLARIZATIONS : raise ValueError ( 'Invalid polarization: {pol!r} ' . format ( pol = polarization )) self . command ( ':OMA:SMartSEtup:POLarization \" {pol} \"' . format ( pol = polarization )) if pre_set_layout is not None : if not isinstance ( pre_set_layout , bool ): raise TypeError ( 'param pre_set_layout should be bool.' ) self . command ( ':OMA:SMartSEtup:PREsetLAyout {enable:d} ' . format ( enable = pre_set_layout )) if compensate_cd is not None : if not isinstance ( compensate_cd , bool ): raise TypeError ( 'param compensate_cd should be bool.' ) self . command ( ':OMA:SMartSEtup:COmpensateCD {:d} ' . format ( compensate_cd )) if compensate_pmd is not None : if not isinstance ( compensate_pmd , bool ): raise TypeError ( 'param sompensate_pmd should be bool.' ) self . command ( ':OMA:SMartSEtup:COmpensatePMD {:d} ' . format ( compensate_pmd )) if execute : self . command ( ':OMA:SMartSEtup:PERformProposedActions' ) Model81571A \u00a4 Bases: BaseModel815x_VOA Keysight 81571A variable optical attenuator. Source code in pyinst\\models.py 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 class Model81571A ( BaseModel815x_VOA ): \"\"\"Keysight 81571A variable optical attenuator.\"\"\" model = \"81571A\" brand = \"Keysight\" details = { \"Wavelength Range\" : \"1200 ~ 1700 nm\" , \"Att Range\" : \"0 ~ 60 dB\" , \"Max Safe Input Power\" : \"+33 dBm\" } params = [ { \"name\" : \"slot\" , \"type\" : \"int\" , \"options\" : [ 1 , 2 , 3 , 4 ] } ] def __init__ ( self , resource_name : str , slot : int , ** kwargs ): super () . __init__ ( resource_name , slot , channel = 1 , ** kwargs ) Model81635A \u00a4 Bases: BaseModel816x_OPM Keysight 81635A optical power meter. Source code in pyinst\\models.py 1830 1831 1832 1833 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 class Model81635A ( BaseModel816x_OPM ): \"\"\"Keysight 81635A optical power meter.\"\"\" brand = \"Keysight\" model = \"81635A\" details = { \"Wavelength Range\" : \"800 ~ 1650 nm\" , \"Input Power Range\" : \"-80 ~ +10 dBm\" , \"Max Safe Input Power\" : \"+16 dBm\" , \"Averaging Time\" : \"100 us ~ 10 s\" , # TODO: verify averaging time } params = [ { \"name\" : \"slot\" , \"type\" : \"int\" , \"options\" : [ 1 , 2 , 3 , 4 ] }, { \"name\" : \"channel\" , \"type\" : \"int\" , \"options\" : [ 1 , 2 ] } ] ModelAQ2200_215 \u00a4 Bases: BaseModelAQ2200_OPM Yokogawa AQ2200-215 optical power meter. Source code in pyinst\\models.py 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 class ModelAQ2200_215 ( BaseModelAQ2200_OPM ): \"\"\"Yokogawa AQ2200-215 optical power meter.\"\"\" model = \"AQ2200-215\" brand = \"Yokogawa\" details = { \"Wavelength Range\" : \"970 ~ 1660 nm\" , \"Input Power Range\" : \"-70 ~ +30 dBm\" , \"Averaging Time\" : \"100us ~ 10s\" , } params = [ { \"name\" : \"slot\" , \"type\" : \"int\" , \"min\" : 1 , \"max\" : 10 } ] def __init__ ( self , resource_name : str , slot : int , ** kwargs ) -> None : \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: slot number in the frame kwargs: directly passed to `VisaInstrument.__init__` \"\"\" super () . __init__ ( resource_name , slot , channel = 1 , ** kwargs ) __init__ ( resource_name , slot , ** kwargs ) \u00a4 Parameters: Name Type Description Default resource_name str Resource name or alias of the VISA resource to open. required slot int slot number in the frame required kwargs directly passed to VisaInstrument.__init__ required Source code in pyinst\\models.py 1423 1424 1425 1426 1427 1428 1429 1430 def __init__ ( self , resource_name : str , slot : int , ** kwargs ) -> None : \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: slot number in the frame kwargs: directly passed to `VisaInstrument.__init__` \"\"\" super () . __init__ ( resource_name , slot , channel = 1 , ** kwargs ) ModelAQ2200_221 \u00a4 Bases: BaseModelAQ2200_OPM Yokogawa AQ2200-221 2-channel optical power meter. Source code in pyinst\\models.py 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 class ModelAQ2200_221 ( BaseModelAQ2200_OPM ): \"\"\"Yokogawa AQ2200-221 2-channel optical power meter.\"\"\" model = \"AQ2200-221\" brand = \"Yokogawa\" details = { \"Wavelength Range\" : \"800 ~ 1700 nm\" , \"Input Power Range\" : \"-70 ~ +10 dBm\" , \"Averaging Time\" : \"200us ~ 10s\" , } params = [ { \"name\" : \"slot\" , \"type\" : \"int\" , \"min\" : 1 , \"max\" : 10 }, { \"name\" : \"channel\" , \"type\" : \"int\" , \"options\" : [ 1 , 2 ] } ] @property def min_avg_time ( self ) -> float : return 0.2 @property def avg_time_table ( self ) -> tuple : return ( 0.2 , 0.5 , 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 , 500 , 1000 , 2000 , 5000 , 10000 , ) ModelAQ2200_311 \u00a4 Bases: BaseModelAQ2200_VOA Yokogawa AQ2200-311 variable optical attenuator. Source code in pyinst\\models.py 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 class ModelAQ2200_311 ( BaseModelAQ2200_VOA ): \"\"\"Yokogawa AQ2200-311 variable optical attenuator.\"\"\" model = \"AQ2200-311\" brand = \"Yokogawa\" details = { \"Wavelength Range\" : \"1200 ~ 1700 nm\" , \"Max Att\" : \"60 dB\" , \"Max Safe Input Power\" : \"+23 dBm\" , \"Averaging Time\" : \"100 us ~ 10 s\" , } params = [ { \"name\" : \"slot\" , \"type\" : \"int\" , \"min\" : 1 , \"max\" : 10 } ] def __init__ ( self , resource_name , slot , ** kwargs ) -> None : \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: slot number in the frame kwargs: directly passed to `VisaInstrument.__init__` \"\"\" super () . __init__ ( resource_name , slot , channel = 1 , ** kwargs ) __init__ ( resource_name , slot , ** kwargs ) \u00a4 Parameters: Name Type Description Default resource_name Resource name or alias of the VISA resource to open. required slot slot number in the frame required kwargs directly passed to VisaInstrument.__init__ required Source code in pyinst\\models.py 1492 1493 1494 1495 1496 1497 1498 1499 def __init__ ( self , resource_name , slot , ** kwargs ) -> None : \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: slot number in the frame kwargs: directly passed to `VisaInstrument.__init__` \"\"\" super () . __init__ ( resource_name , slot , channel = 1 , ** kwargs ) ModelAQ2200_311A \u00a4 Bases: BaseModelAQ2200_VOA Yokogawa AQ2200-311A variable optical attenuator. Source code in pyinst\\models.py 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 class ModelAQ2200_311A ( BaseModelAQ2200_VOA ): \"\"\"Yokogawa AQ2200-311A variable optical attenuator.\"\"\" model = \"AQ2200-311A\" brand = \"Yokogawa\" details = { \"Wavelength Range\" : \"1200 ~ 1700 nm\" , \"Max Att\" : \"60 dB\" , \"Max Safe Input Power\" : \"+23 dBm\" , \"Averaging Time\" : \"100 us ~ 10 s\" , } params = [ { \"name\" : \"slot\" , \"type\" : \"int\" , \"min\" : 1 , \"max\" : 10 } ] def __init__ ( self , resource_name , slot , ** kwargs ) -> None : \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: slot number in the frame kwargs: directly passed to `VisaInstrument.__init__` \"\"\" super () . __init__ ( resource_name , slot , channel = 1 , ** kwargs ) __init__ ( resource_name , slot , ** kwargs ) \u00a4 Parameters: Name Type Description Default resource_name Resource name or alias of the VISA resource to open. required slot slot number in the frame required kwargs directly passed to VisaInstrument.__init__ required Source code in pyinst\\models.py 1522 1523 1524 1525 1526 1527 1528 1529 def __init__ ( self , resource_name , slot , ** kwargs ) -> None : \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: slot number in the frame kwargs: directly passed to `VisaInstrument.__init__` \"\"\" super () . __init__ ( resource_name , slot , channel = 1 , ** kwargs ) ModelAQ2200_331 \u00a4 Bases: BaseModelAQ2200_VOA_with_OPM Yokogawa AQ2200-331 variable optical attenuator with built-in power meter. Source code in pyinst\\models.py 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 class ModelAQ2200_331 ( BaseModelAQ2200_VOA_with_OPM ): \"\"\"Yokogawa AQ2200-331 variable optical attenuator with built-in power meter.\"\"\" model = \"AQ2200-331\" brand = \"Yokogawa\" details = { \"Wavelength Range\" : \"1200 ~ 1700 nm\" , \"Max Att\" : \"60 dB\" , \"Max Safe Input Power\" : \"+23 dBm\" , \"Averaging Time\" : \"100 us ~ 10 s\" , } params = [ { \"name\" : \"slot\" , \"type\" : \"int\" , \"min\" : 1 , \"max\" : 10 } ] def __init__ ( self , resource_name , slot , ** kwargs ) -> None : \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: slot number in the frame kwargs: directly passed to `VisaInstrument.__init__` \"\"\" super () . __init__ ( resource_name , slot , channel = 1 , ** kwargs ) __init__ ( resource_name , slot , ** kwargs ) \u00a4 Parameters: Name Type Description Default resource_name Resource name or alias of the VISA resource to open. required slot slot number in the frame required kwargs directly passed to VisaInstrument.__init__ required Source code in pyinst\\models.py 1552 1553 1554 1555 1556 1557 1558 1559 def __init__ ( self , resource_name , slot , ** kwargs ) -> None : \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: slot number in the frame kwargs: directly passed to `VisaInstrument.__init__` \"\"\" super () . __init__ ( resource_name , slot , channel = 1 , ** kwargs ) ModelAQ2200_342 \u00a4 Bases: BaseModelAQ2200_VOA_with_OPM Yokogawa AQ2200-342 variable optical attenuator with built-in power meter. Source code in pyinst\\models.py 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 class ModelAQ2200_342 ( BaseModelAQ2200_VOA_with_OPM ): \"\"\"Yokogawa AQ2200-342 variable optical attenuator with built-in power meter.\"\"\" model = \"AQ2200-342\" brand = \"Yokogawa\" details = { \"Wavelength Range\" : \"1260 ~ 1640 nm\" , \"Max Att\" : \"40 dB Min\" , \"Max Safe Input Power\" : \"+23 dBm\" , \"Averaging Time\" : \"100 us ~ 10 s\" , } params = [ { \"name\" : \"slot\" , \"type\" : \"int\" , \"min\" : 1 , \"max\" : 10 }, { \"name\" : \"channel\" , \"type\" : \"int\" , \"options\" : [ 1 , 2 ] } ] ModelAQ6150 \u00a4 Bases: VisaInstrument , TypeWM Source code in pyinst\\models.py 3458 3459 3460 3461 3462 3463 3464 3465 3466 3467 3468 3469 3470 3471 3472 3473 3474 3475 3476 3477 3478 3479 3480 3481 3482 3483 3484 3485 3486 3487 3488 3489 3490 3491 3492 3493 3494 3495 3496 3497 3498 3499 3500 3501 3502 3503 3504 3505 3506 3507 3508 3509 3510 3511 3512 3513 3514 3515 3516 3517 3518 3519 3520 3521 class ModelAQ6150 ( VisaInstrument , TypeWM ): model = [ \"AQ6150\" , \"AQ6151\" ] brand = \"Yokogawa\" details = { \"Wavelength Range\" : \"1270 ~ 1650 nm\" , \"Input Power Range\" : \"-30 ~ 10 dBm\" , \"Safe Max Input Power\" : \"+18 dBm\" } def __init__ ( self , resource_name , ** kwargs ): super ( ModelAQ6150 , self ) . __init__ ( resource_name , ** kwargs ) def run ( self , state : bool = True ) -> None : \"\"\" Executes (stops) repeat measurement. Args: state: `True` = Execute, `False` = Stop. \"\"\" if not isinstance ( state , bool ): raise TypeError ( 'Parameter state must be bool type.' ) cmd = ':INITiate:CONTinuous {state:d} ' . format ( state = state ) self . command ( cmd ) def stop ( self ): \"\"\" Stops repeat measurement. \"\"\" self . run ( False ) def is_running ( self ) -> bool : \"\"\" Queries the repeat measurement state. Returns: `True` = Execute, `False` = Stop. \"\"\" cmd = ':INITiate:CONTinuous?' state = bool ( int ( self . query ( cmd ))) return state def get_frequency ( self ) -> float : \"\"\"Queries the peak frequency in single view mode for single measurement. Returns: The peak frequency in THz. \"\"\" cmd = \":MEASure:POWer:FREQuency?\" freq = float ( self . query ( cmd )) / 10 ** 12 if freq == 0 : raise ValueError ( 'No optical input signal.' ) return freq def get_wavelength ( self ): \"\"\"Queries the peak wavelength in single view mode for single measurement. Returns: The peak wavelength in nm. \"\"\" cmd = \":MEASure:POWer:WAVelength?\" wl = float ( self . query ( cmd )) * 10 ** 9 if wl == 0 : raise ValueError ( 'No optical input signal.' ) return wl get_frequency () \u00a4 Queries the peak frequency in single view mode for single measurement. Returns: Type Description float The peak frequency in THz. Source code in pyinst\\models.py 3499 3500 3501 3502 3503 3504 3505 3506 3507 3508 3509 def get_frequency ( self ) -> float : \"\"\"Queries the peak frequency in single view mode for single measurement. Returns: The peak frequency in THz. \"\"\" cmd = \":MEASure:POWer:FREQuency?\" freq = float ( self . query ( cmd )) / 10 ** 12 if freq == 0 : raise ValueError ( 'No optical input signal.' ) return freq get_wavelength () \u00a4 Queries the peak wavelength in single view mode for single measurement. Returns: Type Description The peak wavelength in nm. Source code in pyinst\\models.py 3511 3512 3513 3514 3515 3516 3517 3518 3519 3520 3521 def get_wavelength ( self ): \"\"\"Queries the peak wavelength in single view mode for single measurement. Returns: The peak wavelength in nm. \"\"\" cmd = \":MEASure:POWer:WAVelength?\" wl = float ( self . query ( cmd )) * 10 ** 9 if wl == 0 : raise ValueError ( 'No optical input signal.' ) return wl is_running () \u00a4 Queries the repeat measurement state. Returns: Type Description bool True = Execute, False = Stop. Source code in pyinst\\models.py 3488 3489 3490 3491 3492 3493 3494 3495 3496 3497 def is_running ( self ) -> bool : \"\"\" Queries the repeat measurement state. Returns: `True` = Execute, `False` = Stop. \"\"\" cmd = ':INITiate:CONTinuous?' state = bool ( int ( self . query ( cmd ))) return state run ( state = True ) \u00a4 Executes (stops) repeat measurement. Parameters: Name Type Description Default state bool True = Execute, False = Stop. True Source code in pyinst\\models.py 3470 3471 3472 3473 3474 3475 3476 3477 3478 3479 3480 def run ( self , state : bool = True ) -> None : \"\"\" Executes (stops) repeat measurement. Args: state: `True` = Execute, `False` = Stop. \"\"\" if not isinstance ( state , bool ): raise TypeError ( 'Parameter state must be bool type.' ) cmd = ':INITiate:CONTinuous {state:d} ' . format ( state = state ) self . command ( cmd ) stop () \u00a4 Stops repeat measurement. Source code in pyinst\\models.py 3482 3483 3484 3485 3486 def stop ( self ): \"\"\" Stops repeat measurement. \"\"\" self . run ( False ) ModelAQ6370 \u00a4 Bases: VisaInstrument , TypeOSA OSA Source code in pyinst\\models.py 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 2447 2448 2449 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 2460 2461 2462 2463 2464 2465 2466 2467 2468 2469 2470 2471 2472 2473 2474 2475 2476 2477 2478 2479 2480 2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 2495 2496 2497 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 2511 2512 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 2534 2535 2536 2537 2538 2539 2540 2541 2542 2543 2544 2545 2546 2547 2548 2549 2550 2551 2552 2553 2554 2555 2556 2557 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 2578 2579 2580 2581 2582 2583 2584 2585 2586 2587 2588 2589 2590 2591 2592 2593 2594 2595 2596 2597 2598 2599 2600 2601 2602 2603 2604 2605 2606 2607 2608 2609 2610 2611 2612 2613 2614 2615 2616 2617 2618 2619 2620 2621 2622 2623 2624 2625 2626 2627 2628 2629 2630 2631 2632 2633 2634 2635 2636 2637 2638 2639 2640 2641 2642 2643 2644 2645 2646 2647 2648 2649 2650 2651 2652 2653 2654 2655 2656 2657 2658 2659 2660 2661 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 2674 2675 2676 2677 2678 2679 2680 2681 2682 2683 2684 2685 2686 2687 2688 2689 2690 2691 2692 2693 2694 2695 2696 2697 2698 2699 2700 2701 2702 2703 2704 2705 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 2718 2719 2720 2721 2722 2723 2724 2725 2726 2727 2728 2729 2730 2731 2732 2733 2734 2735 2736 2737 2738 2739 2740 2741 2742 2743 2744 2745 2746 2747 2748 2749 2750 2751 2752 2753 2754 2755 2756 2757 2758 2759 2760 2761 2762 2763 2764 2765 2766 2767 2768 2769 2770 2771 2772 2773 2774 2775 2776 2777 2778 2779 2780 2781 2782 2783 2784 2785 2786 2787 2788 2789 2790 2791 2792 2793 2794 2795 2796 2797 2798 2799 2800 2801 2802 2803 2804 2805 2806 2807 2808 2809 2810 2811 2812 2813 2814 2815 2816 2817 2818 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 2829 2830 2831 2832 2833 2834 2835 2836 2837 2838 2839 2840 2841 2842 2843 2844 2845 2846 2847 2848 2849 2850 2851 2852 2853 2854 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 2866 2867 2868 2869 2870 2871 2872 2873 2874 2875 2876 2877 2878 2879 2880 2881 2882 2883 2884 2885 2886 2887 2888 2889 2890 2891 2892 2893 2894 2895 2896 2897 2898 2899 2900 2901 2902 2903 2904 2905 2906 2907 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 2919 2920 2921 2922 2923 2924 2925 2926 2927 2928 2929 2930 2931 2932 2933 2934 2935 2936 2937 2938 2939 2940 2941 2942 2943 2944 2945 2946 2947 2948 2949 2950 2951 2952 2953 2954 2955 2956 2957 2958 2959 2960 2961 2962 2963 2964 2965 2966 2967 2968 2969 2970 2971 2972 2973 2974 2975 2976 2977 2978 2979 2980 2981 2982 2983 2984 2985 2986 2987 2988 2989 2990 2991 2992 2993 2994 2995 2996 2997 2998 2999 3000 3001 3002 3003 3004 3005 3006 3007 3008 3009 3010 3011 3012 3013 3014 3015 3016 3017 3018 3019 3020 3021 3022 3023 3024 3025 3026 3027 3028 3029 3030 3031 3032 3033 3034 3035 3036 3037 3038 3039 3040 3041 3042 3043 3044 3045 3046 3047 3048 3049 3050 3051 3052 3053 3054 3055 3056 3057 3058 3059 3060 3061 3062 3063 3064 3065 3066 3067 3068 3069 3070 3071 3072 3073 3074 3075 3076 3077 3078 3079 3080 3081 3082 3083 3084 3085 3086 3087 3088 3089 3090 3091 3092 3093 3094 3095 3096 3097 3098 3099 3100 3101 3102 3103 3104 3105 3106 3107 3108 3109 3110 3111 3112 3113 3114 3115 3116 3117 3118 3119 3120 3121 3122 3123 3124 3125 3126 3127 3128 3129 3130 3131 3132 3133 3134 3135 3136 3137 3138 3139 3140 3141 3142 3143 3144 3145 3146 3147 3148 3149 3150 3151 3152 3153 3154 3155 3156 3157 3158 3159 3160 3161 3162 3163 3164 3165 3166 3167 3168 3169 3170 3171 3172 3173 3174 3175 3176 3177 3178 3179 3180 3181 3182 3183 3184 3185 3186 3187 3188 3189 3190 3191 3192 3193 3194 3195 3196 3197 3198 3199 3200 3201 3202 3203 3204 3205 3206 3207 3208 3209 3210 3211 3212 3213 3214 3215 3216 3217 3218 3219 3220 3221 3222 3223 3224 3225 3226 3227 3228 3229 3230 3231 3232 3233 3234 3235 3236 3237 3238 3239 3240 3241 3242 3243 3244 3245 3246 3247 3248 3249 3250 3251 3252 3253 3254 3255 3256 3257 3258 3259 3260 3261 3262 3263 3264 3265 3266 3267 3268 3269 3270 3271 3272 3273 3274 3275 3276 3277 3278 3279 3280 3281 3282 3283 3284 3285 3286 3287 3288 3289 3290 3291 3292 3293 3294 3295 3296 3297 3298 3299 3300 3301 3302 3303 3304 3305 3306 3307 3308 3309 3310 3311 3312 3313 3314 3315 3316 3317 3318 3319 3320 3321 3322 3323 3324 3325 3326 3327 3328 3329 3330 3331 3332 3333 3334 3335 3336 3337 3338 3339 3340 3341 3342 3343 3344 3345 3346 3347 3348 3349 3350 3351 3352 3353 3354 3355 3356 3357 3358 3359 3360 3361 3362 3363 3364 3365 3366 3367 3368 3369 3370 3371 3372 3373 3374 3375 3376 3377 3378 3379 3380 3381 3382 3383 3384 3385 3386 3387 3388 3389 3390 3391 3392 3393 3394 3395 3396 3397 3398 3399 3400 3401 3402 3403 3404 3405 3406 3407 3408 3409 3410 3411 3412 3413 3414 3415 3416 3417 3418 3419 3420 3421 3422 3423 3424 3425 3426 3427 3428 3429 3430 3431 3432 3433 3434 3435 3436 3437 3438 3439 3440 3441 3442 3443 3444 3445 3446 3447 3448 3449 3450 3451 3452 3453 3454 class ModelAQ6370 ( VisaInstrument , TypeOSA ): \"\"\" OSA \"\"\" model = \"AQ6370\" brand = \"Yokogawa\" details = { \"Wavelength Range\" : \"600 ~ 1700 nm\" , \"Max. Resolution\" : \"0.02 nm\" } def __init__ ( self , resource_name , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. kwargs: directly passed to `VisaInstrument.__init__`. \"\"\" super ( ModelAQ6370 , self ) . __init__ ( resource_name , ** kwargs ) self . __analysis_cat = [ \"SWTHRESH\" , \"DFBLD\" , \"SMSR\" , \"OSNR\" , \"WDM\" , ] self . command ( ':FORMat:DATA ASCii' ) # set data format to ascii @property def ANALYSIS_CATEGORIES ( self ): return self . __analysis_cat @property def MARKER_NUMBERS ( self ): return ( 1 , 2 , 3 , 4 ) @property def WL_UNITS ( self ): return ( \"NM\" , \"THZ\" ) @property def WL_SPAN_UNITS ( self ): return ( \"NM\" , \"GHZ\" ) def get_x_unit ( self ) -> str : \"\"\"Queries the units for the X axis. Returns: `\"WAV\"` = Wavelength, `\"FREQ\"` = Frequency \"\"\" cmd = \":UNIT:X?\" options = [ \"WAV\" , \"FREQ\" ] unit = options [ int ( self . query ( cmd ))] return unit def set_x_unit ( self , unit : str ): \"\"\"Sets the units for the X axis. Args: unit: `\"WAV\"` | `\"FREQ\"`. `\"WAV\"` = Wavelength, `\"FREQ\"` = Frequency \"\"\" cmd = \":UNIT:X {unit} \" . format ( unit ) self . command ( cmd ) def sweep ( self , mode : str = \"REPEAT\" ) -> None : \"\"\"Sets the sweep mode and makes a sweep. For information about the sweep modes, please refer to documentation of the instrument. Args: mode: Sweep mode. `\"AUTO\"` | `\"REPEAT\"` | `\"SINGLE\"` | `\"STOP\"`. \"\"\" options = [ \"AUTO\" , \"REPEAT\" , \"SINGLE\" , \"STOP\" ] if mode not in options : raise ValueError ( \"Invalid value for param mode: {value} \" . format ( value = mode )) if mode == \"STOP\" : self . command ( ':ABOR' ) else : self . command ( ':INIT:SMOD {mode} ;:INIT' . format ( mode = mode )) def run ( self ) -> None : \"\"\"Makes a REPEAT sweep. Refer to `sweep` for more information.\"\"\" self . command ( ':INIT:SMOD REPEAT;:INIT' ) def stop ( self ) -> None : \"\"\"Stops sweep.\"\"\" self . command ( ':ABOR' ) def single ( self ) -> None : \"\"\"Makes a SINGLE sweep. Refer to `sweep` for more information.\"\"\" self . command ( ':INIT:SMOD SINGLE;:INIT' ) def set_auto_zero ( self , status : bool ) -> None : \"\"\"Sets whether to enable the auto offset function of the level.\"\"\" if not isinstance ( status , bool ): raise TypeError ( 'param status should be bool' ) cmd = \":CALibration:ZERO {status:d} \" . format ( status = status ) self . command ( cmd ) def get_auto_zero ( self ) -> bool : \"\"\"Queries whether to enable the auto offset function of the level.\"\"\" cmd = \":CALibration:ZERO?\" status = bool ( int ( self . query ( cmd ))) return status def zero_once ( self ): \"\"\"Perform offset adjustment once and wait until adjustment complete. TODO: should stopped?\"\"\" self . command ( \":CALibration:ZERO ONCE\" ) while True : being_executed = int ( self . query ( \":CALibration:ZERO:STATus?\" )) if not being_executed : break def set_auto_analysis ( self , enable ): \"\"\"Sets the automatic analysis function.\"\"\" if not isinstance ( enable , bool ): raise TypeError ( \"param enable should be bool.\" ) cmd = \":CALCulate:AUTO {enable:d} \" . format ( enable = enable ) self . command ( cmd ) def get_auto_analysis ( self ): \"\"\"Queries the automatic analysis function.\"\"\" cmd = \":CALCulate:AUTO?\" enabled = bool ( int ( self . query ( cmd ))) return enabled def set_analysis_category ( self , category : str ): \"\"\"Sets the type of analysis. Args: category: The type of analysis. Options: - `SWTHRESH`: Spectrum width analysis (THRESH) - `DFBLD`: DFB-LD parameter analysis - `SMSR`: SMSR analysis - `OSNR`|`WDM`: OSNR(WDM), WDM analysis \"\"\" if category not in self . ANALYSIS_CATEGORIES : raise ValueError ( 'Invalid option of category: %r ' % category ) cmd = \":CALCulate:CATegory {cat} \" . format ( cat = category ) self . command ( cmd ) def get_analysis_category ( self ) -> str : \"\"\"Queries the type of analysis. Returns: The type of analysis. `SWTHRESH`|`DFBLD`|`SMSR`|`WDM`. Please refer to `set_analysis_category` for detail. \"\"\" cat_dict = { 0 : \"SWTHRESH\" , 5 : \"DFBLD\" , 8 : \"SMSR\" , 11 : \"WDM\" } cmd = \":CALCulate:CATegory?\" cat = cat_dict [ int ( self . query ( cmd ))] return cat def set_wdm_analysis_threshold ( self , threshold : int | float ) -> None : \"\"\" Set the threshold level of channel detection for the WDM analysis function. Args: threshold: The threshold level value in dB. \"\"\" cmd = \":CALCulate:PARameter:WDM:TH {th:.2f} DB\" . format ( th = threshold ) self . command ( cmd ) def get_wdm_analysis_threshold ( self ) -> float : \"\"\" Queries the threshold level of channel detection for the WDM analysis function. Returns: The threshold level value in dB. \"\"\" cmd = \":CALCulate:PARameter:WDM:TH?\" th = float ( self . query ( cmd )) return th def set_wdm_analysis_mdiff ( self , mdiff : int | float ) -> None : \"\"\" Sets the peak bottom difference of channel detection for the WDM analysis function. Args: mdiff: The peak-bottom difference in dB. \"\"\" cmd = \":CALCulate:PARameter:WDM:MDIFf {mdiff:.2f} DB\" . format ( mdiff = mdiff ) self . command ( cmd ) def get_wdm_analysis_mdiff ( self ) -> float : \"\"\" Queries the peak bottom difference of channel detection for the WDM analysis function. Returns: The peak-bottom difference in dB. \"\"\" cmd = \":CALCulate:PARameter:WDM:MDIFf?\" mdiff = float ( self . query ( cmd )) return mdiff def set_wdm_analysis_dmask ( self , dmask : int | float ) -> None : \"\"\" Sets the channel mask threshold level for the WDM analysis function. Args: dmask: The channel mask threshold level in dB. \"\"\" cmd = \":CALCulate:PARameter:WDM:DMASk {dmask:.2f} DB\" . format ( dmask = dmask ) self . command ( cmd ) def get_wdm_analysis_dmask ( self ) -> float : \"\"\" Queries the channel mask threshold level for the WDM analysis function. Returns: The channel mask threshold level in dB. \"\"\" cmd = \":CALCulate:PARameter:WDM:DMASk?\" dmask = float ( self . query ( cmd )) return dmask def set_wdm_analysis_nalgo ( self , algo : str ) -> None : \"\"\" Sets the measurement algorithm applied to noise level measurements made by the WDM analysis function. Options of algorithms: - `AFIX` = AUTO FIX - `MFIX` = MANUAL FIX - `ACEN` = AUTO CENTER - `MCEN` = MANUAL CENTER - `PIT` = PIT Args: algo: The name of algorithm. Refer to options above. \"\"\" algo_options = [ \"AFIX\" , \"MFIX\" , \"ACEN\" , \"MCEN\" , \"PIT\" ] if algo . upper () not in algo_options : raise ValueError ( \"Invalid value for algo: {value!r} \" . format ( value = algo )) cmd = \":CALCulate:PARameter:WDM:NALGo {algo} \" . format ( algo = algo ) self . command ( cmd ) def get_wdm_analysis_nalgo ( self ) -> str : \"\"\" Queries the measurement algorithm applied to noise level measurements made by the WDM analysis function. Options of algorithms: - `AFIX` = AUTO FIX - `MFIX` = MANUAL FIX - `ACEN` = AUTO CENTER - `MCEN` = MANUAL CENTER - `PIT` = PIT Returns: The name of algorithm. Refer to options above. \"\"\" algo_options = [ \"AFIX\" , \"MFIX\" , \"ACEN\" , \"MCEN\" , \"PIT\" ] cmd = \":CALCulate:PARameter:WDM:NALGo?\" algo = algo_options [ int ( self . query ( cmd ))] return algo def set_wdm_analysis_narea ( self , narea : int | float ) -> None : \"\"\"Sets the measuring range applied to noise level measurements made by the WDM analysis function. Args: narea: The range in nm. \"\"\" cmd = \":CALCulate:PARameter:WDM:NARea {narea:.2f} NM\" . format ( narea = narea ) self . command ( cmd ) def get_wdm_analysis_narea ( self ) -> float : \"\"\"Quereis the measuring range applied to noise level measurements made by the WDM analysis function. Returns: The range in nm. \"\"\" cmd = \":CALCulate:PARameter:WDM:NARea?\" narea = float ( self . query ( cmd )) * 10 ** 9 return narea def set_wdm_analysis_marea ( self , marea : int | float ) -> None : \"\"\"Sets the mask range during level measurement applied to noise level measurements made by the WDM analysis function. Args: marea: The mask range in nm. \"\"\" cmd = \":CALCulate:PARameter:WDM:MARea {marea:.2f} NM\" . format ( marea = marea ) self . command ( cmd ) def get_wdm_analysis_marea ( self ) -> float : \"\"\"Queries the mask range during level measurement applied to noise level measurements made by the WDM analysis function. Returns: The mask range in nm. \"\"\" cmd = \":CALCulate:PARameter:WDM:MARea?\" marea = float ( self . query ( cmd )) * 10 ** 9 return marea def set_wdm_analysis_falgo ( self , algo : str ) -> None : \"\"\"Sets the fitting function during level measurement applied to noise level measurements made by the WDM analysis function. Options of algorithms: - `LIN` = LINEAR - `GAUS` = GAUSS - `LOR` = LORENZ - `3RD` = 3RD POLY - `4TH` = 4YH POLY - `5TH` = 5TH POLY Args: algo: The name of the algorithm. Refer to options above. \"\"\" algo_options = [ \"LIN\" , \"GAUS\" , \"LOR\" , \"3RD\" , \"4TH\" , \"5TH\" ] if algo . upper () not in algo_options : raise ValueError ( \"Invalid value for algo: {value!r} \" . format ( value = algo )) cmd = \":CALCulate:PARameter:WDM:FALGo {algo} \" . format ( algo = algo ) self . command ( cmd ) def get_wdm_analysis_falgo ( self ) -> str : \"\"\"Queries the fitting function during level measurement applied to noise level measurements made by the WDM analysis function. Options of algorithms: - `LIN` = LINEAR - `GAUS` = GAUSS - `LOR` = LORENZ - `3RD` = 3RD POLY - `4TH` = 4YH POLY - `5TH` = 5TH POLY Returns: The name of the algorithm. Refer to options above. \"\"\" algo_options = [ \"LIN\" , \"GAUS\" , \"LOR\" , \"3RD\" , \"4TH\" , \"5TH\" ] cmd = \":CALCulate:PARameter:WDM:FALGo?\" algo = algo_options [ int ( self . query ( cmd ))] return algo def set_wdm_analysis_parameter_nbw ( self , nbw : int | float ) -> None : \"\"\"Sets the noise bandwidth for the WDM analysis function. Args: nbw: The noise bandwidth in nm. \"\"\" cmd = \":CALCulate:PARameter:WDM:NBW {nbw:.2f} NM\" . format ( nbw = nbw ) self . command ( cmd ) def get_wdm_analysis_parameter_nbw ( self ) -> float : \"\"\"Queries the noise bandwidth for the WDM analysis function. Returns: The noise bandwidth in nm. \"\"\" cmd = \":CALCulate:PARameter:WDM:NBW?\" nbw = float ( self . query ( cmd )) * 10 ** 9 return nbw def set_smsr_analysis_mask ( self , mask : int | float ) -> None : \"\"\"Set the mask value for the SMSR analysis function. Args: mask: The mask value in nm. \"\"\" cmd = \":CALCulate:PARameter:SMSR:MASK {mask:.2f} NM\" . format ( mask = mask ) self . command ( cmd ) def get_smsr_analysis_mask ( self , mask : int | float ) -> None : \"\"\"Quereis the mask value for the SMSR analysis function. Returns: The mask value in nm. \"\"\" cmd = \":CALCulate:PARameter:SMSR:MASK?\" mask = float ( self . query ( cmd )) * 10 ** 9 return mask def set_smsr_analysis_mode ( self , mode : str ) -> None : \"\"\"Sets the analysis mode for the SMSR analysis function. Args: mode: The analysis mode, `SMSR1`|`SMSR2`|`SMSR3`|`SMSR4`. \"\"\" options = [ \"SMSR1\" , \"SMSR2\" , \"SMSR3\" , \"SMSR4\" ] if mode not in options : raise ValueError ( \"Invalid option for mode: {mode!r} \" . format ( mode = mode )) cmd = \":CALCulate:PARameter:SMSR:MODE {mode} \" . format ( mode = mode ) self . command ( cmd ) def get_smsr_analysis_mode ( self ) -> str : \"\"\"Sets the analysis mode for the SMSR analysis function. Returns: The analysis mode, `SMSR1`|`SMSR2`|`SMSR3`|`SMSR4`. \"\"\" cmd = \":CALCulate:PARameter:SMSR:MODE?\" mode = self . query ( cmd ) . strip () return mode def set_dfbld_analysis_parameter ( self , item : str , parameter : str , data : str ) -> None : \"\"\"Sets parameters for the DFB-LD analysis function. For more information, please refer to the documents provided by instument vendor. Args: item: Analytical item that sets parameter(s). parameter: Parameter to be set. data: Setting data. |`<item>`|`<parameter>`|`<data>`| |--------|-------------|--------| |SWIDth |ALGO |`ENVelope|THResh|RMS|PKRMs`| | |TH |`<NRf>[DB]`| | |TH2 |`<NRf>[DB]`| | |K |`<NRf>`| | |MFIT |`OFF|ON|0|1`| | |MDIFf |`<NRf>[DB]`| |SMSR |SMODe |`SMSR1|SMSR2|SMSR3|SMSR4`| | |SMASk |`<NRf>[M]`| | |MDIFf |`<NRf>[DB]`| |RMS |ALGO |`RMS|PKRMs`| | |TH |`<NRf>[DB]`| | |K |`<NRf>`| | |MDIFf |`<NRf>[DB]`| |POWer |SPAN |`<NRf>[M]`| |OSNR |MDIFf |`<NRf>[DB]`| | |NALGo |`AFIX|MFIX|ACENter|MCENter|PIT|0|1|2|3|4`| | |NARea |`<NRf>[M]`| | |MARea |`<NRf>[M]`| | |FALGo |`LINear|GAUSs|LORenz|3RD|4TH|5TH|0|1|2|3|4|5`| | |NBW |`<NRf>[M]`| | |SPOWer |`PEAK|INTegral|0|1`| | |IRANge |`<NRf>`| \"\"\" cmd = \":CALCulate:PARameter:DFBLd {item} , {paramater} , {data} \" . format ( item = item , parameter = parameter , data = data ) self . command ( cmd ) def get_dfbld_analysis_parameter ( self , item : str , parameter : str ) -> str : \"\"\"Sets parameters for the DFB-LD analysis function. For more information, please refer to the documents provided by instument vendor. Args: item: Analytical item that sets parameter(s). parameter: Parameter to be set. Returns: A string of the value of parameter. Please refer to `set_dfbld_analysis_parameter` for detail. \"\"\" cmd = \":CALCulate:PARameter:DFBLd? {item} , {paramater} \" . format ( item = item , parameter = parameter ) return self . query ( cmd ) def set_swthresh_analysis_k ( self , k : int | float ) -> None : \"\"\"Sets the magnification of the THRESH method-based spectrum width analysis function. Args: k: The magnification. \"\"\" cmd = \":CALCulate:PARameter:SWTHResh:K {k:.2f} \" . format ( k = k ) self . command ( cmd ) def get_swthresh_analysis_k ( self ) -> float : \"\"\"Sets the magnification of the THRESH method-based spectrum width analysis function. Returns: The magnification. \"\"\" cmd = \":CALCulate:PARameter:SWTHResh:K?\" k = float ( self . query ( cmd )) return k def set_swthresh_analysis_mfit ( self , en : bool ) -> None : \"\"\"Sets whether to enable the mode fit of the THRESH method-based spectrum width analysis function. Args: en: Whether to enable the mode fit. \"\"\" if not isinstance ( en , bool ): raise TypeError ( \"Param en should be bool.\" ) cmd = \":CALCulate:PARameter:SWTHresh:MFIT {en:d} \" . format ( en = en ) self . command ( cmd ) def get_swthresh_analysis_mfit ( self ) -> bool : \"\"\"Queries whether to enable the mode fit of the THRESH method-based spectrum width analysis function. Returns: Whether to enable the mode fit. \"\"\" cmd = \":CALCulate:PARameter:SWTHresh:MFIT?\" en = bool ( int ( self . query ( cmd ))) return en def set_swthresh_analysis_th ( self , th : int | float ) -> None : \"\"\"Sets the threshold level of the THRESH method-based spectrum width analysis function. Args: th: The threshold level in dB. \"\"\" cmd = \":CALCulate:PARameter:SWTHresh:TH {th:.2f} DB\" . format ( th = th ) self . command ( cmd ) def get_swthresh_analysis_th ( self ) -> float : \"\"\"Queries the threshold level of the THRESH method-based spectrum width analysis function. Returns: The threshold level in dB. \"\"\" cmd = \":CALCulate:PARameter:SWTHresh:TH?\" th = float ( self . query ( cmd )) return th def get_analysis_data ( self ) -> str : \"\"\"Queries the analysis results from the last time analysis was executed. For the output formats of analysis results, please refer to documents from the instrument vendor. \"\"\" return self . query ( ':CALC:DATA?' ) def set_center ( self , value : int | float , unit : str ) -> None : \"\"\"Sets the measurement condition center wavelength/frequency. Args: value: The center frequency in THz or wavelength in nm. unit: `\"NM\"` or `\"THZ\"`. \"\"\" if unit . upper () not in self . WL_UNITS : raise ValueError ( 'Invalid option for unit: {unit!r} .' . format ( unit = unit )) cmd = \":SENSe:WAVelength:CENTer {value:.4f}{unit} \" . format ( value = value , unit = unit ) self . command ( cmd ) def set_wavelength ( self , wavelength : int | float ) -> None : self . set_center ( wavelength , 'NM' ) def set_frequency ( self , frequency : int | float ) -> None : return self . set_center ( frequency , 'THZ' ) def get_center ( self ) -> float : \"\"\" Queries the measurement condition center wavelength/frequency. Returns: The value of center frequency/wavelength value. If x unit is \"WAV\", returns the center wavelength in nm. If x unit is \"FREQ\", returns the center frequency in THz. Please refer to `get_x_unit` for more information. \"\"\" cmd = \":SENSe:WAVelength:CENTer?\" if \"WAV\" == self . get_x_unit (): center = float ( self . query ( cmd )) * 10 ** 9 else : center = float ( self . query ( cmd )) / 10 ** 12 return center def get_wavelength ( self ) -> float : if \"WAV\" == self . get_x_unit (): cmd = \":SENSe:WAVelength:CENTer?\" wl = float ( self . query ( cmd )) * 10 ** 9 else : wl = super () . get_wavelength () return wl def get_frequency ( self ) -> float : if \"FREQ\" == self . get_x_unit (): cmd = \":SENSe:WAVelength:CENTer?\" freq = float ( self . query ( cmd )) / 10 ** 12 else : freq = super () . get_frequency () return freq def set_span ( self , value : int | float , unit : str ) -> None : \"\"\"Sets the measurement condition measurement span. Args: value: The value of measurement span. unit: `\"NM\"` or `\"GHZ\"`. \"\"\" if unit not in self . WL_SPAN_UNITS : raise ValueError ( \"Invalid option for unit: {unit!r} \" . format ( unit = unit )) cmd = \":SENSe:WAVelengthSPAN {value:.2f}{unit} \" . format ( value = value , unit = unit ) return self . command ( cmd ) def get_span ( self ) -> float : \"\"\"Queries the measurement condition measurement span and unit. Returns: The value of measurement span value. If x unit is \"WAV\", returns the span in nm. If x unit is \"FREQ\", returns the span in GHz. Please refer to `get_x_unit` for more information. \"\"\" cmd = \":SENSe:WAVelengthSPAN?\" if \"WAV\" == self . get_x_unit (): span = float ( self . query ( cmd )) * 10 ** 9 else : span = float ( self . query ( cmd )) / 10 ** 9 return span def get_start_wavelength ( self ) -> float : \"\"\"Queries the measurement condition measurement start wavelength in nm. Returns: The start wavelength in nm. \"\"\" cmd = \":SENSe:WAVelength:STARt?\" if \"WAV\" == self . get_x_unit (): wl = float ( self . query ( cmd )) * 10 ** 9 else : wl = LIGHTSPEED / ( float ( self . query ( cmd )) / 10 ** 12 ) return wl def set_start_wavelength ( self , wavelength : int | float ) -> None : \"\"\"Sets the measurement condition measurement start wavelength in nm. Args: wavelength: The start wavelength in nm. \"\"\" if \"WAV\" == self . get_x_unit (): cmd = \":SENSe:WAVelength:STARt {wl:.6f} NM\" . format ( wl = wavelength ) self . command ( cmd ) else : self . set_stop_frequency ( LIGHTSPEED / wavelength ) def get_stop_wavelength ( self ) -> float : \"\"\"Queries the measurement condition measurement stop wavelength in nm. Returns: The stop wavelength in nm. \"\"\" cmd = \":SENSe:WAVelength:STOP?\" if \"WAV\" == self . get_x_unit (): wl = float ( self . query ( cmd )) * 10 ** 9 else : wl = LIGHTSPEED / ( float ( self . query ( cmd )) / 10 ** 12 ) return wl def set_stop_wavelength ( self , wavelength : int | float ) -> None : \"\"\"Sets the measurement condition measurement stop wavelength in nm. Args: wavelength: The stop wavelength in nm. \"\"\" if \"WAV\" == self . get_x_unit (): cmd = \":SENSe:WAVelength:STOP {wl:.6f} NM\" . format ( wl = wavelength ) self . command ( cmd ) else : self . set_start_frequency ( LIGHTSPEED / wavelength ) def get_start_frequency ( self ) -> float : \"\"\"Queries the measurement condition measurement start frequency in THz. Returns: The start frequency in THz. \"\"\" cmd = \":SENSe:WAVelength:STOP?\" if \"FREQ\" == self . get_x_unit (): f = float ( self . query ( cmd )) / 10 ** 12 else : f = LIGHTSPEED / ( float ( self . query ( cmd )) * 10 ** 9 ) return f def set_start_frequency ( self , frequency : int | float ) -> None : \"\"\"Queries the measurement condition measurement start frequency in THz. Args: frequency: The start frequency in THz. \"\"\" if \"FREQ\" == self . get_x_unit (): cmd = \":SENSe:WAVelength:STOP {freq:.6f} THZ\" . format ( freq = frequency ) self . command ( cmd ) else : self . set_stop_wavelength ( LIGHTSPEED / frequency ) def get_stop_frequency ( self ) -> float : \"\"\"Queries the measurement condition measurement stop frequency in THz. Returns: The stop frequency in THz. \"\"\" cmd = \":SENSe:WAVelength:STARt?\" if \"FREQ\" == self . get_x_unit (): f = float ( self . query ( cmd )) / 10 ** 12 else : f = LIGHTSPEED / ( float ( self . query ( cmd )) * 10 ** 9 ) return f def set_stop_frequency ( self , frequency : int | float ) -> None : \"\"\"Queries the measurement condition measurement stop frequency in THz. Args: frequency: The stop frequency in THz. \"\"\" if \"FREQ\" == self . get_x_unit (): cmd = \":SENSe:WAVelength:STARt {freq:.6f} THZ\" . format ( freq = frequency ) self . command ( cmd ) else : self . set_start_wavelength ( LIGHTSPEED / frequency ) def set_marker_active_state ( self , marker : int , state : bool ) -> None : \"\"\"Set the active state of a specified marker. A marker should be set into active state before further operations. Args: marker: Marker number. `1` | `2` | `3` | `4`. state: `True` = active, `False` = inactive. \"\"\" if marker not in self . MARKER_NUMBERS : raise ValueError ( \"Invalid marker: {marker!r} \" . format ( marker = marker )) if not isinstance ( state , bool ): raise TypeError ( 'Param state should be bool.' ) cmd = \":CALCULATE:MARKER:STATE {marker:d} , {state:d} \" self . command ( cmd ) def get_marker_active_state ( self , marker : int ) -> bool : \"\"\"Queries the active state of a specified marker. A marker should be set into active state before further operations. Args: marker: Marker number. `1` | `2` | `3` | `4`. Returns: `True` = active, `False` = inactive. \"\"\" cmd = \":CALCulate:MARKer:STATe? {marker:d} \" . format ( marker = marker ) state = bool ( int ( self . query ( cmd ))) return state def get_marker_x_unit ( self ) -> str : \"\"\"Queries the units of display for the marker values. Returns: The unit of marker X. `\"WAV\"` | `\"FREQ\"`. \"\"\" cmd = \":CALCulate:MARKer:UNIT?\" unit = [ \"WAV\" , \"FREQ\" ][ int ( self . query ( cmd ))] return unit def set_marker_x_unit ( self , unit : str ) -> None : \"\"\"Sets the units of display for the marker values. Args: unit: The unit of marker X. `\"WAV\"` | `\"FREQ\"`. \"\"\" cmd = \":CALCulate:MARKer:UNIT {unit} \" . format ( unit = unit ) self . command ( cmd ) def set_marker_x ( self , marker : int , x : int | float , unit : str ): \"\"\"Places a specified marker in a specified position. Args: marker: Marker number. `1` | `2` | `3` | `4`. x: The x value to put the marker. unit: The unit of x value. `\"THZ\"` or `\"NM\"`. \"\"\" if marker not in self . MARKER_NUMBERS : raise ValueError ( \"Invalid marker: {marker!r} \" . format ( marker = marker )) if unit not in [ 'NM' , 'THZ' ]: raise ValueError ( \"Invalid unit: {u!r} \" . format ( u = unit )) cmd = \":CALCulate:MARKer:X {marker:d} , {x:.6f}{unit} \" . format ( marker = marker , x = x , unit = unit ) self . command ( cmd ) def get_marker_x ( self , marker : int ) -> float : \"\"\"Queries the X value of the specified marker. Args: marker: Marker number. `1` | `2` | `3` | `4` Returns: The X value of the specified marker. If marker x unit is \"WAV\", returns the x value in nm. If x unit is \"FREQ\", returns the x value in THz. Please refer to `get_marker_x_unit` for information. \"\"\" if marker not in self . MARKER_NUMBERS : raise ValueError ( \"Invalid marker: {marker!r} \" . format ( marker = marker )) cmd = \":CALCulate:MARKer:X? {marker:d} \" . format ( marker = marker ) x_unit = self . get_marker_x_unit () if \"WAV\" == x_unit : x = float ( self . query ( cmd )) * 10 ** 9 else : x = float ( self . query ( cmd )) / 10 ** 12 return x def get_marker_y ( self , marker : int ) -> str : \"\"\"Queries the Y value of the specified marker. This unit of the marker level to be queried is dependent on the Y-axis unit of the active trace. \"\"\" if marker not in self . MARKER_NUMBERS : raise ValueError ( \"Invalid marker: {marker!r} \" . format ( marker = marker )) cmd = \":CALCulate:MARKer:Y? {marker:d} \" . format ( marker = marker ) y = float ( self . query ( cmd )) return y def set_y_scale_mode ( self , mode : str ) -> None : \"\"\"Sets the scale mode of the main scale of the level axis. Args: mode: The scale mode of level axis. `\"LOG\"` = Logarighmic, `\"LIN\"` = Linear. \"\"\" if mode not in ( \"LOG\" , \"LIN\" ): raise ValueError ( \"Invalid mode: {mode!r} \" . format ( mode = mode )) cmd = \":DISPlay:TRACe:Y1:SPACing {mode} \" . format ( mode = mode ) self . command ( cmd ) def get_y_scale_mode ( self ) -> str : \"\"\"Queries the scale mode of the main scale of the level axis. Returns: mode: The scale mode of level axis. `\"LOG\"` = Logarighmic, `\"LIN\"` = Linear. \"\"\" cmd = \":DISPlay:TRACe:Y1:SPACing?\" mode = [ \"LOG\" , \"LIN\" ][ int ( self . query ( cmd ))] return mode def set_peak_to_center ( self ) -> None : \"\"\"Detects the peak wavelength and sets it as the measurement center waveform. \"\"\" cmd = \":CALCulate:MARKer:MAXimum:SCENter\" self . command ( cmd ) def set_ref_level ( self , value : int | float , unit : str ) -> None : \"\"\"Sets the reference level of the main scale of the level axis. Args: value: The value of the ref level. unit: The unit of the ref level. `\"DBM\"` | `\"W\"` | `\"MW\"`. \"\"\" if unit not in [ 'DBM' , 'W' , 'MW' ]: raise ValueError ( 'Invalid unit: {unit!r} ' . format ( unit = unit )) cmd = \":DISPlay:TRACe:Y1:RLEVel {value:.6E}{unit} \" . format ( value = value , unit = unit ) self . command ( cmd ) def get_ref_level ( self ) -> Tuple [ float , str ]: \"\"\"Sets/queries the reference level of the main scale of the level axis. Returns: The value of the ref level in unit dBm or W depends on the Y scale mode. Please refer to `get_y_scale_mode` for information. \"\"\" cmd = \":DISPlay:TRACe:Y1:RLEVel?\" level = float ( self . query ( cmd )) return level def set_peak_to_ref ( self ) -> None : \"\"\"Detects the peak level and sets it for the reference level.\"\"\" cmd = \":CALCulate:MARKer:MAXimum:SRLevel\" self . command ( cmd ) def set_auto_ref_level ( self , enable : bool ) -> None : \"\"\"Sets ON/OFF of the function to automatically detect the peak level and sets it as the reference level. Args: enable: Whether to enable auto ref level. \"\"\" if not isinstance ( enable , bool ): raise TypeError ( \"Param enable must be bool type.\" ) cmd = \":CALCulate:MARKer:MAXimum:SRLevel:AUTO {enable:d} \" . format ( enable = enable ) self . command ( cmd ) def get_auto_ref_level ( self ) -> bool : \"\"\"Queries ON/OFF of the function to automatically detect the peak level and sets it as the reference level. Returns: If this function is enabled. \"\"\" cmd = \":CALCulate:MARKer:MAXimum:SRLevel:AUTO?\" enabled = bool ( int ( self . query ( cmd ))) return enabled def get_resolution_bandwidth ( self ) -> float : \"\"\"Queries the measurment resolution. Returns: The resolution bandwidth. If x unit is \"WAV\", returns the resolution in nm. If x unit is \"FREQ\", returns the resolution in GHz. Please refer to `get_x_unit` for more information. \"\"\" cmd = \":SENSe:BANDwidth?\" if \"WAV\" == self . get_x_unit (): res = float ( self . query ( cmd )) * 10 ** 9 else : res = float ( self . query ( cmd )) / 10 ** 9 return res def set_resolution_bandwidth ( self , bandwidth : int | float , unit : str ) -> None : # TODO: verify if only particular values can be set. \"\"\"Sets the measurment resolution. Args: bandwidth: The resolution bandwidth. unit: `\"NM\"` or `\"GHZ\"`. \"\"\" if unit not in [ \"NM\" , \"GHZ\" ]: raise TypeError ( \"Invalid unit: {unit!r} \" . format ( unit = unit )) cmd = \":SENSe:BANDwidth {bandwidth:.6f}{unit} \" . format ( bandwidth = bandwidth , unit = unit ) self . command ( cmd ) def clear_all_markers ( self ) -> None : \"\"\"Clears all markers.\"\"\" self . command ( ':CALCulate:MARKer:AOFF' ) def set_active_trace ( self , trace_name : str ) -> None : \"\"\"Sets the active trace. Args: trace_name: `TRA` | `TRB` | `TRC` | `TRD` | `TRE` | `TRF` | `TRG` \"\"\" if trace_name not in [ 'TRA' , 'TRB' , 'TRC' , 'TRD' , 'TRE' , 'TRF' , 'TRG' ]: raise ValueError ( 'Invalid trace_name: {name!r} ' . format ( name = trace_name )) cmd = ':TRACe:ACTive {trace_name} ' . format ( trace_name = trace_name ) self . command ( cmd ) def get_active_trace ( self ) -> str : \"\"\"Queries the active trace. Returns: The trace name, `TRA` | `TRB` | `TRC` | `TRD` | `TRE` | `TRF` | `TRG`. \"\"\" cmd = ':TRACe:ACTive?' trace_name = self . query ( cmd ) . strip () return trace_name def set_trace_attribute ( self , trace_name : str , attribute : str ) -> None : \"\"\"Sets the attributes of the specified trace. Args: trace_name: `TRA` | `TRB` | `TRC` | `TRD` | `TRE` | `TRF` | `TRG` attribute: `WRIT` | `FIX` | `MAX` | `MIN` | `RAVG` | `CALC` \"\"\" if trace_name not in [ 'TRA' , 'TRB' , 'TRC' , 'TRD' , 'TRE' , 'TRF' , 'TRG' ]: raise ValueError ( 'Invalid trace_name: {name!r} ' . format ( name = trace_name )) if attribute not in [ 'WRIT' , 'FIX' , 'MAX' , 'MIN' , 'RAVG' , 'CALC' ]: raise ValueError ( 'Invalid attribute: {attr!r} ' . format ( attr = attribute )) cmd = ':TRACe:ATTRibute: {trace} {attribute} ' . format ( trace = trace_name , attribute = attribute ) self . command ( cmd ) def get_trace_attribute ( self , trace_name : str ) -> str : \"\"\"Queries the attributes of the specified trace. Args: trace_name: `TRA` | `TRB` | `TRC` | `TRD` | `TRE` | `TRF` | `TRG` Returns: attribute: `WRIT` | `FIX` | `MAX` | `MIN` | `RAVG` | `CALC` \"\"\" cmd = ':TRACe:ATTRibute: {trace} ?' . format ( trace = trace_name ) ATTRS = [ 'WRIT' , 'FIX' , 'MAX' , 'MIN' , 'RAVG' , 'CALC' ] attr = ATTRS [ int ( self . query ( cmd ))] return attr def set_trace_display_status ( self , trace_name : str , display : bool ) -> None : \"\"\"Sets the display status of the specified trace. Args: trace_name: `TRA` | `TRB` | `TRC` | `TRD` | `TRE` | `TRF` | `TRG` display: Whether to display the trace. \"\"\" if trace_name not in [ 'TRA' , 'TRB' , 'TRC' , 'TRD' , 'TRE' , 'TRF' , 'TRG' ]: raise ValueError ( 'Invalid trace_name: {name!r} ' . format ( name = trace_name )) if not isinstance ( display , bool ): raise TypeError ( 'Parameter display must be bool type.' ) cmd = ':TRACe:STATe: {trace_name} {display:d} ' . format ( trace_name = trace_name , display = display ) self . command ( cmd ) def get_trace_display_status ( self , trace_name : str ) -> bool : \"\"\"Queries the display status of the specified trace. Args: trace_name: `TRA` | `TRB` | `TRC` | `TRD` | `TRE` | `TRF` | `TRG` Returns: Whether the trace is displayed. \"\"\" cmd = ':TRACe:STATe: {trace_name} ?' . format ( trace_name = trace_name ) displayed = bool ( int ( self . query ( cmd ))) return displayed def clear_trace ( self , trace_name : str ) -> None : \"\"\"Deletes the data of a specified trace. Args: trace_name: `TRA` | `TRB` | `TRC` | `TRD` | `TRE` | `TRF` | `TRG` \"\"\" if trace_name not in [ 'TRA' , 'TRB' , 'TRC' , 'TRD' , 'TRE' , 'TRF' , 'TRG' ]: raise ValueError ( 'Invalid trace_name: {name!r} ' . format ( name = trace_name )) cmd = ':TRACe:DELete {trace_name} ' . format ( trace_name = trace_name ) self . command ( cmd ) def clear_all_traces ( self ) -> None : \"\"\"Clears the data for all traces. \"\"\" self . command ( ':TRACe:DELete:ALL' ) def get_trace_data_x ( self , trace_name : str ) -> List [ float ]: \"\"\"Queries the wavelength axis data of the specified trace. Data is output in the unit of wavelength value (nm), regardless of whether this unit is in the wavelength mode or in the frequency mode. Args: trace_name: `TRA` | `TRB` | `TRC` | `TRD` | `TRE` | `TRF` | `TRG` Returns: A list of the wavelength axis data in nm. \"\"\" if trace_name not in [ 'TRA' , 'TRB' , 'TRC' , 'TRD' , 'TRE' , 'TRF' , 'TRG' ]: raise ValueError ( 'Invalid trace_name: {name!r} ' . format ( name = trace_name )) cmd = ':TRACe:DATA:X? {trace_name} ' . format ( trace_name ) result = [ float ( i ) * 10 ** 9 for i in self . query ( cmd ) . split ( ',' )] return result def get_trace_data_y ( self , trace_name : str ) -> List [ float ]: \"\"\"Queries the level axis data of specified trace. The data is output in order of its wavelength from the shortest level to the longest, irrespective of the wavelength/frequency mode. When the level scale is LOG, data is output in LOG values. When the level scale is Linear, data is output in linear values. \"\"\" if trace_name not in [ 'TRA' , 'TRB' , 'TRC' , 'TRD' , 'TRE' , 'TRF' , 'TRG' ]: raise ValueError ( 'Invalid trace_name: {name!r} ' . format ( name = trace_name )) cmd = ':TRACe:DATA:Y? {trace_name} ' . format ( trace_name ) result = [ float ( i ) for i in self . query ( cmd ) . split ( ',' )] return result def capture_screen ( self ) -> bytes : \"\"\"Capture the screen in BMP format and returns the iamge data as bytes. Returns: The image data of the screen capture. \"\"\" # create a unique name with nearly no chance to conflict temp_filename = 'tmp- {timestamp:X} ' . format ( timestamp = int ( time . time () * 10 ** 6 )) # save image to internal memory self . command ( ':MMEMORY:STORE:GRAPHICS COLOR,BMP,\" {filename} \",INTERNAL' . format ( filename = temp_filename )) self . opc # save data to PC bin_data = self . query ( ':MMEMORY:DATA? \" {filename} .BMP\",internal' . format ( filename = temp_filename ), bin = True ) bytes_data = bytes ( bin_data ) # delete temp file from internal memory self . command ( ':MMEMORY:DELETE \" {filename} .BMP\",internal' . format ( filename = temp_filename )) return bytes_data def save_screen ( self , file_path ): \"\"\"Capture the screen and save as a .bmp file. Args: file_path: The file path to save the screen capture. \"\"\" data = self . capture_screen () if os . path . exists ( file_path ): raise PermissionError ( 'The file path {path} already exists.' . format ( path = file_path )) with open ( file_path , 'wb' ) as f : f . write ( data ) __init__ ( resource_name , ** kwargs ) \u00a4 Parameters: Name Type Description Default resource_name Resource name or alias of the VISA resource to open. required kwargs directly passed to VisaInstrument.__init__ . required Source code in pyinst\\models.py 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 2391 2392 2393 2394 def __init__ ( self , resource_name , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. kwargs: directly passed to `VisaInstrument.__init__`. \"\"\" super ( ModelAQ6370 , self ) . __init__ ( resource_name , ** kwargs ) self . __analysis_cat = [ \"SWTHRESH\" , \"DFBLD\" , \"SMSR\" , \"OSNR\" , \"WDM\" , ] self . command ( ':FORMat:DATA ASCii' ) # set data format to ascii capture_screen () \u00a4 Capture the screen in BMP format and returns the iamge data as bytes. Returns: Type Description bytes The image data of the screen capture. Source code in pyinst\\models.py 3426 3427 3428 3429 3430 3431 3432 3433 3434 3435 3436 3437 3438 3439 3440 3441 3442 def capture_screen ( self ) -> bytes : \"\"\"Capture the screen in BMP format and returns the iamge data as bytes. Returns: The image data of the screen capture. \"\"\" # create a unique name with nearly no chance to conflict temp_filename = 'tmp- {timestamp:X} ' . format ( timestamp = int ( time . time () * 10 ** 6 )) # save image to internal memory self . command ( ':MMEMORY:STORE:GRAPHICS COLOR,BMP,\" {filename} \",INTERNAL' . format ( filename = temp_filename )) self . opc # save data to PC bin_data = self . query ( ':MMEMORY:DATA? \" {filename} .BMP\",internal' . format ( filename = temp_filename ), bin = True ) bytes_data = bytes ( bin_data ) # delete temp file from internal memory self . command ( ':MMEMORY:DELETE \" {filename} .BMP\",internal' . format ( filename = temp_filename )) return bytes_data clear_all_markers () \u00a4 Clears all markers. Source code in pyinst\\models.py 3298 3299 3300 def clear_all_markers ( self ) -> None : \"\"\"Clears all markers.\"\"\" self . command ( ':CALCulate:MARKer:AOFF' ) clear_all_traces () \u00a4 Clears the data for all traces. Source code in pyinst\\models.py 3388 3389 3390 def clear_all_traces ( self ) -> None : \"\"\"Clears the data for all traces. \"\"\" self . command ( ':TRACe:DELete:ALL' ) clear_trace ( trace_name ) \u00a4 Deletes the data of a specified trace. Parameters: Name Type Description Default trace_name str TRA | TRB | TRC | TRD | TRE | TRF | TRG required Source code in pyinst\\models.py 3377 3378 3379 3380 3381 3382 3383 3384 3385 3386 def clear_trace ( self , trace_name : str ) -> None : \"\"\"Deletes the data of a specified trace. Args: trace_name: `TRA` | `TRB` | `TRC` | `TRD` | `TRE` | `TRF` | `TRG` \"\"\" if trace_name not in [ 'TRA' , 'TRB' , 'TRC' , 'TRD' , 'TRE' , 'TRF' , 'TRG' ]: raise ValueError ( 'Invalid trace_name: {name!r} ' . format ( name = trace_name )) cmd = ':TRACe:DELete {trace_name} ' . format ( trace_name = trace_name ) self . command ( cmd ) get_active_trace () \u00a4 Queries the active trace. Returns: Type Description str The trace name, TRA | TRB | TRC | TRD | TRE | TRF | TRG . Source code in pyinst\\models.py 3313 3314 3315 3316 3317 3318 3319 3320 3321 def get_active_trace ( self ) -> str : \"\"\"Queries the active trace. Returns: The trace name, `TRA` | `TRB` | `TRC` | `TRD` | `TRE` | `TRF` | `TRG`. \"\"\" cmd = ':TRACe:ACTive?' trace_name = self . query ( cmd ) . strip () return trace_name get_analysis_category () \u00a4 Queries the type of analysis. Returns: Type Description str The type of analysis. SWTHRESH | DFBLD | SMSR | WDM . str Please refer to set_analysis_category for detail. Source code in pyinst\\models.py 2512 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 def get_analysis_category ( self ) -> str : \"\"\"Queries the type of analysis. Returns: The type of analysis. `SWTHRESH`|`DFBLD`|`SMSR`|`WDM`. Please refer to `set_analysis_category` for detail. \"\"\" cat_dict = { 0 : \"SWTHRESH\" , 5 : \"DFBLD\" , 8 : \"SMSR\" , 11 : \"WDM\" } cmd = \":CALCulate:CATegory?\" cat = cat_dict [ int ( self . query ( cmd ))] return cat get_analysis_data () \u00a4 Queries the analysis results from the last time analysis was executed. For the output formats of analysis results, please refer to documents from the instrument vendor. Source code in pyinst\\models.py 2899 2900 2901 2902 2903 2904 2905 2906 def get_analysis_data ( self ) -> str : \"\"\"Queries the analysis results from the last time analysis was executed. For the output formats of analysis results, please refer to documents from the instrument vendor. \"\"\" return self . query ( ':CALC:DATA?' ) get_auto_analysis () \u00a4 Queries the automatic analysis function. Source code in pyinst\\models.py 2491 2492 2493 2494 2495 def get_auto_analysis ( self ): \"\"\"Queries the automatic analysis function.\"\"\" cmd = \":CALCulate:AUTO?\" enabled = bool ( int ( self . query ( cmd ))) return enabled get_auto_ref_level () \u00a4 Queries ON/OFF of the function to automatically detect the peak level and sets it as the reference level. Returns: Type Description bool If this function is enabled. Source code in pyinst\\models.py 3257 3258 3259 3260 3261 3262 3263 3264 3265 3266 def get_auto_ref_level ( self ) -> bool : \"\"\"Queries ON/OFF of the function to automatically detect the peak level and sets it as the reference level. Returns: If this function is enabled. \"\"\" cmd = \":CALCulate:MARKer:MAXimum:SRLevel:AUTO?\" enabled = bool ( int ( self . query ( cmd ))) return enabled get_auto_zero () \u00a4 Queries whether to enable the auto offset function of the level. Source code in pyinst\\models.py 2470 2471 2472 2473 2474 def get_auto_zero ( self ) -> bool : \"\"\"Queries whether to enable the auto offset function of the level.\"\"\" cmd = \":CALibration:ZERO?\" status = bool ( int ( self . query ( cmd ))) return status get_center () \u00a4 Queries the measurement condition center wavelength/frequency. Returns: Type Description float The value of center frequency/wavelength value. If x unit is float \"WAV\", returns the center wavelength in nm. If x unit is \"FREQ\", float returns the center frequency in THz. float Please refer to get_x_unit for more information. Source code in pyinst\\models.py 2926 2927 2928 2929 2930 2931 2932 2933 2934 2935 2936 2937 2938 2939 2940 2941 2942 def get_center ( self ) -> float : \"\"\" Queries the measurement condition center wavelength/frequency. Returns: The value of center frequency/wavelength value. If x unit is \"WAV\", returns the center wavelength in nm. If x unit is \"FREQ\", returns the center frequency in THz. Please refer to `get_x_unit` for more information. \"\"\" cmd = \":SENSe:WAVelength:CENTer?\" if \"WAV\" == self . get_x_unit (): center = float ( self . query ( cmd )) * 10 ** 9 else : center = float ( self . query ( cmd )) / 10 ** 12 return center get_dfbld_analysis_parameter ( item , parameter ) \u00a4 Sets parameters for the DFB-LD analysis function. For more information, please refer to the documents provided by instument vendor. Parameters: Name Type Description Default item str Analytical item that sets parameter(s). required parameter str Parameter to be set. required Returns: Type Description str A string of the value of parameter. Please refer to str set_dfbld_analysis_parameter for detail. Source code in pyinst\\models.py 2818 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 2829 2830 2831 2832 def get_dfbld_analysis_parameter ( self , item : str , parameter : str ) -> str : \"\"\"Sets parameters for the DFB-LD analysis function. For more information, please refer to the documents provided by instument vendor. Args: item: Analytical item that sets parameter(s). parameter: Parameter to be set. Returns: A string of the value of parameter. Please refer to `set_dfbld_analysis_parameter` for detail. \"\"\" cmd = \":CALCulate:PARameter:DFBLd? {item} , {paramater} \" . format ( item = item , parameter = parameter ) return self . query ( cmd ) get_marker_active_state ( marker ) \u00a4 Queries the active state of a specified marker. A marker should be set into active state before further operations. Parameters: Name Type Description Default marker int Marker number. 1 | 2 | 3 | 4 . required Returns: Type Description bool True = active, False = inactive. Source code in pyinst\\models.py 3103 3104 3105 3106 3107 3108 3109 3110 3111 3112 3113 3114 3115 def get_marker_active_state ( self , marker : int ) -> bool : \"\"\"Queries the active state of a specified marker. A marker should be set into active state before further operations. Args: marker: Marker number. `1` | `2` | `3` | `4`. Returns: `True` = active, `False` = inactive. \"\"\" cmd = \":CALCulate:MARKer:STATe? {marker:d} \" . format ( marker = marker ) state = bool ( int ( self . query ( cmd ))) return state get_marker_x ( marker ) \u00a4 Queries the X value of the specified marker. Parameters: Name Type Description Default marker int Marker number. 1 | 2 | 3 | 4 required Returns: Type Description float The X value of the specified marker. If marker x unit is float \"WAV\", returns the x value in nm. If x unit is \"FREQ\", float returns the x value in THz. float Please refer to get_marker_x_unit for information. Source code in pyinst\\models.py 3151 3152 3153 3154 3155 3156 3157 3158 3159 3160 3161 3162 3163 3164 3165 3166 3167 3168 3169 3170 3171 3172 def get_marker_x ( self , marker : int ) -> float : \"\"\"Queries the X value of the specified marker. Args: marker: Marker number. `1` | `2` | `3` | `4` Returns: The X value of the specified marker. If marker x unit is \"WAV\", returns the x value in nm. If x unit is \"FREQ\", returns the x value in THz. Please refer to `get_marker_x_unit` for information. \"\"\" if marker not in self . MARKER_NUMBERS : raise ValueError ( \"Invalid marker: {marker!r} \" . format ( marker = marker )) cmd = \":CALCulate:MARKer:X? {marker:d} \" . format ( marker = marker ) x_unit = self . get_marker_x_unit () if \"WAV\" == x_unit : x = float ( self . query ( cmd )) * 10 ** 9 else : x = float ( self . query ( cmd )) / 10 ** 12 return x get_marker_x_unit () \u00a4 Queries the units of display for the marker values. Returns: Type Description str The unit of marker X. \"WAV\" | \"FREQ\" . Source code in pyinst\\models.py 3117 3118 3119 3120 3121 3122 3123 3124 3125 def get_marker_x_unit ( self ) -> str : \"\"\"Queries the units of display for the marker values. Returns: The unit of marker X. `\"WAV\"` | `\"FREQ\"`. \"\"\" cmd = \":CALCulate:MARKer:UNIT?\" unit = [ \"WAV\" , \"FREQ\" ][ int ( self . query ( cmd ))] return unit get_marker_y ( marker ) \u00a4 Queries the Y value of the specified marker. This unit of the marker level to be queried is dependent on the Y-axis unit of the active trace. Source code in pyinst\\models.py 3174 3175 3176 3177 3178 3179 3180 3181 3182 3183 3184 def get_marker_y ( self , marker : int ) -> str : \"\"\"Queries the Y value of the specified marker. This unit of the marker level to be queried is dependent on the Y-axis unit of the active trace. \"\"\" if marker not in self . MARKER_NUMBERS : raise ValueError ( \"Invalid marker: {marker!r} \" . format ( marker = marker )) cmd = \":CALCulate:MARKer:Y? {marker:d} \" . format ( marker = marker ) y = float ( self . query ( cmd )) return y get_ref_level () \u00a4 Sets/queries the reference level of the main scale of the level axis. Returns: Type Description float The value of the ref level in unit dBm or W depends on the Y scale str mode. Please refer to get_y_scale_mode for information. Source code in pyinst\\models.py 3228 3229 3230 3231 3232 3233 3234 3235 3236 3237 3238 def get_ref_level ( self ) -> Tuple [ float , str ]: \"\"\"Sets/queries the reference level of the main scale of the level axis. Returns: The value of the ref level in unit dBm or W depends on the Y scale mode. Please refer to `get_y_scale_mode` for information. \"\"\" cmd = \":DISPlay:TRACe:Y1:RLEVel?\" level = float ( self . query ( cmd )) return level get_resolution_bandwidth () \u00a4 Queries the measurment resolution. Returns: Type Description float The resolution bandwidth. If x unit is \"WAV\", returns the float resolution in nm. If x unit is \"FREQ\", returns the resolution float in GHz. float Please refer to get_x_unit for more information. Source code in pyinst\\models.py 3268 3269 3270 3271 3272 3273 3274 3275 3276 3277 3278 3279 3280 3281 3282 3283 def get_resolution_bandwidth ( self ) -> float : \"\"\"Queries the measurment resolution. Returns: The resolution bandwidth. If x unit is \"WAV\", returns the resolution in nm. If x unit is \"FREQ\", returns the resolution in GHz. Please refer to `get_x_unit` for more information. \"\"\" cmd = \":SENSe:BANDwidth?\" if \"WAV\" == self . get_x_unit (): res = float ( self . query ( cmd )) * 10 ** 9 else : res = float ( self . query ( cmd )) / 10 ** 9 return res get_smsr_analysis_mask ( mask ) \u00a4 Quereis the mask value for the SMSR analysis function. Returns: Type Description None The mask value in nm. Source code in pyinst\\models.py 2747 2748 2749 2750 2751 2752 2753 2754 2755 def get_smsr_analysis_mask ( self , mask : int | float ) -> None : \"\"\"Quereis the mask value for the SMSR analysis function. Returns: The mask value in nm. \"\"\" cmd = \":CALCulate:PARameter:SMSR:MASK?\" mask = float ( self . query ( cmd )) * 10 ** 9 return mask get_smsr_analysis_mode () \u00a4 Sets the analysis mode for the SMSR analysis function. Returns: Type Description str The analysis mode, SMSR1 | SMSR2 | SMSR3 | SMSR4 . Source code in pyinst\\models.py 2769 2770 2771 2772 2773 2774 2775 2776 2777 def get_smsr_analysis_mode ( self ) -> str : \"\"\"Sets the analysis mode for the SMSR analysis function. Returns: The analysis mode, `SMSR1`|`SMSR2`|`SMSR3`|`SMSR4`. \"\"\" cmd = \":CALCulate:PARameter:SMSR:MODE?\" mode = self . query ( cmd ) . strip () return mode get_span () \u00a4 Queries the measurement condition measurement span and unit. Returns: Type Description float The value of measurement span value. If x unit is \"WAV\", returns float the span in nm. If x unit is \"FREQ\", returns the span in GHz. float Please refer to get_x_unit for more information. Source code in pyinst\\models.py 2972 2973 2974 2975 2976 2977 2978 2979 2980 2981 2982 2983 2984 2985 2986 def get_span ( self ) -> float : \"\"\"Queries the measurement condition measurement span and unit. Returns: The value of measurement span value. If x unit is \"WAV\", returns the span in nm. If x unit is \"FREQ\", returns the span in GHz. Please refer to `get_x_unit` for more information. \"\"\" cmd = \":SENSe:WAVelengthSPAN?\" if \"WAV\" == self . get_x_unit (): span = float ( self . query ( cmd )) * 10 ** 9 else : span = float ( self . query ( cmd )) / 10 ** 9 return span get_start_frequency () \u00a4 Queries the measurement condition measurement start frequency in THz. Returns: Type Description float The start frequency in THz. Source code in pyinst\\models.py 3038 3039 3040 3041 3042 3043 3044 3045 3046 3047 3048 3049 def get_start_frequency ( self ) -> float : \"\"\"Queries the measurement condition measurement start frequency in THz. Returns: The start frequency in THz. \"\"\" cmd = \":SENSe:WAVelength:STOP?\" if \"FREQ\" == self . get_x_unit (): f = float ( self . query ( cmd )) / 10 ** 12 else : f = LIGHTSPEED / ( float ( self . query ( cmd )) * 10 ** 9 ) return f get_start_wavelength () \u00a4 Queries the measurement condition measurement start wavelength in nm. Returns: Type Description float The start wavelength in nm. Source code in pyinst\\models.py 2988 2989 2990 2991 2992 2993 2994 2995 2996 2997 2998 2999 def get_start_wavelength ( self ) -> float : \"\"\"Queries the measurement condition measurement start wavelength in nm. Returns: The start wavelength in nm. \"\"\" cmd = \":SENSe:WAVelength:STARt?\" if \"WAV\" == self . get_x_unit (): wl = float ( self . query ( cmd )) * 10 ** 9 else : wl = LIGHTSPEED / ( float ( self . query ( cmd )) / 10 ** 12 ) return wl get_stop_frequency () \u00a4 Queries the measurement condition measurement stop frequency in THz. Returns: Type Description float The stop frequency in THz. Source code in pyinst\\models.py 3063 3064 3065 3066 3067 3068 3069 3070 3071 3072 3073 3074 def get_stop_frequency ( self ) -> float : \"\"\"Queries the measurement condition measurement stop frequency in THz. Returns: The stop frequency in THz. \"\"\" cmd = \":SENSe:WAVelength:STARt?\" if \"FREQ\" == self . get_x_unit (): f = float ( self . query ( cmd )) / 10 ** 12 else : f = LIGHTSPEED / ( float ( self . query ( cmd )) * 10 ** 9 ) return f get_stop_wavelength () \u00a4 Queries the measurement condition measurement stop wavelength in nm. Returns: Type Description float The stop wavelength in nm. Source code in pyinst\\models.py 3013 3014 3015 3016 3017 3018 3019 3020 3021 3022 3023 3024 def get_stop_wavelength ( self ) -> float : \"\"\"Queries the measurement condition measurement stop wavelength in nm. Returns: The stop wavelength in nm. \"\"\" cmd = \":SENSe:WAVelength:STOP?\" if \"WAV\" == self . get_x_unit (): wl = float ( self . query ( cmd )) * 10 ** 9 else : wl = LIGHTSPEED / ( float ( self . query ( cmd )) / 10 ** 12 ) return wl get_swthresh_analysis_k () \u00a4 Sets the magnification of the THRESH method-based spectrum width analysis function. Returns: Type Description float The magnification. Source code in pyinst\\models.py 2844 2845 2846 2847 2848 2849 2850 2851 2852 2853 def get_swthresh_analysis_k ( self ) -> float : \"\"\"Sets the magnification of the THRESH method-based spectrum width analysis function. Returns: The magnification. \"\"\" cmd = \":CALCulate:PARameter:SWTHResh:K?\" k = float ( self . query ( cmd )) return k get_swthresh_analysis_mfit () \u00a4 Queries whether to enable the mode fit of the THRESH method-based spectrum width analysis function. Returns: Type Description bool Whether to enable the mode fit. Source code in pyinst\\models.py 2867 2868 2869 2870 2871 2872 2873 2874 2875 2876 def get_swthresh_analysis_mfit ( self ) -> bool : \"\"\"Queries whether to enable the mode fit of the THRESH method-based spectrum width analysis function. Returns: Whether to enable the mode fit. \"\"\" cmd = \":CALCulate:PARameter:SWTHresh:MFIT?\" en = bool ( int ( self . query ( cmd ))) return en get_swthresh_analysis_th () \u00a4 Queries the threshold level of the THRESH method-based spectrum width analysis function. Returns: Type Description float The threshold level in dB. Source code in pyinst\\models.py 2888 2889 2890 2891 2892 2893 2894 2895 2896 2897 def get_swthresh_analysis_th ( self ) -> float : \"\"\"Queries the threshold level of the THRESH method-based spectrum width analysis function. Returns: The threshold level in dB. \"\"\" cmd = \":CALCulate:PARameter:SWTHresh:TH?\" th = float ( self . query ( cmd )) return th get_trace_attribute ( trace_name ) \u00a4 Queries the attributes of the specified trace. Parameters: Name Type Description Default trace_name str TRA | TRB | TRC | TRD | TRE | TRF | TRG required Returns: Name Type Description attribute str WRIT | FIX | MAX | MIN | RAVG | CALC Source code in pyinst\\models.py 3337 3338 3339 3340 3341 3342 3343 3344 3345 3346 3347 3348 def get_trace_attribute ( self , trace_name : str ) -> str : \"\"\"Queries the attributes of the specified trace. Args: trace_name: `TRA` | `TRB` | `TRC` | `TRD` | `TRE` | `TRF` | `TRG` Returns: attribute: `WRIT` | `FIX` | `MAX` | `MIN` | `RAVG` | `CALC` \"\"\" cmd = ':TRACe:ATTRibute: {trace} ?' . format ( trace = trace_name ) ATTRS = [ 'WRIT' , 'FIX' , 'MAX' , 'MIN' , 'RAVG' , 'CALC' ] attr = ATTRS [ int ( self . query ( cmd ))] return attr get_trace_data_x ( trace_name ) \u00a4 Queries the wavelength axis data of the specified trace. Data is output in the unit of wavelength value (nm), regardless of whether this unit is in the wavelength mode or in the frequency mode. Parameters: Name Type Description Default trace_name str TRA | TRB | TRC | TRD | TRE | TRF | TRG required Returns: Type Description List [ float ] A list of the wavelength axis data in nm. Source code in pyinst\\models.py 3392 3393 3394 3395 3396 3397 3398 3399 3400 3401 3402 3403 3404 3405 3406 3407 3408 def get_trace_data_x ( self , trace_name : str ) -> List [ float ]: \"\"\"Queries the wavelength axis data of the specified trace. Data is output in the unit of wavelength value (nm), regardless of whether this unit is in the wavelength mode or in the frequency mode. Args: trace_name: `TRA` | `TRB` | `TRC` | `TRD` | `TRE` | `TRF` | `TRG` Returns: A list of the wavelength axis data in nm. \"\"\" if trace_name not in [ 'TRA' , 'TRB' , 'TRC' , 'TRD' , 'TRE' , 'TRF' , 'TRG' ]: raise ValueError ( 'Invalid trace_name: {name!r} ' . format ( name = trace_name )) cmd = ':TRACe:DATA:X? {trace_name} ' . format ( trace_name ) result = [ float ( i ) * 10 ** 9 for i in self . query ( cmd ) . split ( ',' )] return result get_trace_data_y ( trace_name ) \u00a4 Queries the level axis data of specified trace. The data is output in order of its wavelength from the shortest level to the longest, irrespective of the wavelength/frequency mode. When the level scale is LOG, data is output in LOG values. When the level scale is Linear, data is output in linear values. Source code in pyinst\\models.py 3410 3411 3412 3413 3414 3415 3416 3417 3418 3419 3420 3421 3422 3423 3424 def get_trace_data_y ( self , trace_name : str ) -> List [ float ]: \"\"\"Queries the level axis data of specified trace. The data is output in order of its wavelength from the shortest level to the longest, irrespective of the wavelength/frequency mode. When the level scale is LOG, data is output in LOG values. When the level scale is Linear, data is output in linear values. \"\"\" if trace_name not in [ 'TRA' , 'TRB' , 'TRC' , 'TRD' , 'TRE' , 'TRF' , 'TRG' ]: raise ValueError ( 'Invalid trace_name: {name!r} ' . format ( name = trace_name )) cmd = ':TRACe:DATA:Y? {trace_name} ' . format ( trace_name ) result = [ float ( i ) for i in self . query ( cmd ) . split ( ',' )] return result get_trace_display_status ( trace_name ) \u00a4 Queries the display status of the specified trace. Parameters: Name Type Description Default trace_name str TRA | TRB | TRC | TRD | TRE | TRF | TRG required Returns: Type Description bool Whether the trace is displayed. Source code in pyinst\\models.py 3364 3365 3366 3367 3368 3369 3370 3371 3372 3373 3374 3375 def get_trace_display_status ( self , trace_name : str ) -> bool : \"\"\"Queries the display status of the specified trace. Args: trace_name: `TRA` | `TRB` | `TRC` | `TRD` | `TRE` | `TRF` | `TRG` Returns: Whether the trace is displayed. \"\"\" cmd = ':TRACe:STATe: {trace_name} ?' . format ( trace_name = trace_name ) displayed = bool ( int ( self . query ( cmd ))) return displayed get_wdm_analysis_dmask () \u00a4 Queries the channel mask threshold level for the WDM analysis function. Returns: Type Description float The channel mask threshold level in dB. Source code in pyinst\\models.py 2580 2581 2582 2583 2584 2585 2586 2587 2588 2589 def get_wdm_analysis_dmask ( self ) -> float : \"\"\" Queries the channel mask threshold level for the WDM analysis function. Returns: The channel mask threshold level in dB. \"\"\" cmd = \":CALCulate:PARameter:WDM:DMASk?\" dmask = float ( self . query ( cmd )) return dmask get_wdm_analysis_falgo () \u00a4 Queries the fitting function during level measurement applied to noise level measurements made by the WDM analysis function. Options of algorithms: LIN = LINEAR GAUS = GAUSS LOR = LORENZ 3RD = 3RD POLY 4TH = 4YH POLY 5TH = 5TH POLY Returns: Type Description str The name of the algorithm. Refer to options above. Source code in pyinst\\models.py 2698 2699 2700 2701 2702 2703 2704 2705 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 def get_wdm_analysis_falgo ( self ) -> str : \"\"\"Queries the fitting function during level measurement applied to noise level measurements made by the WDM analysis function. Options of algorithms: - `LIN` = LINEAR - `GAUS` = GAUSS - `LOR` = LORENZ - `3RD` = 3RD POLY - `4TH` = 4YH POLY - `5TH` = 5TH POLY Returns: The name of the algorithm. Refer to options above. \"\"\" algo_options = [ \"LIN\" , \"GAUS\" , \"LOR\" , \"3RD\" , \"4TH\" , \"5TH\" ] cmd = \":CALCulate:PARameter:WDM:FALGo?\" algo = algo_options [ int ( self . query ( cmd ))] return algo get_wdm_analysis_marea () \u00a4 Queries the mask range during level measurement applied to noise level measurements made by the WDM analysis function. Returns: Type Description float The mask range in nm. Source code in pyinst\\models.py 2665 2666 2667 2668 2669 2670 2671 2672 2673 2674 def get_wdm_analysis_marea ( self ) -> float : \"\"\"Queries the mask range during level measurement applied to noise level measurements made by the WDM analysis function. Returns: The mask range in nm. \"\"\" cmd = \":CALCulate:PARameter:WDM:MARea?\" marea = float ( self . query ( cmd )) * 10 ** 9 return marea get_wdm_analysis_mdiff () \u00a4 Queries the peak bottom difference of channel detection for the WDM analysis function. Returns: Type Description float The peak-bottom difference in dB. Source code in pyinst\\models.py 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 def get_wdm_analysis_mdiff ( self ) -> float : \"\"\" Queries the peak bottom difference of channel detection for the WDM analysis function. Returns: The peak-bottom difference in dB. \"\"\" cmd = \":CALCulate:PARameter:WDM:MDIFf?\" mdiff = float ( self . query ( cmd )) return mdiff get_wdm_analysis_nalgo () \u00a4 Queries the measurement algorithm applied to noise level measurements made by the WDM analysis function. Options of algorithms: AFIX = AUTO FIX MFIX = MANUAL FIX ACEN = AUTO CENTER MCEN = MANUAL CENTER PIT = PIT Returns: Type Description str The name of algorithm. Refer to options above. Source code in pyinst\\models.py 2613 2614 2615 2616 2617 2618 2619 2620 2621 2622 2623 2624 2625 2626 2627 2628 2629 2630 2631 2632 def get_wdm_analysis_nalgo ( self ) -> str : \"\"\" Queries the measurement algorithm applied to noise level measurements made by the WDM analysis function. Options of algorithms: - `AFIX` = AUTO FIX - `MFIX` = MANUAL FIX - `ACEN` = AUTO CENTER - `MCEN` = MANUAL CENTER - `PIT` = PIT Returns: The name of algorithm. Refer to options above. \"\"\" algo_options = [ \"AFIX\" , \"MFIX\" , \"ACEN\" , \"MCEN\" , \"PIT\" ] cmd = \":CALCulate:PARameter:WDM:NALGo?\" algo = algo_options [ int ( self . query ( cmd ))] return algo get_wdm_analysis_narea () \u00a4 Quereis the measuring range applied to noise level measurements made by the WDM analysis function. Returns: Type Description float The range in nm. Source code in pyinst\\models.py 2644 2645 2646 2647 2648 2649 2650 2651 2652 2653 def get_wdm_analysis_narea ( self ) -> float : \"\"\"Quereis the measuring range applied to noise level measurements made by the WDM analysis function. Returns: The range in nm. \"\"\" cmd = \":CALCulate:PARameter:WDM:NARea?\" narea = float ( self . query ( cmd )) * 10 ** 9 return narea get_wdm_analysis_parameter_nbw () \u00a4 Queries the noise bandwidth for the WDM analysis function. Returns: Type Description float The noise bandwidth in nm. Source code in pyinst\\models.py 2728 2729 2730 2731 2732 2733 2734 2735 2736 def get_wdm_analysis_parameter_nbw ( self ) -> float : \"\"\"Queries the noise bandwidth for the WDM analysis function. Returns: The noise bandwidth in nm. \"\"\" cmd = \":CALCulate:PARameter:WDM:NBW?\" nbw = float ( self . query ( cmd )) * 10 ** 9 return nbw get_wdm_analysis_threshold () \u00a4 Queries the threshold level of channel detection for the WDM analysis function. Returns: Type Description float The threshold level value in dB. Source code in pyinst\\models.py 2535 2536 2537 2538 2539 2540 2541 2542 2543 2544 2545 def get_wdm_analysis_threshold ( self ) -> float : \"\"\" Queries the threshold level of channel detection for the WDM analysis function. Returns: The threshold level value in dB. \"\"\" cmd = \":CALCulate:PARameter:WDM:TH?\" th = float ( self . query ( cmd )) return th get_x_unit () \u00a4 Queries the units for the X axis. Returns: Type Description str \"WAV\" = Wavelength, str \"FREQ\" = Frequency Source code in pyinst\\models.py 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 def get_x_unit ( self ) -> str : \"\"\"Queries the units for the X axis. Returns: `\"WAV\"` = Wavelength, `\"FREQ\"` = Frequency \"\"\" cmd = \":UNIT:X?\" options = [ \"WAV\" , \"FREQ\" ] unit = options [ int ( self . query ( cmd ))] return unit get_y_scale_mode () \u00a4 Queries the scale mode of the main scale of the level axis. Returns: Name Type Description mode str The scale mode of level axis. \"LOG\" = Logarighmic, \"LIN\" = Linear. Source code in pyinst\\models.py 3198 3199 3200 3201 3202 3203 3204 3205 3206 3207 def get_y_scale_mode ( self ) -> str : \"\"\"Queries the scale mode of the main scale of the level axis. Returns: mode: The scale mode of level axis. `\"LOG\"` = Logarighmic, `\"LIN\"` = Linear. \"\"\" cmd = \":DISPlay:TRACe:Y1:SPACing?\" mode = [ \"LOG\" , \"LIN\" ][ int ( self . query ( cmd ))] return mode run () \u00a4 Makes a REPEAT sweep. Refer to sweep for more information. Source code in pyinst\\models.py 2451 2452 2453 def run ( self ) -> None : \"\"\"Makes a REPEAT sweep. Refer to `sweep` for more information.\"\"\" self . command ( ':INIT:SMOD REPEAT;:INIT' ) save_screen ( file_path ) \u00a4 Capture the screen and save as a .bmp file. Parameters: Name Type Description Default file_path The file path to save the screen capture. required Source code in pyinst\\models.py 3444 3445 3446 3447 3448 3449 3450 3451 3452 3453 3454 def save_screen ( self , file_path ): \"\"\"Capture the screen and save as a .bmp file. Args: file_path: The file path to save the screen capture. \"\"\" data = self . capture_screen () if os . path . exists ( file_path ): raise PermissionError ( 'The file path {path} already exists.' . format ( path = file_path )) with open ( file_path , 'wb' ) as f : f . write ( data ) set_active_trace ( trace_name ) \u00a4 Sets the active trace. Parameters: Name Type Description Default trace_name str TRA | TRB | TRC | TRD | TRE | TRF | TRG required Source code in pyinst\\models.py 3302 3303 3304 3305 3306 3307 3308 3309 3310 3311 def set_active_trace ( self , trace_name : str ) -> None : \"\"\"Sets the active trace. Args: trace_name: `TRA` | `TRB` | `TRC` | `TRD` | `TRE` | `TRF` | `TRG` \"\"\" if trace_name not in [ 'TRA' , 'TRB' , 'TRC' , 'TRD' , 'TRE' , 'TRF' , 'TRG' ]: raise ValueError ( 'Invalid trace_name: {name!r} ' . format ( name = trace_name )) cmd = ':TRACe:ACTive {trace_name} ' . format ( trace_name = trace_name ) self . command ( cmd ) set_analysis_category ( category ) \u00a4 Sets the type of analysis. Parameters: Name Type Description Default category str The type of analysis. Options: required - `SWTHRESH` Spectrum width analysis (THRESH) required - `DFBLD` DFB-LD parameter analysis required - `SMSR` SMSR analysis required - `OSNR`|`WDM` OSNR(WDM), WDM analysis required Source code in pyinst\\models.py 2497 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 def set_analysis_category ( self , category : str ): \"\"\"Sets the type of analysis. Args: category: The type of analysis. Options: - `SWTHRESH`: Spectrum width analysis (THRESH) - `DFBLD`: DFB-LD parameter analysis - `SMSR`: SMSR analysis - `OSNR`|`WDM`: OSNR(WDM), WDM analysis \"\"\" if category not in self . ANALYSIS_CATEGORIES : raise ValueError ( 'Invalid option of category: %r ' % category ) cmd = \":CALCulate:CATegory {cat} \" . format ( cat = category ) self . command ( cmd ) set_auto_analysis ( enable ) \u00a4 Sets the automatic analysis function. Source code in pyinst\\models.py 2484 2485 2486 2487 2488 2489 def set_auto_analysis ( self , enable ): \"\"\"Sets the automatic analysis function.\"\"\" if not isinstance ( enable , bool ): raise TypeError ( \"param enable should be bool.\" ) cmd = \":CALCulate:AUTO {enable:d} \" . format ( enable = enable ) self . command ( cmd ) set_auto_ref_level ( enable ) \u00a4 Sets ON/OFF of the function to automatically detect the peak level and sets it as the reference level. Parameters: Name Type Description Default enable bool Whether to enable auto ref level. required Source code in pyinst\\models.py 3245 3246 3247 3248 3249 3250 3251 3252 3253 3254 3255 def set_auto_ref_level ( self , enable : bool ) -> None : \"\"\"Sets ON/OFF of the function to automatically detect the peak level and sets it as the reference level. Args: enable: Whether to enable auto ref level. \"\"\" if not isinstance ( enable , bool ): raise TypeError ( \"Param enable must be bool type.\" ) cmd = \":CALCulate:MARKer:MAXimum:SRLevel:AUTO {enable:d} \" . format ( enable = enable ) self . command ( cmd ) set_auto_zero ( status ) \u00a4 Sets whether to enable the auto offset function of the level. Source code in pyinst\\models.py 2463 2464 2465 2466 2467 2468 def set_auto_zero ( self , status : bool ) -> None : \"\"\"Sets whether to enable the auto offset function of the level.\"\"\" if not isinstance ( status , bool ): raise TypeError ( 'param status should be bool' ) cmd = \":CALibration:ZERO {status:d} \" . format ( status = status ) self . command ( cmd ) set_center ( value , unit ) \u00a4 Sets the measurement condition center wavelength/frequency. Parameters: Name Type Description Default value int | float The center frequency in THz or wavelength in nm. required unit str \"NM\" or \"THZ\" . required Source code in pyinst\\models.py 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 def set_center ( self , value : int | float , unit : str ) -> None : \"\"\"Sets the measurement condition center wavelength/frequency. Args: value: The center frequency in THz or wavelength in nm. unit: `\"NM\"` or `\"THZ\"`. \"\"\" if unit . upper () not in self . WL_UNITS : raise ValueError ( 'Invalid option for unit: {unit!r} .' . format ( unit = unit )) cmd = \":SENSe:WAVelength:CENTer {value:.4f}{unit} \" . format ( value = value , unit = unit ) self . command ( cmd ) set_dfbld_analysis_parameter ( item , parameter , data ) \u00a4 Sets parameters for the DFB-LD analysis function. For more information, please refer to the documents provided by instument vendor. Parameters: Name Type Description Default item str Analytical item that sets parameter(s). required parameter str Parameter to be set. required data str Setting data. required <item> <parameter> <data> SWIDth ALGO ENVelope|THResh|RMS|PKRMs TH <NRf>[DB] TH2 <NRf>[DB] K <NRf> MFIT OFF|ON|0|1 MDIFf <NRf>[DB] SMSR SMODe SMSR1|SMSR2|SMSR3|SMSR4 SMASk <NRf>[M] MDIFf <NRf>[DB] RMS ALGO RMS|PKRMs TH <NRf>[DB] K <NRf> MDIFf <NRf>[DB] POWer SPAN <NRf>[M] OSNR MDIFf <NRf>[DB] NALGo AFIX|MFIX|ACENter|MCENter|PIT|0|1|2|3|4 NARea <NRf>[M] MARea <NRf>[M] FALGo LINear|GAUSs|LORenz|3RD|4TH|5TH|0|1|2|3|4|5 NBW <NRf>[M] SPOWer PEAK|INTegral|0|1 IRANge <NRf> Source code in pyinst\\models.py 2779 2780 2781 2782 2783 2784 2785 2786 2787 2788 2789 2790 2791 2792 2793 2794 2795 2796 2797 2798 2799 2800 2801 2802 2803 2804 2805 2806 2807 2808 2809 2810 2811 2812 2813 2814 2815 2816 def set_dfbld_analysis_parameter ( self , item : str , parameter : str , data : str ) -> None : \"\"\"Sets parameters for the DFB-LD analysis function. For more information, please refer to the documents provided by instument vendor. Args: item: Analytical item that sets parameter(s). parameter: Parameter to be set. data: Setting data. |`<item>`|`<parameter>`|`<data>`| |--------|-------------|--------| |SWIDth |ALGO |`ENVelope|THResh|RMS|PKRMs`| | |TH |`<NRf>[DB]`| | |TH2 |`<NRf>[DB]`| | |K |`<NRf>`| | |MFIT |`OFF|ON|0|1`| | |MDIFf |`<NRf>[DB]`| |SMSR |SMODe |`SMSR1|SMSR2|SMSR3|SMSR4`| | |SMASk |`<NRf>[M]`| | |MDIFf |`<NRf>[DB]`| |RMS |ALGO |`RMS|PKRMs`| | |TH |`<NRf>[DB]`| | |K |`<NRf>`| | |MDIFf |`<NRf>[DB]`| |POWer |SPAN |`<NRf>[M]`| |OSNR |MDIFf |`<NRf>[DB]`| | |NALGo |`AFIX|MFIX|ACENter|MCENter|PIT|0|1|2|3|4`| | |NARea |`<NRf>[M]`| | |MARea |`<NRf>[M]`| | |FALGo |`LINear|GAUSs|LORenz|3RD|4TH|5TH|0|1|2|3|4|5`| | |NBW |`<NRf>[M]`| | |SPOWer |`PEAK|INTegral|0|1`| | |IRANge |`<NRf>`| \"\"\" cmd = \":CALCulate:PARameter:DFBLd {item} , {paramater} , {data} \" . format ( item = item , parameter = parameter , data = data ) self . command ( cmd ) set_marker_active_state ( marker , state ) \u00a4 Set the active state of a specified marker. A marker should be set into active state before further operations. Parameters: Name Type Description Default marker int Marker number. 1 | 2 | 3 | 4 . required state bool True = active, False = inactive. required Source code in pyinst\\models.py 3088 3089 3090 3091 3092 3093 3094 3095 3096 3097 3098 3099 3100 3101 def set_marker_active_state ( self , marker : int , state : bool ) -> None : \"\"\"Set the active state of a specified marker. A marker should be set into active state before further operations. Args: marker: Marker number. `1` | `2` | `3` | `4`. state: `True` = active, `False` = inactive. \"\"\" if marker not in self . MARKER_NUMBERS : raise ValueError ( \"Invalid marker: {marker!r} \" . format ( marker = marker )) if not isinstance ( state , bool ): raise TypeError ( 'Param state should be bool.' ) cmd = \":CALCULATE:MARKER:STATE {marker:d} , {state:d} \" self . command ( cmd ) set_marker_x ( marker , x , unit ) \u00a4 Places a specified marker in a specified position. Parameters: Name Type Description Default marker int Marker number. 1 | 2 | 3 | 4 . required x int | float The x value to put the marker. required unit str The unit of x value. \"THZ\" or \"NM\" . required Source code in pyinst\\models.py 3136 3137 3138 3139 3140 3141 3142 3143 3144 3145 3146 3147 3148 3149 def set_marker_x ( self , marker : int , x : int | float , unit : str ): \"\"\"Places a specified marker in a specified position. Args: marker: Marker number. `1` | `2` | `3` | `4`. x: The x value to put the marker. unit: The unit of x value. `\"THZ\"` or `\"NM\"`. \"\"\" if marker not in self . MARKER_NUMBERS : raise ValueError ( \"Invalid marker: {marker!r} \" . format ( marker = marker )) if unit not in [ 'NM' , 'THZ' ]: raise ValueError ( \"Invalid unit: {u!r} \" . format ( u = unit )) cmd = \":CALCulate:MARKer:X {marker:d} , {x:.6f}{unit} \" . format ( marker = marker , x = x , unit = unit ) self . command ( cmd ) set_marker_x_unit ( unit ) \u00a4 Sets the units of display for the marker values. Parameters: Name Type Description Default unit str The unit of marker X. \"WAV\" | \"FREQ\" . required Source code in pyinst\\models.py 3127 3128 3129 3130 3131 3132 3133 3134 def set_marker_x_unit ( self , unit : str ) -> None : \"\"\"Sets the units of display for the marker values. Args: unit: The unit of marker X. `\"WAV\"` | `\"FREQ\"`. \"\"\" cmd = \":CALCulate:MARKer:UNIT {unit} \" . format ( unit = unit ) self . command ( cmd ) set_peak_to_center () \u00a4 Detects the peak wavelength and sets it as the measurement center waveform. Source code in pyinst\\models.py 3209 3210 3211 3212 3213 3214 def set_peak_to_center ( self ) -> None : \"\"\"Detects the peak wavelength and sets it as the measurement center waveform. \"\"\" cmd = \":CALCulate:MARKer:MAXimum:SCENter\" self . command ( cmd ) set_peak_to_ref () \u00a4 Detects the peak level and sets it for the reference level. Source code in pyinst\\models.py 3240 3241 3242 3243 def set_peak_to_ref ( self ) -> None : \"\"\"Detects the peak level and sets it for the reference level.\"\"\" cmd = \":CALCulate:MARKer:MAXimum:SRLevel\" self . command ( cmd ) set_ref_level ( value , unit ) \u00a4 Sets the reference level of the main scale of the level axis. Parameters: Name Type Description Default value int | float The value of the ref level. required unit str The unit of the ref level. \"DBM\" | \"W\" | \"MW\" . required Source code in pyinst\\models.py 3216 3217 3218 3219 3220 3221 3222 3223 3224 3225 3226 def set_ref_level ( self , value : int | float , unit : str ) -> None : \"\"\"Sets the reference level of the main scale of the level axis. Args: value: The value of the ref level. unit: The unit of the ref level. `\"DBM\"` | `\"W\"` | `\"MW\"`. \"\"\" if unit not in [ 'DBM' , 'W' , 'MW' ]: raise ValueError ( 'Invalid unit: {unit!r} ' . format ( unit = unit )) cmd = \":DISPlay:TRACe:Y1:RLEVel {value:.6E}{unit} \" . format ( value = value , unit = unit ) self . command ( cmd ) set_resolution_bandwidth ( bandwidth , unit ) \u00a4 Sets the measurment resolution. Parameters: Name Type Description Default bandwidth int | float The resolution bandwidth. required unit str \"NM\" or \"GHZ\" . required Source code in pyinst\\models.py 3285 3286 3287 3288 3289 3290 3291 3292 3293 3294 3295 3296 def set_resolution_bandwidth ( self , bandwidth : int | float , unit : str ) -> None : # TODO: verify if only particular values can be set. \"\"\"Sets the measurment resolution. Args: bandwidth: The resolution bandwidth. unit: `\"NM\"` or `\"GHZ\"`. \"\"\" if unit not in [ \"NM\" , \"GHZ\" ]: raise TypeError ( \"Invalid unit: {unit!r} \" . format ( unit = unit )) cmd = \":SENSe:BANDwidth {bandwidth:.6f}{unit} \" . format ( bandwidth = bandwidth , unit = unit ) self . command ( cmd ) set_smsr_analysis_mask ( mask ) \u00a4 Set the mask value for the SMSR analysis function. Parameters: Name Type Description Default mask int | float The mask value in nm. required Source code in pyinst\\models.py 2738 2739 2740 2741 2742 2743 2744 2745 def set_smsr_analysis_mask ( self , mask : int | float ) -> None : \"\"\"Set the mask value for the SMSR analysis function. Args: mask: The mask value in nm. \"\"\" cmd = \":CALCulate:PARameter:SMSR:MASK {mask:.2f} NM\" . format ( mask = mask ) self . command ( cmd ) set_smsr_analysis_mode ( mode ) \u00a4 Sets the analysis mode for the SMSR analysis function. Parameters: Name Type Description Default mode str The analysis mode, SMSR1 | SMSR2 | SMSR3 | SMSR4 . required Source code in pyinst\\models.py 2757 2758 2759 2760 2761 2762 2763 2764 2765 2766 2767 def set_smsr_analysis_mode ( self , mode : str ) -> None : \"\"\"Sets the analysis mode for the SMSR analysis function. Args: mode: The analysis mode, `SMSR1`|`SMSR2`|`SMSR3`|`SMSR4`. \"\"\" options = [ \"SMSR1\" , \"SMSR2\" , \"SMSR3\" , \"SMSR4\" ] if mode not in options : raise ValueError ( \"Invalid option for mode: {mode!r} \" . format ( mode = mode )) cmd = \":CALCulate:PARameter:SMSR:MODE {mode} \" . format ( mode = mode ) self . command ( cmd ) set_span ( value , unit ) \u00a4 Sets the measurement condition measurement span. Parameters: Name Type Description Default value int | float The value of measurement span. required unit str \"NM\" or \"GHZ\" . required Source code in pyinst\\models.py 2960 2961 2962 2963 2964 2965 2966 2967 2968 2969 2970 def set_span ( self , value : int | float , unit : str ) -> None : \"\"\"Sets the measurement condition measurement span. Args: value: The value of measurement span. unit: `\"NM\"` or `\"GHZ\"`. \"\"\" if unit not in self . WL_SPAN_UNITS : raise ValueError ( \"Invalid option for unit: {unit!r} \" . format ( unit = unit )) cmd = \":SENSe:WAVelengthSPAN {value:.2f}{unit} \" . format ( value = value , unit = unit ) return self . command ( cmd ) set_start_frequency ( frequency ) \u00a4 Queries the measurement condition measurement start frequency in THz. Parameters: Name Type Description Default frequency int | float The start frequency in THz. required Source code in pyinst\\models.py 3051 3052 3053 3054 3055 3056 3057 3058 3059 3060 3061 def set_start_frequency ( self , frequency : int | float ) -> None : \"\"\"Queries the measurement condition measurement start frequency in THz. Args: frequency: The start frequency in THz. \"\"\" if \"FREQ\" == self . get_x_unit (): cmd = \":SENSe:WAVelength:STOP {freq:.6f} THZ\" . format ( freq = frequency ) self . command ( cmd ) else : self . set_stop_wavelength ( LIGHTSPEED / frequency ) set_start_wavelength ( wavelength ) \u00a4 Sets the measurement condition measurement start wavelength in nm. Parameters: Name Type Description Default wavelength int | float The start wavelength in nm. required Source code in pyinst\\models.py 3001 3002 3003 3004 3005 3006 3007 3008 3009 3010 3011 def set_start_wavelength ( self , wavelength : int | float ) -> None : \"\"\"Sets the measurement condition measurement start wavelength in nm. Args: wavelength: The start wavelength in nm. \"\"\" if \"WAV\" == self . get_x_unit (): cmd = \":SENSe:WAVelength:STARt {wl:.6f} NM\" . format ( wl = wavelength ) self . command ( cmd ) else : self . set_stop_frequency ( LIGHTSPEED / wavelength ) set_stop_frequency ( frequency ) \u00a4 Queries the measurement condition measurement stop frequency in THz. Parameters: Name Type Description Default frequency int | float The stop frequency in THz. required Source code in pyinst\\models.py 3076 3077 3078 3079 3080 3081 3082 3083 3084 3085 3086 def set_stop_frequency ( self , frequency : int | float ) -> None : \"\"\"Queries the measurement condition measurement stop frequency in THz. Args: frequency: The stop frequency in THz. \"\"\" if \"FREQ\" == self . get_x_unit (): cmd = \":SENSe:WAVelength:STARt {freq:.6f} THZ\" . format ( freq = frequency ) self . command ( cmd ) else : self . set_start_wavelength ( LIGHTSPEED / frequency ) set_stop_wavelength ( wavelength ) \u00a4 Sets the measurement condition measurement stop wavelength in nm. Parameters: Name Type Description Default wavelength int | float The stop wavelength in nm. required Source code in pyinst\\models.py 3026 3027 3028 3029 3030 3031 3032 3033 3034 3035 3036 def set_stop_wavelength ( self , wavelength : int | float ) -> None : \"\"\"Sets the measurement condition measurement stop wavelength in nm. Args: wavelength: The stop wavelength in nm. \"\"\" if \"WAV\" == self . get_x_unit (): cmd = \":SENSe:WAVelength:STOP {wl:.6f} NM\" . format ( wl = wavelength ) self . command ( cmd ) else : self . set_start_frequency ( LIGHTSPEED / wavelength ) set_swthresh_analysis_k ( k ) \u00a4 Sets the magnification of the THRESH method-based spectrum width analysis function. Parameters: Name Type Description Default k int | float The magnification. required Source code in pyinst\\models.py 2834 2835 2836 2837 2838 2839 2840 2841 2842 def set_swthresh_analysis_k ( self , k : int | float ) -> None : \"\"\"Sets the magnification of the THRESH method-based spectrum width analysis function. Args: k: The magnification. \"\"\" cmd = \":CALCulate:PARameter:SWTHResh:K {k:.2f} \" . format ( k = k ) self . command ( cmd ) set_swthresh_analysis_mfit ( en ) \u00a4 Sets whether to enable the mode fit of the THRESH method-based spectrum width analysis function. Parameters: Name Type Description Default en bool Whether to enable the mode fit. required Source code in pyinst\\models.py 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 def set_swthresh_analysis_mfit ( self , en : bool ) -> None : \"\"\"Sets whether to enable the mode fit of the THRESH method-based spectrum width analysis function. Args: en: Whether to enable the mode fit. \"\"\" if not isinstance ( en , bool ): raise TypeError ( \"Param en should be bool.\" ) cmd = \":CALCulate:PARameter:SWTHresh:MFIT {en:d} \" . format ( en = en ) self . command ( cmd ) set_swthresh_analysis_th ( th ) \u00a4 Sets the threshold level of the THRESH method-based spectrum width analysis function. Parameters: Name Type Description Default th int | float The threshold level in dB. required Source code in pyinst\\models.py 2878 2879 2880 2881 2882 2883 2884 2885 2886 def set_swthresh_analysis_th ( self , th : int | float ) -> None : \"\"\"Sets the threshold level of the THRESH method-based spectrum width analysis function. Args: th: The threshold level in dB. \"\"\" cmd = \":CALCulate:PARameter:SWTHresh:TH {th:.2f} DB\" . format ( th = th ) self . command ( cmd ) set_trace_attribute ( trace_name , attribute ) \u00a4 Sets the attributes of the specified trace. Parameters: Name Type Description Default trace_name str TRA | TRB | TRC | TRD | TRE | TRF | TRG required attribute str WRIT | FIX | MAX | MIN | RAVG | CALC required Source code in pyinst\\models.py 3323 3324 3325 3326 3327 3328 3329 3330 3331 3332 3333 3334 3335 def set_trace_attribute ( self , trace_name : str , attribute : str ) -> None : \"\"\"Sets the attributes of the specified trace. Args: trace_name: `TRA` | `TRB` | `TRC` | `TRD` | `TRE` | `TRF` | `TRG` attribute: `WRIT` | `FIX` | `MAX` | `MIN` | `RAVG` | `CALC` \"\"\" if trace_name not in [ 'TRA' , 'TRB' , 'TRC' , 'TRD' , 'TRE' , 'TRF' , 'TRG' ]: raise ValueError ( 'Invalid trace_name: {name!r} ' . format ( name = trace_name )) if attribute not in [ 'WRIT' , 'FIX' , 'MAX' , 'MIN' , 'RAVG' , 'CALC' ]: raise ValueError ( 'Invalid attribute: {attr!r} ' . format ( attr = attribute )) cmd = ':TRACe:ATTRibute: {trace} {attribute} ' . format ( trace = trace_name , attribute = attribute ) self . command ( cmd ) set_trace_display_status ( trace_name , display ) \u00a4 Sets the display status of the specified trace. Parameters: Name Type Description Default trace_name str TRA | TRB | TRC | TRD | TRE | TRF | TRG required display bool Whether to display the trace. required Source code in pyinst\\models.py 3350 3351 3352 3353 3354 3355 3356 3357 3358 3359 3360 3361 3362 def set_trace_display_status ( self , trace_name : str , display : bool ) -> None : \"\"\"Sets the display status of the specified trace. Args: trace_name: `TRA` | `TRB` | `TRC` | `TRD` | `TRE` | `TRF` | `TRG` display: Whether to display the trace. \"\"\" if trace_name not in [ 'TRA' , 'TRB' , 'TRC' , 'TRD' , 'TRE' , 'TRF' , 'TRG' ]: raise ValueError ( 'Invalid trace_name: {name!r} ' . format ( name = trace_name )) if not isinstance ( display , bool ): raise TypeError ( 'Parameter display must be bool type.' ) cmd = ':TRACe:STATe: {trace_name} {display:d} ' . format ( trace_name = trace_name , display = display ) self . command ( cmd ) set_wdm_analysis_dmask ( dmask ) \u00a4 Sets the channel mask threshold level for the WDM analysis function. Parameters: Name Type Description Default dmask int | float The channel mask threshold level in dB. required Source code in pyinst\\models.py 2570 2571 2572 2573 2574 2575 2576 2577 2578 def set_wdm_analysis_dmask ( self , dmask : int | float ) -> None : \"\"\" Sets the channel mask threshold level for the WDM analysis function. Args: dmask: The channel mask threshold level in dB. \"\"\" cmd = \":CALCulate:PARameter:WDM:DMASk {dmask:.2f} DB\" . format ( dmask = dmask ) self . command ( cmd ) set_wdm_analysis_falgo ( algo ) \u00a4 Sets the fitting function during level measurement applied to noise level measurements made by the WDM analysis function. Options of algorithms: LIN = LINEAR GAUS = GAUSS LOR = LORENZ 3RD = 3RD POLY 4TH = 4YH POLY 5TH = 5TH POLY Parameters: Name Type Description Default algo str The name of the algorithm. Refer to options above. required Source code in pyinst\\models.py 2676 2677 2678 2679 2680 2681 2682 2683 2684 2685 2686 2687 2688 2689 2690 2691 2692 2693 2694 2695 2696 def set_wdm_analysis_falgo ( self , algo : str ) -> None : \"\"\"Sets the fitting function during level measurement applied to noise level measurements made by the WDM analysis function. Options of algorithms: - `LIN` = LINEAR - `GAUS` = GAUSS - `LOR` = LORENZ - `3RD` = 3RD POLY - `4TH` = 4YH POLY - `5TH` = 5TH POLY Args: algo: The name of the algorithm. Refer to options above. \"\"\" algo_options = [ \"LIN\" , \"GAUS\" , \"LOR\" , \"3RD\" , \"4TH\" , \"5TH\" ] if algo . upper () not in algo_options : raise ValueError ( \"Invalid value for algo: {value!r} \" . format ( value = algo )) cmd = \":CALCulate:PARameter:WDM:FALGo {algo} \" . format ( algo = algo ) self . command ( cmd ) set_wdm_analysis_marea ( marea ) \u00a4 Sets the mask range during level measurement applied to noise level measurements made by the WDM analysis function. Parameters: Name Type Description Default marea int | float The mask range in nm. required Source code in pyinst\\models.py 2655 2656 2657 2658 2659 2660 2661 2662 2663 def set_wdm_analysis_marea ( self , marea : int | float ) -> None : \"\"\"Sets the mask range during level measurement applied to noise level measurements made by the WDM analysis function. Args: marea: The mask range in nm. \"\"\" cmd = \":CALCulate:PARameter:WDM:MARea {marea:.2f} NM\" . format ( marea = marea ) self . command ( cmd ) set_wdm_analysis_mdiff ( mdiff ) \u00a4 Sets the peak bottom difference of channel detection for the WDM analysis function. Parameters: Name Type Description Default mdiff int | float The peak-bottom difference in dB. required Source code in pyinst\\models.py 2547 2548 2549 2550 2551 2552 2553 2554 2555 2556 def set_wdm_analysis_mdiff ( self , mdiff : int | float ) -> None : \"\"\" Sets the peak bottom difference of channel detection for the WDM analysis function. Args: mdiff: The peak-bottom difference in dB. \"\"\" cmd = \":CALCulate:PARameter:WDM:MDIFf {mdiff:.2f} DB\" . format ( mdiff = mdiff ) self . command ( cmd ) set_wdm_analysis_nalgo ( algo ) \u00a4 Sets the measurement algorithm applied to noise level measurements made by the WDM analysis function. Options of algorithms: AFIX = AUTO FIX MFIX = MANUAL FIX ACEN = AUTO CENTER MCEN = MANUAL CENTER PIT = PIT Parameters: Name Type Description Default algo str The name of algorithm. Refer to options above. required Source code in pyinst\\models.py 2591 2592 2593 2594 2595 2596 2597 2598 2599 2600 2601 2602 2603 2604 2605 2606 2607 2608 2609 2610 2611 def set_wdm_analysis_nalgo ( self , algo : str ) -> None : \"\"\" Sets the measurement algorithm applied to noise level measurements made by the WDM analysis function. Options of algorithms: - `AFIX` = AUTO FIX - `MFIX` = MANUAL FIX - `ACEN` = AUTO CENTER - `MCEN` = MANUAL CENTER - `PIT` = PIT Args: algo: The name of algorithm. Refer to options above. \"\"\" algo_options = [ \"AFIX\" , \"MFIX\" , \"ACEN\" , \"MCEN\" , \"PIT\" ] if algo . upper () not in algo_options : raise ValueError ( \"Invalid value for algo: {value!r} \" . format ( value = algo )) cmd = \":CALCulate:PARameter:WDM:NALGo {algo} \" . format ( algo = algo ) self . command ( cmd ) set_wdm_analysis_narea ( narea ) \u00a4 Sets the measuring range applied to noise level measurements made by the WDM analysis function. Parameters: Name Type Description Default narea int | float The range in nm. required Source code in pyinst\\models.py 2634 2635 2636 2637 2638 2639 2640 2641 2642 def set_wdm_analysis_narea ( self , narea : int | float ) -> None : \"\"\"Sets the measuring range applied to noise level measurements made by the WDM analysis function. Args: narea: The range in nm. \"\"\" cmd = \":CALCulate:PARameter:WDM:NARea {narea:.2f} NM\" . format ( narea = narea ) self . command ( cmd ) set_wdm_analysis_parameter_nbw ( nbw ) \u00a4 Sets the noise bandwidth for the WDM analysis function. Parameters: Name Type Description Default nbw int | float The noise bandwidth in nm. required Source code in pyinst\\models.py 2719 2720 2721 2722 2723 2724 2725 2726 def set_wdm_analysis_parameter_nbw ( self , nbw : int | float ) -> None : \"\"\"Sets the noise bandwidth for the WDM analysis function. Args: nbw: The noise bandwidth in nm. \"\"\" cmd = \":CALCulate:PARameter:WDM:NBW {nbw:.2f} NM\" . format ( nbw = nbw ) self . command ( cmd ) set_wdm_analysis_threshold ( threshold ) \u00a4 Set the threshold level of channel detection for the WDM analysis function. Parameters: Name Type Description Default threshold int | float The threshold level value in dB. required Source code in pyinst\\models.py 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 def set_wdm_analysis_threshold ( self , threshold : int | float ) -> None : \"\"\" Set the threshold level of channel detection for the WDM analysis function. Args: threshold: The threshold level value in dB. \"\"\" cmd = \":CALCulate:PARameter:WDM:TH {th:.2f} DB\" . format ( th = threshold ) self . command ( cmd ) set_x_unit ( unit ) \u00a4 Sets the units for the X axis. Parameters: Name Type Description Default unit str \"WAV\" | \"FREQ\" . \"WAV\" = Wavelength, \"FREQ\" = Frequency required Source code in pyinst\\models.py 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 def set_x_unit ( self , unit : str ): \"\"\"Sets the units for the X axis. Args: unit: `\"WAV\"` | `\"FREQ\"`. `\"WAV\"` = Wavelength, `\"FREQ\"` = Frequency \"\"\" cmd = \":UNIT:X {unit} \" . format ( unit ) self . command ( cmd ) set_y_scale_mode ( mode ) \u00a4 Sets the scale mode of the main scale of the level axis. Parameters: Name Type Description Default mode str The scale mode of level axis. \"LOG\" = Logarighmic, \"LIN\" = Linear. required Source code in pyinst\\models.py 3186 3187 3188 3189 3190 3191 3192 3193 3194 3195 3196 def set_y_scale_mode ( self , mode : str ) -> None : \"\"\"Sets the scale mode of the main scale of the level axis. Args: mode: The scale mode of level axis. `\"LOG\"` = Logarighmic, `\"LIN\"` = Linear. \"\"\" if mode not in ( \"LOG\" , \"LIN\" ): raise ValueError ( \"Invalid mode: {mode!r} \" . format ( mode = mode )) cmd = \":DISPlay:TRACe:Y1:SPACing {mode} \" . format ( mode = mode ) self . command ( cmd ) single () \u00a4 Makes a SINGLE sweep. Refer to sweep for more information. Source code in pyinst\\models.py 2459 2460 2461 def single ( self ) -> None : \"\"\"Makes a SINGLE sweep. Refer to `sweep` for more information.\"\"\" self . command ( ':INIT:SMOD SINGLE;:INIT' ) stop () \u00a4 Stops sweep. Source code in pyinst\\models.py 2455 2456 2457 def stop ( self ) -> None : \"\"\"Stops sweep.\"\"\" self . command ( ':ABOR' ) sweep ( mode = 'REPEAT' ) \u00a4 Sets the sweep mode and makes a sweep. For information about the sweep modes, please refer to documentation of the instrument. Parameters: Name Type Description Default mode str Sweep mode. \"AUTO\" | \"REPEAT\" | \"SINGLE\" | \"STOP\" . 'REPEAT' Source code in pyinst\\models.py 2436 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 2447 2448 2449 def sweep ( self , mode : str = \"REPEAT\" ) -> None : \"\"\"Sets the sweep mode and makes a sweep. For information about the sweep modes, please refer to documentation of the instrument. Args: mode: Sweep mode. `\"AUTO\"` | `\"REPEAT\"` | `\"SINGLE\"` | `\"STOP\"`. \"\"\" options = [ \"AUTO\" , \"REPEAT\" , \"SINGLE\" , \"STOP\" ] if mode not in options : raise ValueError ( \"Invalid value for param mode: {value} \" . format ( value = mode )) if mode == \"STOP\" : self . command ( ':ABOR' ) else : self . command ( ':INIT:SMOD {mode} ;:INIT' . format ( mode = mode )) zero_once () \u00a4 Perform offset adjustment once and wait until adjustment complete. TODO: should stopped? Source code in pyinst\\models.py 2476 2477 2478 2479 2480 2481 2482 def zero_once ( self ): \"\"\"Perform offset adjustment once and wait until adjustment complete. TODO: should stopped?\"\"\" self . command ( \":CALibration:ZERO ONCE\" ) while True : being_executed = int ( self . query ( \":CALibration:ZERO:STATus?\" )) if not being_executed : break ModelATS535 \u00a4 Bases: VisaInstrument , TypeTS ATS-535 is a thermo-stream model by Temptronic. Note that before operating with temperature directly (means not in Cycle mode), you should set the thermo-stream to the Operator screen, and make sure the test head is lower down, and the air flow is on. Examples: ts = ModelATS535 ( '<resource-name>' ) ts . reset_operator () # check the test head is down if not ts . is_head_down (): raise OperationalError ( 'The thermo-stream test head is up.' ) # turn on the air flow ts . flow () # operate with the temperature directly ts . set_target_temp ( 35 ) t = ts . get_current_temp () Source code in pyinst\\models.py 3753 3754 3755 3756 3757 3758 3759 3760 3761 3762 3763 3764 3765 3766 3767 3768 3769 3770 3771 3772 3773 3774 3775 3776 3777 3778 3779 3780 3781 3782 3783 3784 3785 3786 3787 3788 3789 3790 3791 3792 3793 3794 3795 3796 3797 3798 3799 3800 3801 3802 3803 3804 3805 3806 3807 3808 3809 3810 3811 3812 3813 3814 3815 3816 3817 3818 3819 3820 3821 3822 3823 3824 3825 3826 3827 3828 3829 3830 3831 3832 3833 3834 3835 3836 3837 3838 3839 3840 3841 3842 3843 3844 3845 3846 3847 3848 3849 3850 3851 3852 3853 3854 3855 3856 3857 3858 3859 3860 3861 3862 3863 3864 3865 3866 3867 3868 3869 3870 3871 3872 3873 3874 3875 3876 3877 3878 3879 3880 3881 3882 3883 3884 3885 3886 3887 3888 3889 3890 3891 3892 3893 3894 3895 3896 3897 3898 3899 3900 3901 3902 3903 3904 3905 3906 3907 3908 3909 3910 3911 3912 3913 3914 3915 3916 class ModelATS535 ( VisaInstrument , TypeTS ): \"\"\"ATS-535 is a thermo-stream model by Temptronic. Note that before operating with temperature directly (means not in Cycle mode), you should set the thermo-stream to the Operator screen, and make sure the test head is lower down, and the air flow is on. Examples: ```python ts = ModelATS535('<resource-name>') ts.reset_operator() # check the test head is down if not ts.is_head_down(): raise OperationalError('The thermo-stream test head is up.') # turn on the air flow ts.flow() # operate with the temperature directly ts.set_target_temp(35) t = ts.get_current_temp() ``` \"\"\" model = \"ATS-535\" brand = \"Temptronic\" def __init__ ( self , resource_name , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. **kwargs: directly passed to `VisaInstrument.__init__` \"\"\" super ( ModelATS535 , self ) . __init__ ( resource_name , ** kwargs ) @property def ts_type ( self ) -> TemperatureSourceType : return TemperatureSourceType . THERMO_STREAM def head_up ( self ) -> None : \"\"\"Raise up the test head.\"\"\" self . command ( 'HEAD 0' ) def head_down ( self ) -> None : \"\"\"Lower down the test head.\"\"\" self . command ( 'HEAD 1' ) def is_head_down ( self ) -> bool : \"\"\"Queries if the test head is lowered down. Returns: If the test head is lowered down. \"\"\" is_down = bool ( int ( self . query ( 'HEAD?' ))) return is_down def flow ( self , on : bool = True ) -> None : \"\"\"Turn the main nozzle air flow on or off. Args: on: `True` = turn on, `False` = turn off. \"\"\" cmd = 'FLOW {:d} ' . format ( on ) self . command ( cmd ) def enable_dut_mode ( self , en : bool = True ) -> None : \"\"\"Enable (disable) DUT mode. Args: en: True = DUT mode on (DUT control); False = DUT mode off (air control). \"\"\" if not isinstance ( en , bool ): raise TypeError ( 'Parameter en must be bool type.' ) cmd = 'DUTM {en:d} ' . format ( en = en ) self . command ( cmd ) def is_dut_mode ( self ) -> bool : \"\"\"Queries if DUT mode is on. Returns: True = DUT mode on (DUT control); False = DUT mode off (air control). \"\"\" state = bool ( int ( self . query ( 'DUTM?' ))) return state def disable_dut_mode ( self ) -> None : \"\"\"Disable DUT mode.\"\"\" self . enable_dut_mode ( False ) def reset_operator ( self ) -> None : \"\"\"Reset (force) the System to the Operator screen.\"\"\" self . command ( 'RSTO' ) time . sleep ( 0.3 ) def set_ramp ( self ) -> None : \"\"\"Enter Ramp/Cycle.\"\"\" self . command ( 'RMPC 1' ) def set_n ( self , n : int ) -> None : \"\"\"Select a setpoint to be the current setpoint. Args: n: - n is 0 - 17 when on the Cycle screen. - n is 0 to 2 when on the Operator screen (0=hot, 1=ambient, 2=cold). \"\"\" return self . command ( 'SETN %d ' % n ) def set_p ( self , p : int | float ) -> None : \"\"\"Set the currently selected setpoint's temperature.\"\"\" return self . command ( 'SETP %.1f ' % p ) def get_p_setting ( self ) -> float : \"\"\"Read the current temperature setpoint.\"\"\" p = float ( self . query ( 'SETP?' )) return p def set_ramp ( self , ramp : int | float ) -> None : \"\"\"Set the ramp rate for the currently selected setpoint, in \u00b0C per minute. Args: ramp: The ramp rate in \u00b0C per minute. \"\"\" if 0 <= ramp <= 99.9 : t = ' {:.1f} ' . format ( ramp ) elif 99.9 < ramp <= 9999 : t = ' {:d} ' . format ( ramp ) else : raise ValueError ( 'Parameter ramp out of range.' ) return self . command ( 'RAMP {} ' . format ( t )) def get_ramp ( self ) -> float : \"\"\"Read the setting of RAMP. Returns: The ramp rate in \u00b0C per minute. \"\"\" cmd = 'RAMP?' ramp = float ( self . query ( cmd )) return ramp def set_target_temp ( self , value : int | float ) -> None : if value < 20 : n = 2 elif 20 <= value <= 30 : n = 1 else : n = 0 self . set_n ( n ) self . set_p ( value ) def get_target_temp ( self ) -> float : return self . get_p_setting () def get_current_temp ( self ) -> float : temp = float ( self . query ( 'TEMP?' )) if temp > 400 : raise ValueError ( 'Invalid current temperature.' ) return temp def set_temp_unit ( self , unit : TemperatureUnit ) -> None : if unit != TemperatureUnit . C : raise ValueError ( 'The temperature unit of this thermo-stream is fixed to C.' ) def get_temp_unit ( self ) -> TemperatureUnit : return TemperatureUnit . C __init__ ( resource_name , ** kwargs ) \u00a4 Parameters: Name Type Description Default resource_name Resource name or alias of the VISA resource to open. required **kwargs directly passed to VisaInstrument.__init__ {} Source code in pyinst\\models.py 3777 3778 3779 3780 3781 3782 3783 def __init__ ( self , resource_name , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. **kwargs: directly passed to `VisaInstrument.__init__` \"\"\" super ( ModelATS535 , self ) . __init__ ( resource_name , ** kwargs ) disable_dut_mode () \u00a4 Disable DUT mode. Source code in pyinst\\models.py 3835 3836 3837 def disable_dut_mode ( self ) -> None : \"\"\"Disable DUT mode.\"\"\" self . enable_dut_mode ( False ) enable_dut_mode ( en = True ) \u00a4 Enable (disable) DUT mode. Parameters: Name Type Description Default en bool True = DUT mode on (DUT control); False = DUT mode off (air control). True Source code in pyinst\\models.py 3815 3816 3817 3818 3819 3820 3821 3822 3823 3824 def enable_dut_mode ( self , en : bool = True ) -> None : \"\"\"Enable (disable) DUT mode. Args: en: True = DUT mode on (DUT control); False = DUT mode off (air control). \"\"\" if not isinstance ( en , bool ): raise TypeError ( 'Parameter en must be bool type.' ) cmd = 'DUTM {en:d} ' . format ( en = en ) self . command ( cmd ) flow ( on = True ) \u00a4 Turn the main nozzle air flow on or off. Parameters: Name Type Description Default on bool True = turn on, False = turn off. True Source code in pyinst\\models.py 3806 3807 3808 3809 3810 3811 3812 3813 def flow ( self , on : bool = True ) -> None : \"\"\"Turn the main nozzle air flow on or off. Args: on: `True` = turn on, `False` = turn off. \"\"\" cmd = 'FLOW {:d} ' . format ( on ) self . command ( cmd ) get_p_setting () \u00a4 Read the current temperature setpoint. Source code in pyinst\\models.py 3862 3863 3864 3865 def get_p_setting ( self ) -> float : \"\"\"Read the current temperature setpoint.\"\"\" p = float ( self . query ( 'SETP?' )) return p get_ramp () \u00a4 Read the setting of RAMP. Returns: Type Description float The ramp rate in \u00b0C per minute. Source code in pyinst\\models.py 3882 3883 3884 3885 3886 3887 3888 3889 3890 def get_ramp ( self ) -> float : \"\"\"Read the setting of RAMP. Returns: The ramp rate in \u00b0C per minute. \"\"\" cmd = 'RAMP?' ramp = float ( self . query ( cmd )) return ramp head_down () \u00a4 Lower down the test head. Source code in pyinst\\models.py 3793 3794 3795 def head_down ( self ) -> None : \"\"\"Lower down the test head.\"\"\" self . command ( 'HEAD 1' ) head_up () \u00a4 Raise up the test head. Source code in pyinst\\models.py 3789 3790 3791 def head_up ( self ) -> None : \"\"\"Raise up the test head.\"\"\" self . command ( 'HEAD 0' ) is_dut_mode () \u00a4 Queries if DUT mode is on. Returns: Type Description bool True = DUT mode on (DUT control); False = DUT mode off (air control). Source code in pyinst\\models.py 3826 3827 3828 3829 3830 3831 3832 3833 def is_dut_mode ( self ) -> bool : \"\"\"Queries if DUT mode is on. Returns: True = DUT mode on (DUT control); False = DUT mode off (air control). \"\"\" state = bool ( int ( self . query ( 'DUTM?' ))) return state is_head_down () \u00a4 Queries if the test head is lowered down. Returns: Type Description bool If the test head is lowered down. Source code in pyinst\\models.py 3797 3798 3799 3800 3801 3802 3803 3804 def is_head_down ( self ) -> bool : \"\"\"Queries if the test head is lowered down. Returns: If the test head is lowered down. \"\"\" is_down = bool ( int ( self . query ( 'HEAD?' ))) return is_down reset_operator () \u00a4 Reset (force) the System to the Operator screen. Source code in pyinst\\models.py 3839 3840 3841 3842 def reset_operator ( self ) -> None : \"\"\"Reset (force) the System to the Operator screen.\"\"\" self . command ( 'RSTO' ) time . sleep ( 0.3 ) set_n ( n ) \u00a4 Select a setpoint to be the current setpoint. Parameters: Name Type Description Default n int n is 0 - 17 when on the Cycle screen. n is 0 to 2 when on the Operator screen (0=hot, 1=ambient, 2=cold). required Source code in pyinst\\models.py 3848 3849 3850 3851 3852 3853 3854 3855 3856 def set_n ( self , n : int ) -> None : \"\"\"Select a setpoint to be the current setpoint. Args: n: - n is 0 - 17 when on the Cycle screen. - n is 0 to 2 when on the Operator screen (0=hot, 1=ambient, 2=cold). \"\"\" return self . command ( 'SETN %d ' % n ) set_p ( p ) \u00a4 Set the currently selected setpoint's temperature. Source code in pyinst\\models.py 3858 3859 3860 def set_p ( self , p : int | float ) -> None : \"\"\"Set the currently selected setpoint's temperature.\"\"\" return self . command ( 'SETP %.1f ' % p ) set_ramp ( ramp ) \u00a4 Set the ramp rate for the currently selected setpoint, in \u00b0C per minute. Parameters: Name Type Description Default ramp int | float The ramp rate in \u00b0C per minute. required Source code in pyinst\\models.py 3867 3868 3869 3870 3871 3872 3873 3874 3875 3876 3877 3878 3879 3880 def set_ramp ( self , ramp : int | float ) -> None : \"\"\"Set the ramp rate for the currently selected setpoint, in \u00b0C per minute. Args: ramp: The ramp rate in \u00b0C per minute. \"\"\" if 0 <= ramp <= 99.9 : t = ' {:.1f} ' . format ( ramp ) elif 99.9 < ramp <= 9999 : t = ' {:d} ' . format ( ramp ) else : raise ValueError ( 'Parameter ramp out of range.' ) return self . command ( 'RAMP {} ' . format ( t )) ModelE3631A \u00a4 Bases: VisaInstrument , TypePS Source code in pyinst\\models.py 4566 4567 4568 4569 4570 4571 4572 4573 4574 4575 4576 4577 4578 4579 4580 4581 4582 4583 4584 4585 4586 4587 4588 4589 4590 4591 4592 4593 4594 4595 4596 4597 4598 4599 4600 4601 4602 4603 4604 4605 4606 4607 4608 4609 4610 4611 4612 4613 4614 4615 4616 4617 4618 4619 4620 4621 4622 4623 4624 4625 4626 4627 4628 4629 4630 4631 4632 4633 4634 4635 4636 4637 4638 4639 4640 4641 4642 4643 4644 4645 4646 4647 4648 4649 4650 4651 4652 4653 4654 4655 4656 4657 4658 4659 4660 4661 4662 4663 4664 4665 4666 4667 4668 4669 4670 4671 4672 4673 4674 4675 4676 4677 4678 4679 4680 4681 4682 4683 4684 4685 4686 4687 4688 4689 4690 4691 4692 class ModelE3631A ( VisaInstrument , TypePS ): model = \"E3631A\" brand = \"Keysight\" details = { \"Power Supply Range\" : \"Port 1: 6V, 5A; Port 2: 25V, 1A; Port 3: -25V, 1A\" } params = [ { \"name\" : \"port\" , \"type\" : \"int\" , \"options\" : [ 1 , 2 , 3 ] } ] def __init__ ( self , resource_name : str , port : int , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. port: The port number among three output ports. - `1`: +6V - `2`: +25V - `3`: -25V kwargs: directly passed to `VisaInstrument.__init__`. \"\"\" super () . __init__ ( resource_name , ** kwargs ) if port not in { 1 , 2 , 3 }: raise ValueError ( f \"Invalid parameter port: { port !r} \" ) self . __port = port def __select_port ( func : Callable ) -> Callable : @wraps ( func ) def wrapper ( self , * args , ** kwargs ): cmd = f \":INSTrument:NSELect { self . port : d } \" self . command ( cmd ) return func ( self , * args , ** kwargs ) return wrapper @property def port ( self ): \"\"\"The selected port number among three output ports.\"\"\" return self . __port @property @__select_port def min_voltage ( self ): cmd = \":VOLTage? MIN\" v = float ( self . query ( cmd )) return v @property @__select_port def max_voltage ( self ): cmd = \":VOLTage? MAX\" v = float ( self . query ( cmd )) return v @property @__select_port def min_current ( self ): cmd = \":CURRent? MIN\" i = float ( self . query ( cmd )) return i @property @__select_port def max_current ( self ): cmd = \":CURRent? MAX\" i = float ( self . query ( cmd )) return i @__select_port def enable ( self , en : bool = True ) -> None : if not isinstance ( en , bool ): raise TypeError ( 'Parameter en must be bool type.' ) cmd = f ':OUTPut { [ \"OFF\" , \"ON\" ][ int ( en )] } ' self . command ( cmd ) def disable ( self ) -> None : self . enable ( False ) @__select_port def is_enabled ( self ) -> bool : cmd = \":OUTPut?\" status = bool ( int ( self . query ( cmd ))) return status @__select_port def set_voltage_limit ( self , value : int | float ) -> None : if not 0 <= value <= self . max_voltage : raise ValueError ( f \"The voltage limit value out of range: { value !r} \" ) cmd = f \":VOLTage { value : .4f } \" self . command ( cmd ) @__select_port def get_voltage_limit ( self ) -> float : cmd = \":VOLTage?\" v = float ( self . query ( cmd )) return v @__select_port def measure_voltage ( self ) -> float : cmd = \":MEASure:VOLTage?\" v = float ( self . query ( cmd )) return v @__select_port def set_current_limit ( self , value : int | float ) -> None : if not 0 <= value <= self . max_current : raise ValueError ( f \"The current limit value out of range: { value !r} \" ) cmd = f \":CURRent { value : .4f } \" self . command ( cmd ) @__select_port def get_current_limit ( self ) -> float : cmd = \":CURRent?\" i = float ( self . command ( cmd )) return i @__select_port def measure_current ( self ) -> float : cmd = \":MEASure:CURRent?\" i = float ( self . command ( cmd )) return i __init__ ( resource_name , port , ** kwargs ) \u00a4 Parameters: Name Type Description Default resource_name str Resource name or alias of the VISA resource to open. required port int The port number among three output ports. - 1 : +6V - 2 : +25V - 3 : -25V required kwargs directly passed to VisaInstrument.__init__ . required Source code in pyinst\\models.py 4584 4585 4586 4587 4588 4589 4590 4591 4592 4593 4594 4595 4596 4597 def __init__ ( self , resource_name : str , port : int , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. port: The port number among three output ports. - `1`: +6V - `2`: +25V - `3`: -25V kwargs: directly passed to `VisaInstrument.__init__`. \"\"\" super () . __init__ ( resource_name , ** kwargs ) if port not in { 1 , 2 , 3 }: raise ValueError ( f \"Invalid parameter port: { port !r} \" ) self . __port = port port () property \u00a4 The selected port number among three output ports. Source code in pyinst\\models.py 4607 4608 4609 4610 @property def port ( self ): \"\"\"The selected port number among three output ports.\"\"\" return self . __port ModelE3633A \u00a4 Bases: VisaInstrument , TypePSwithOvpOcpFunctions Source code in pyinst\\models.py 4695 4696 4697 4698 4699 4700 4701 4702 4703 4704 4705 4706 4707 4708 4709 4710 4711 4712 4713 4714 4715 4716 4717 4718 4719 4720 4721 4722 4723 4724 4725 4726 4727 4728 4729 4730 4731 4732 4733 4734 4735 4736 4737 4738 4739 4740 4741 4742 4743 4744 4745 4746 4747 4748 4749 4750 4751 4752 4753 4754 4755 4756 4757 4758 4759 4760 4761 4762 4763 4764 4765 4766 4767 4768 4769 4770 4771 4772 4773 4774 4775 4776 4777 4778 4779 4780 4781 4782 4783 4784 4785 4786 4787 4788 4789 4790 4791 4792 4793 4794 4795 4796 4797 4798 4799 4800 4801 4802 4803 4804 4805 4806 4807 4808 4809 4810 4811 4812 4813 4814 4815 4816 4817 4818 4819 4820 4821 4822 4823 4824 4825 4826 4827 4828 4829 4830 4831 4832 4833 4834 4835 4836 4837 4838 4839 4840 4841 4842 4843 4844 4845 4846 4847 4848 4849 4850 4851 4852 4853 4854 4855 4856 4857 4858 4859 4860 4861 4862 4863 4864 4865 4866 4867 4868 4869 class ModelE3633A ( VisaInstrument , TypePSwithOvpOcpFunctions ): model = \"E3633A\" brand = \"Keysight\" details = { \"Power Supply Range\" : \"20 V, 10 A | 8 V, 20 A\" } def __init__ ( self , resource_name : str , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. kwargs: directly passed to `VisaInstrument.__init__`. \"\"\" super () . __init__ ( resource_name , ** kwargs ) def set_output_range ( self , option : str ) -> None : \"\"\"Selects an output range to be programmed. Note: For model E3633A, the programming ranges are: - LOW: 0 V to 8.24 V, 0 A to 20.60 A - HIGH: 0 V to 20.60 V, 0 A to 10.30 A Args: option: `\"LOW\"` | `\"HIGH\"` \"\"\" cmd = f \":VOLTage:RANGe { option } \" self . command ( cmd ) def get_output_range ( self ) -> str : \"\"\"Queries current selected output range. Please refer to `set_output_range()` for more information. Returns: `\"LOW\"` | `\"HIGH\"` \"\"\" @property def min_voltage ( self ): cmd = \":VOLTage? MIN\" v = float ( self . query ( cmd )) return v @property def max_voltage ( self ): cmd = \":VOLTage? MAX\" v = float ( self . query ( cmd )) return v @property def min_current ( self ): cmd = \":CURRent? MIN\" i = float ( self . query ( cmd )) return i @property def max_current ( self ): cmd = \":CURRent? MAX\" i = float ( self . query ( cmd )) return i def enable ( self , en : bool = True ) -> None : if not isinstance ( en , bool ): raise TypeError ( 'Parameter en must be bool type.' ) cmd = f ':OUTPut { [ \"OFF\" , \"ON\" ][ int ( en )] } ' self . command ( cmd ) def disable ( self ) -> None : self . enable ( False ) def is_enabled ( self ) -> bool : cmd = \":OUTPut?\" status = bool ( int ( self . query ( cmd ))) return status def set_voltage_limit ( self , value : int | float ) -> None : if not 0 <= value <= self . max_voltage : raise ValueError ( f \"The voltage limit value out of range: { value !r} \" ) cmd = f \":VOLTage { value : .4f } \" self . command ( cmd ) def get_voltage_limit ( self ) -> float : cmd = \":VOLTage?\" v = float ( self . query ( cmd )) return v def measure_voltage ( self ) -> float : cmd = \":MEASure:VOLTage?\" v = float ( self . query ( cmd )) return v def set_current_limit ( self , value : int | float ) -> None : if not 0 <= value <= self . max_current : raise ValueError ( f \"The current limit value out of range: { value !r} \" ) cmd = f \":CURRent { value : .4f } \" self . command ( cmd ) def get_current_limit ( self ) -> float : cmd = \":CURRent?\" i = float ( self . command ( cmd )) return i def measure_current ( self ) -> float : cmd = \":MEASure:CURRent?\" i = float ( self . command ( cmd )) return i def set_ocp_level ( self , level : int | float ) -> None : cmd = f \":CURRent:PROTection { level : .4f } \" self . command ( cmd ) def get_ocp_level ( self ) -> float : cmd = f \":CURRent:PROTection?\" ocp = float ( self . query ( cmd )) return ocp def enable_ocp ( self , enable : bool = True ) -> None : if not isinstance ( enable , bool ): raise TypeError ( \"Parameter enable must be bool type.\" ) cmd = f \":CURRent:PROTection:STATe { enable : d } \" self . command ( cmd ) def disable_ocp ( self ) -> None : self . enable_ocp ( False ) def is_ocp_enabled ( self ) -> bool : cmd = \":CURRent:PROTection:STATe?\" enabled = bool ( int ( self . query ( cmd ))) return enabled def is_ocp_tripped ( self ) -> bool : cmd = \":CURRent:PROTection:TRIPped?\" tripped = bool ( int ( self . query ( cmd ))) return tripped def clear_ocp ( self ) -> None : cmd = \":CURRent:PROTection:CLEar\" self . command ( cmd ) def set_ovp_level ( self , level : int | float ) -> None : cmd = f \":VOLTage:PROTection { level : .4f } \" self . command ( cmd ) def get_ovp_level ( self ) -> float : cmd = \":VOLTage:PROTection?\" ovp = float ( self . query ( cmd )) return ovp def enable_ovp ( self , enable : bool = True ) -> None : if not isinstance ( enable , bool ): raise TypeError ( \"Parameter enable must be bool type.\" ) cmd = f \":VOLTage:PROTection:STATe { enable : d } \" self . command ( cmd ) def disable_ovp ( self ) -> None : self . enable_ovp ( False ) def is_ovp_enabled ( self ) -> bool : cmd = \":VOLTage:PROTection:STATe?\" enabled = bool ( int ( self . query ( cmd ))) return enabled def is_ovp_tripped ( self ) -> bool : cmd = \":VOLTage:PROTection:TRIPped?\" tripped = bool ( int ( self . query ( cmd ))) return tripped def clear_ovp ( self ) -> None : cmd = \":VOLTage:PROTection:CLEar\" self . command ( cmd ) __init__ ( resource_name , ** kwargs ) \u00a4 Parameters: Name Type Description Default resource_name str Resource name or alias of the VISA resource to open. required kwargs directly passed to VisaInstrument.__init__ . required Source code in pyinst\\models.py 4705 4706 4707 4708 4709 4710 4711 def __init__ ( self , resource_name : str , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. kwargs: directly passed to `VisaInstrument.__init__`. \"\"\" super () . __init__ ( resource_name , ** kwargs ) get_output_range () \u00a4 Queries current selected output range. Please refer to set_output_range() for more information. Returns: Type Description str \"LOW\" | \"HIGH\" Source code in pyinst\\models.py 4728 4729 4730 4731 4732 4733 4734 4735 def get_output_range ( self ) -> str : \"\"\"Queries current selected output range. Please refer to `set_output_range()` for more information. Returns: `\"LOW\"` | `\"HIGH\"` \"\"\" set_output_range ( option ) \u00a4 Selects an output range to be programmed. Note For model E3633A, the programming ranges are: LOW: 0 V to 8.24 V, 0 A to 20.60 A HIGH: 0 V to 20.60 V, 0 A to 10.30 A Parameters: Name Type Description Default option str \"LOW\" | \"HIGH\" required Source code in pyinst\\models.py 4713 4714 4715 4716 4717 4718 4719 4720 4721 4722 4723 4724 4725 4726 def set_output_range ( self , option : str ) -> None : \"\"\"Selects an output range to be programmed. Note: For model E3633A, the programming ranges are: - LOW: 0 V to 8.24 V, 0 A to 20.60 A - HIGH: 0 V to 20.60 V, 0 A to 10.30 A Args: option: `\"LOW\"` | `\"HIGH\"` \"\"\" cmd = f \":VOLTage:RANGe { option } \" self . command ( cmd ) ModelEPS1000 \u00a4 Bases: BaseInstrument , TypePOLC Source code in pyinst\\models.py 5426 5427 5428 5429 5430 5431 5432 5433 5434 5435 5436 5437 5438 5439 5440 5441 5442 5443 5444 5445 5446 5447 5448 5449 5450 5451 5452 5453 5454 5455 5456 5457 5458 5459 5460 5461 5462 5463 5464 5465 5466 5467 5468 5469 5470 5471 5472 5473 5474 5475 5476 5477 5478 5479 5480 5481 5482 5483 5484 5485 5486 5487 5488 5489 5490 5491 5492 5493 5494 5495 5496 5497 5498 5499 5500 5501 5502 5503 5504 5505 5506 5507 5508 5509 5510 5511 5512 5513 5514 5515 5516 5517 5518 5519 5520 5521 5522 5523 5524 5525 5526 5527 5528 5529 5530 5531 5532 5533 5534 5535 5536 5537 5538 5539 5540 5541 5542 5543 5544 5545 5546 5547 5548 5549 5550 5551 5552 5553 5554 5555 5556 5557 5558 5559 5560 5561 5562 5563 5564 5565 5566 5567 5568 5569 5570 5571 5572 5573 5574 5575 5576 5577 5578 5579 5580 5581 5582 5583 5584 5585 5586 5587 5588 5589 5590 5591 5592 5593 5594 5595 5596 5597 5598 5599 5600 5601 5602 5603 5604 5605 5606 5607 5608 5609 5610 5611 5612 5613 5614 5615 5616 5617 5618 5619 5620 5621 5622 5623 5624 5625 5626 5627 5628 5629 5630 5631 5632 5633 5634 5635 5636 5637 5638 class ModelEPS1000 ( BaseInstrument , TypePOLC ): model = \"EPS1000\" brand = \"Novoptel\" details = { \"Wavelength Range\" : \"1510.3-1639.1 nm\" , \"Frequency Range\" : \"182.9-198.5 THz\" , \"Insertion loss\" : \"1.5-3 dB\" , \"Peaked Rate\" : \"0-20,000,000 rad/s\" , \"Rayleigh Rate\" : \"0-10,000,000 rad/s\" } def __init__ ( self , resource_name : str , timeout = 3 , ** kwargs ): super () . __init__ ( resource_name , ** kwargs ) baudrate = 230400 device_list = ftd . listDevices () for i in range ( len ( device_list )): desc = ftd . getDeviceInfoDetail ( i )[ \"description\" ] . decode () if desc . startswith ( 'EPS1000' ): sn = desc . split ()[ - 1 ] else : continue if resource_name . endswith ( sn ): self . __device_num = i break else : raise ValueError ( 'Device not found: {model} | S/N: {sn} ' . format ( model = self . model , sn = resource_name )) self . __device = ftd . open ( self . __device_num ) self . __device . setBaudRate ( baudrate ) self . __device . setDataCharacteristics ( 8 , 0 , 0 ) self . __device . setTimeouts ( round ( timeout * 1000 ), round ( timeout * 1000 )) self . __connected = True @property def min_frequency ( self ) -> float : return super () . min_frequency @property def max_frequency ( self ) -> float : return super () . max_frequency @property def min_wavelength ( self ) -> float : return 1510.3 @property def max_wavelength ( self ) -> float : return 1639.1 def close ( self ) -> None : self . __device . close () self . __connected = False # def check_connection(self): # return self.__connected def __write_register ( self , addr , data ): if not self . __connected : raise ValueError ( 'Device is closed. Please connect first.' ) time . sleep ( 0.01 ) write_str = 'W' + ' {:03X} ' . format ( addr ) + ' {:04X} ' . format ( data ) + chr ( 13 ) write_str_c = ctypes . create_string_buffer ( write_str . encode ( 'utf-8' ), 9 ) self . __device . write ( write_str_c ) def __read_register ( self , addr ): if not self . __connected : raise ValueError ( 'Device is closed. Please connect first.' ) self . __device . purge () # clear buffer time . sleep ( 0.01 ) # send request read_request = 'R' + ' {:03X} ' . format ( addr ) + '0000' + chr ( 13 ) read_request_c = ctypes . create_string_buffer ( read_request . encode ( 'utf-8' ), 9 ) self . __device . write ( read_request_c ) # wait response bytesavailable = 0 tries = 0 while bytesavailable < 5 and tries < 1000 : bytesavailable = self . __device . getQueueStatus () tries += 1 time . sleep ( 0.001 ) # get responce res = self . __device . read ( bytesavailable ) # return responce as integer if bytesavailable > 4 : value = int ( res . decode ( \"utf-8\" ), 16 ) else : raise ValueError ( 'Invalid response from ' ) return value def set_qwp ( self , qwp_n , direction , speed ): \"\"\" qwp_n = 0, 1, 2, 3, 4, 5 direction = 0(Disabled), 1(Forward), -1(Backward) speed = (rad/s) \"\"\" control_reg_addr = qwp_n + 1 speed_reg_addr0 = qwp_n * 2 + 11 speed_reg_addr1 = qwp_n * 2 + 12 if direction == 0 : self . __write_register ( control_reg_addr , 0 ) elif direction == 1 : self . __write_register ( control_reg_addr , 1 ) elif direction == - 1 : self . __write_register ( control_reg_addr , 3 ) else : raise ValueError ( 'Invalid value for direction: {} . Options: 0(Disabled), 1(Forward), -1(Backward)' . format ( direction )) speed_msb = int (( speed * 100 ) / ( 2 ** 16 )) & 0xffff speed_lsb = int (( speed * 100 )) & 0xffff self . __write_register ( speed_reg_addr0 , speed_lsb ) self . __write_register ( speed_reg_addr1 , speed_msb ) def set_hwp ( self , direction , speed ): \"\"\" direction = 0(Disabled), 1(Forward), -1(Backward) speed = (krad/s) \"\"\" control_reg_addr = 0 speed_reg_addr0 = 9 speed_reg_addr1 = 10 if direction == 0 : self . __write_register ( control_reg_addr , 0 ) elif direction == 1 : self . __write_register ( control_reg_addr , 1 ) elif direction == - 1 : self . __write_register ( control_reg_addr , 3 ) else : raise ValueError ( 'Invalid value for direction: {} . Options: 0(Disabled), 1(Forward), -1(Backward)' . format ( direction )) speed_msb = int (( speed * 100 ) / ( 2 ** 16 )) & 0xffff speed_lsb = int (( speed * 100 )) & 0xffff self . __write_register ( speed_reg_addr0 , speed_lsb ) self . __write_register ( speed_reg_addr1 , speed_msb ) def get_frequency ( self ) -> float : value = int ( self . read_register ( addr = 25 )) freq = ( value + 1828 ) / 10 return freq def set_frequency ( self , frequency : int | float ) -> None : value = round ( frequency * 10 - 1828 ) self . write_register ( addr = 25 , data = value ) time . sleep ( 0.1 ) def get_wavelength ( self ) -> float : return super () . get_wavelength () def set_wavelength ( self , wavelength : int | float ) -> None : return super () . set_wavelength ( wavelength ) def start_scrambling ( self , mode : str , rate : int | float , ** params ) -> None : ''' speed unit: rad/s when mode is 'Peaked', the max rate is 2000000rad/s when mode is 'Rayleigh', the max rate is 1000000rad/s when mode is 'Marvell', the unit is rad/s ''' speed = rate if mode == 'Peaked' : if 0 <= speed <= 20000000 : speed_10 = round ( speed / 10 ) lsb = speed_10 & 0xFFFF msb = ( 2 << 14 ) | ( speed_10 >> 16 ) self . write_register ( addr = 23 , data = lsb ) self . write_register ( addr = 24 , data = msb ) else : raise ValueError ( \"Speed is out of range, the max speed of 'Peaked' mode is 2000000rad/s\" ) elif mode == 'Rayleigh' : if 0 <= speed <= 10000000 : speed_10 = round ( speed / 10 ) lsb = speed_10 & 0xFFFF msb = ( 3 << 14 ) | ( speed_10 >> 16 ) self . write_register ( addr = 23 , data = lsb ) self . write_register ( addr = 24 , data = msb ) else : raise ValueError ( \"Speed is out of range, the max speed of 'Rayleigh' mode is 1000000rad/s\" ) elif mode == 'Marvell' : self . stop_scrambling () self . write_register ( addr = 23 , data = 0 ) self . write_register ( addr = 24 , data = 0 ) time . sleep ( 0.1 ) qwp_speed = speed / 6 offset = 0.02 self . set_qwp ( qwp_n = 0 , direction = 1 , speed = qwp_speed * ( 1.0 + offset )) self . set_qwp ( qwp_n = 1 , direction =- 1 , speed = qwp_speed * ( 1.0 - offset )) self . set_qwp ( qwp_n = 2 , direction = 1 , speed = qwp_speed * ( 1.0 + offset )) self . set_hwp ( direction =- 1 , speed = 0.01 ) # -1 is backward. 0.01 could be just rad/s self . set_qwp ( qwp_n = 3 , direction =- 1 , speed = qwp_speed * ( 1.0 - offset )) self . set_qwp ( qwp_n = 4 , direction = 1 , speed = qwp_speed * ( 1.0 + offset )) self . set_qwp ( qwp_n = 5 , direction =- 1 , speed = qwp_speed * ( 1.0 - offset )) if qwp_speed < 10 : self . set_hwp ( direction = 0 , speed = 0 ) def stop_scrambling ( self ) -> None : self . start_scrambling ( 'Peaked' , 0 ) set_hwp ( direction , speed ) \u00a4 direction = 0(Disabled), 1(Forward), -1(Backward) speed = (krad/s) Source code in pyinst\\models.py 5549 5550 5551 5552 5553 5554 5555 5556 5557 5558 5559 5560 5561 5562 5563 5564 5565 5566 5567 5568 5569 5570 5571 5572 5573 def set_hwp ( self , direction , speed ): \"\"\" direction = 0(Disabled), 1(Forward), -1(Backward) speed = (krad/s) \"\"\" control_reg_addr = 0 speed_reg_addr0 = 9 speed_reg_addr1 = 10 if direction == 0 : self . __write_register ( control_reg_addr , 0 ) elif direction == 1 : self . __write_register ( control_reg_addr , 1 ) elif direction == - 1 : self . __write_register ( control_reg_addr , 3 ) else : raise ValueError ( 'Invalid value for direction: {} . Options: 0(Disabled), 1(Forward), -1(Backward)' . format ( direction )) speed_msb = int (( speed * 100 ) / ( 2 ** 16 )) & 0xffff speed_lsb = int (( speed * 100 )) & 0xffff self . __write_register ( speed_reg_addr0 , speed_lsb ) self . __write_register ( speed_reg_addr1 , speed_msb ) set_qwp ( qwp_n , direction , speed ) \u00a4 qwp_n = 0, 1, 2, 3, 4, 5 direction = 0(Disabled), 1(Forward), -1(Backward) speed = (rad/s) Source code in pyinst\\models.py 5524 5525 5526 5527 5528 5529 5530 5531 5532 5533 5534 5535 5536 5537 5538 5539 5540 5541 5542 5543 5544 5545 5546 5547 def set_qwp ( self , qwp_n , direction , speed ): \"\"\" qwp_n = 0, 1, 2, 3, 4, 5 direction = 0(Disabled), 1(Forward), -1(Backward) speed = (rad/s) \"\"\" control_reg_addr = qwp_n + 1 speed_reg_addr0 = qwp_n * 2 + 11 speed_reg_addr1 = qwp_n * 2 + 12 if direction == 0 : self . __write_register ( control_reg_addr , 0 ) elif direction == 1 : self . __write_register ( control_reg_addr , 1 ) elif direction == - 1 : self . __write_register ( control_reg_addr , 3 ) else : raise ValueError ( 'Invalid value for direction: {} . Options: 0(Disabled), 1(Forward), -1(Backward)' . format ( direction )) speed_msb = int (( speed * 100 ) / ( 2 ** 16 )) & 0xffff speed_lsb = int (( speed * 100 )) & 0xffff self . __write_register ( speed_reg_addr0 , speed_lsb ) self . __write_register ( speed_reg_addr1 , speed_msb ) start_scrambling ( mode , rate , ** params ) \u00a4 speed unit: rad/s when mode is 'Peaked', the max rate is 2000000rad/s when mode is 'Rayleigh', the max rate is 1000000rad/s when mode is 'Marvell', the unit is rad/s Source code in pyinst\\models.py 5591 5592 5593 5594 5595 5596 5597 5598 5599 5600 5601 5602 5603 5604 5605 5606 5607 5608 5609 5610 5611 5612 5613 5614 5615 5616 5617 5618 5619 5620 5621 5622 5623 5624 5625 5626 5627 5628 5629 5630 5631 5632 5633 5634 5635 def start_scrambling ( self , mode : str , rate : int | float , ** params ) -> None : ''' speed unit: rad/s when mode is 'Peaked', the max rate is 2000000rad/s when mode is 'Rayleigh', the max rate is 1000000rad/s when mode is 'Marvell', the unit is rad/s ''' speed = rate if mode == 'Peaked' : if 0 <= speed <= 20000000 : speed_10 = round ( speed / 10 ) lsb = speed_10 & 0xFFFF msb = ( 2 << 14 ) | ( speed_10 >> 16 ) self . write_register ( addr = 23 , data = lsb ) self . write_register ( addr = 24 , data = msb ) else : raise ValueError ( \"Speed is out of range, the max speed of 'Peaked' mode is 2000000rad/s\" ) elif mode == 'Rayleigh' : if 0 <= speed <= 10000000 : speed_10 = round ( speed / 10 ) lsb = speed_10 & 0xFFFF msb = ( 3 << 14 ) | ( speed_10 >> 16 ) self . write_register ( addr = 23 , data = lsb ) self . write_register ( addr = 24 , data = msb ) else : raise ValueError ( \"Speed is out of range, the max speed of 'Rayleigh' mode is 1000000rad/s\" ) elif mode == 'Marvell' : self . stop_scrambling () self . write_register ( addr = 23 , data = 0 ) self . write_register ( addr = 24 , data = 0 ) time . sleep ( 0.1 ) qwp_speed = speed / 6 offset = 0.02 self . set_qwp ( qwp_n = 0 , direction = 1 , speed = qwp_speed * ( 1.0 + offset )) self . set_qwp ( qwp_n = 1 , direction =- 1 , speed = qwp_speed * ( 1.0 - offset )) self . set_qwp ( qwp_n = 2 , direction = 1 , speed = qwp_speed * ( 1.0 + offset )) self . set_hwp ( direction =- 1 , speed = 0.01 ) # -1 is backward. 0.01 could be just rad/s self . set_qwp ( qwp_n = 3 , direction =- 1 , speed = qwp_speed * ( 1.0 - offset )) self . set_qwp ( qwp_n = 4 , direction = 1 , speed = qwp_speed * ( 1.0 + offset )) self . set_qwp ( qwp_n = 5 , direction =- 1 , speed = qwp_speed * ( 1.0 - offset )) if qwp_speed < 10 : self . set_hwp ( direction = 0 , speed = 0 ) ModelM8292A \u00a4 Bases: BaseModelVSA89600_OMA M8290A Optical Modulation Analyzer Source code in pyinst\\models.py 2332 2333 2334 2335 2336 2337 2338 2339 2340 2341 2342 2343 2344 2345 2346 2347 2348 2349 2350 2351 2352 2353 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 2366 class ModelM8292A ( BaseModelVSA89600_OMA ): \"\"\"M8290A Optical Modulation Analyzer\"\"\" model = \"M8292A\" brand = \"Keysight\" details = { \"Maximum detectable symbol rate\" : \"74 GBd\" , \"Optical frequency range\" : \"196.25 ~ 190.95 THz\" , \"Max signal input power\" : \"+14.5 dBm\" , \"External LO input power\" : \"+17 dBm\" , } def __init__ ( self , resource_name , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. kwargs: directly passed to `VisaInstrument.__init__`. \"\"\" super ( ModelM8292A , self ) . __init__ ( resource_name , ** kwargs ) @property def min_frequency ( self ) -> float : return 190.95 @property def max_frequency ( self ) -> float : return 196.25 @property def min_wavelength ( self ) -> float : return super () . min_wavelength @property def max_wavelength ( self ) -> float : return super () . max_wavelength __init__ ( resource_name , ** kwargs ) \u00a4 Parameters: Name Type Description Default resource_name Resource name or alias of the VISA resource to open. required kwargs directly passed to VisaInstrument.__init__ . required Source code in pyinst\\models.py 2344 2345 2346 2347 2348 2349 2350 def __init__ ( self , resource_name , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. kwargs: directly passed to `VisaInstrument.__init__`. \"\"\" super ( ModelM8292A , self ) . __init__ ( resource_name , ** kwargs ) ModelMAP_mOSX_C1 \u00a4 Bases: VisaInstrument , TypeMSW mOSX-C1 is a optical matrix switch by VIAVI. Source code in pyinst\\models.py 4431 4432 4433 4434 4435 4436 4437 4438 4439 4440 4441 4442 4443 4444 4445 4446 4447 4448 4449 4450 4451 4452 4453 4454 4455 4456 4457 4458 4459 4460 4461 4462 4463 4464 4465 4466 4467 4468 4469 4470 4471 4472 4473 4474 4475 4476 4477 4478 4479 4480 4481 4482 4483 4484 4485 4486 4487 4488 4489 4490 4491 4492 4493 4494 4495 4496 4497 4498 4499 4500 4501 4502 4503 4504 4505 4506 4507 4508 4509 4510 4511 4512 4513 4514 4515 4516 4517 4518 4519 4520 4521 4522 4523 4524 4525 4526 4527 4528 4529 4530 4531 4532 4533 4534 4535 4536 4537 4538 4539 4540 4541 4542 4543 4544 4545 4546 4547 4548 4549 4550 4551 4552 4553 4554 4555 4556 4557 4558 4559 4560 4561 4562 4563 class ModelMAP_mOSX_C1 ( VisaInstrument , TypeMSW ): \"\"\"mOSX-C1 is a optical matrix switch by VIAVI.\"\"\" model = \"mOSX-C1\" brand = \"VIAVI\" details = { \"Wavelength Range\" : \"1260 ~ 1675 nm\" , \"Return Loss\" : \"> 50 dB\" , \"Switching Time\" : \"<= 25 ms\" , \"Insertion Loss\" : \"<= 1.5 dB\" , \"PDL\" : \"< 0.1 dB\" , } params = [ { \"name\" : \"slot\" , \"type\" : \"int\" , \"min\" : 1 , \"max\" : 8 , } ] def __init__ ( self , resource_name : str , slot : int , ** kwargs ) -> None : \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: The slot number in the frame. :kwargs: directly passed to `VisaInstrument.__init__`. \"\"\" super ( ModelMAP_mOSX_C1 , self ) . __init__ ( resource_name , ** kwargs ) self . __device = ' {slot:d} , {device} ' . format ( slot = slot , device = 1 ) def get_switch_topology ( self ) -> Tuple [ int , int ]: \"\"\" Returns the configured switch topology Returns: M: number of input ports N: number of output ports Notes: For common connection mode, M = total number of ports, N = 0. \"\"\" cmd = ':MODUle:TYPE? {device} ' . format ( device = self . __device ) rpl = self . query ( cmd ) config = tuple ( int ( i ) for i in rpl . split ( ',' )) return config def set_switch_topology ( self , n_in : int , n_out : int ) -> None : \"\"\" Sets the switch topology to emulate an MxN switch or common connection. All the channels will be cleared after topology changed. Args: n_in: Number of input ports (0 for common connection mode). n_out: Number of output ports (0 for common connection mode). \"\"\" cmd = ':MODUle:TYPe {device} , {n_in} , {n_out} ' . format ( device = self . __device , n_in = n_in , n_out = n_out ) self . command ( cmd ) def list_channels ( self ) -> List [ Tuple [ int , int , bool ]]: \"\"\" Returns a list of all configured connections and their status. Returns: All configured connections and their status. [(port1, port2, state), ...]. For state, False = Disabled, True = Enabled. \"\"\" cmd = ':ROUTe:LIST? {device} ' . format ( device = self . __device ) rpl = self . query ( cmd ) channels = [] for s in rpl . split ( ',' ): spl = s . split () port1 , port2 = ( int ( i ) for i in spl [ 0 ] . split ( '-' )) state = bool ( int ( spl [ 1 ])) channels . append (( port1 , port2 , state )) return channels def set_channel ( self , port1 : int , port2 : int , enable : bool = True ) -> None : m , n = self . get_switch_topology () if m == n : raise ValueError ( 'Invalid port value: please select 2 different ports. port1= {port1} , port2= {port2} ' . format ( port1 = port1 , port2 = port2 )) if n == 0 : if port1 > m or port2 > m : raise ValueError ( 'Invalid port value: exceed max port number {m} . port1= {port1} , port2= {port2} ' . format ( m = m , port1 = port1 , port2 = port2 )) else : if not ( port1 <= m ) ^ ( port2 <= m ): raise ValueError ( 'Invalid port value for {m} x {n} switch: port1= {port1} , port2= {port2} ' . format ( m = m , n = n , port1 = port1 , port2 = port2 )) cmd = ':ROUTe:CLOSe {device} , {port1:d} , {port2:d} , {state:d} ' . format ( device = self . __device , port1 = port1 , port2 = port2 , state = enable ) self . command ( cmd ) def get_connected_port ( self , port : int ) -> Optional [ int ]: cmd = ':ROUTe:CLOSe? {device} , {port:d} ' . format ( device = self . __device , port = port ) rpl = self . query ( cmd ) return int ( rpl ) or None def clear_channel ( self , port : int ) -> None : cmd = ':ROUTe:CLEAR {device} , {port:d} ' . format ( device = self . __device , port = port ) self . command ( cmd ) def clear_all_channels ( self ) -> None : cmd = ':ROUTe:CLEAR:ALL {device} ' . format ( device = self . __device ) self . command ( cmd ) def check_channel ( self , port1 : int , port2 : int ) -> bool : cmd = ':ROUTe:CHECK? {device} , {port1:d} , {port2:d} ' . format ( device = self . __device , port1 = port1 , port2 = port2 ) rpl = self . query ( cmd ) return bool ( int ( rpl )) def enable_channel ( self , port : int , enable : bool = True ) -> None : cmd = ':ROUTe:ENABle {device} , {port:d} , {state:d} ' . format ( device = self . __device , port = port , state = enable ) self . command ( cmd ) def disable_channel ( self , port : int ) -> None : return self . enable_channel ( port , enable = False ) def is_channel_enabled ( self , port : int ) -> bool : cmd = ':ROUTe:ENABle? {device} , {port:d} ' . format ( device = self . __device , port = port ) rpl = self . query ( cmd ) return bool ( int ( rpl )) __init__ ( resource_name , slot , ** kwargs ) \u00a4 Parameters: Name Type Description Default resource_name str Resource name or alias of the VISA resource to open. required slot int The slot number in the frame. required kwargs: directly passed to VisaInstrument.__init__ . required Source code in pyinst\\models.py 4455 4456 4457 4458 4459 4460 4461 4462 4463 def __init__ ( self , resource_name : str , slot : int , ** kwargs ) -> None : \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: The slot number in the frame. :kwargs: directly passed to `VisaInstrument.__init__`. \"\"\" super ( ModelMAP_mOSX_C1 , self ) . __init__ ( resource_name , ** kwargs ) self . __device = ' {slot:d} , {device} ' . format ( slot = slot , device = 1 ) get_switch_topology () \u00a4 Returns the configured switch topology Returns: Name Type Description M int number of input ports N int number of output ports Notes For common connection mode, M = total number of ports, N = 0. Source code in pyinst\\models.py 4465 4466 4467 4468 4469 4470 4471 4472 4473 4474 4475 4476 4477 4478 4479 def get_switch_topology ( self ) -> Tuple [ int , int ]: \"\"\" Returns the configured switch topology Returns: M: number of input ports N: number of output ports Notes: For common connection mode, M = total number of ports, N = 0. \"\"\" cmd = ':MODUle:TYPE? {device} ' . format ( device = self . __device ) rpl = self . query ( cmd ) config = tuple ( int ( i ) for i in rpl . split ( ',' )) return config list_channels () \u00a4 Returns a list of all configured connections and their status. Returns: Type Description List [ Tuple [ int , int , bool ]] All configured connections and their status. [(port1, port2, state), ...]. List [ Tuple [ int , int , bool ]] For state, False = Disabled, True = Enabled. Source code in pyinst\\models.py 4497 4498 4499 4500 4501 4502 4503 4504 4505 4506 4507 4508 4509 4510 4511 4512 4513 4514 def list_channels ( self ) -> List [ Tuple [ int , int , bool ]]: \"\"\" Returns a list of all configured connections and their status. Returns: All configured connections and their status. [(port1, port2, state), ...]. For state, False = Disabled, True = Enabled. \"\"\" cmd = ':ROUTe:LIST? {device} ' . format ( device = self . __device ) rpl = self . query ( cmd ) channels = [] for s in rpl . split ( ',' ): spl = s . split () port1 , port2 = ( int ( i ) for i in spl [ 0 ] . split ( '-' )) state = bool ( int ( spl [ 1 ])) channels . append (( port1 , port2 , state )) return channels set_switch_topology ( n_in , n_out ) \u00a4 Sets the switch topology to emulate an MxN switch or common connection. All the channels will be cleared after topology changed. Parameters: Name Type Description Default n_in int Number of input ports (0 for common connection mode). required n_out int Number of output ports (0 for common connection mode). required Source code in pyinst\\models.py 4481 4482 4483 4484 4485 4486 4487 4488 4489 4490 4491 4492 4493 4494 4495 def set_switch_topology ( self , n_in : int , n_out : int ) -> None : \"\"\" Sets the switch topology to emulate an MxN switch or common connection. All the channels will be cleared after topology changed. Args: n_in: Number of input ports (0 for common connection mode). n_out: Number of output ports (0 for common connection mode). \"\"\" cmd = ':MODUle:TYPe {device} , {n_in} , {n_out} ' . format ( device = self . __device , n_in = n_in , n_out = n_out ) self . command ( cmd ) ModelMC711 \u00a4 Bases: BaseModelEspecOld See base class: [ BaseModelEspecOld ][pyinst.instrument_models.BaseModelEspecOld Source code in pyinst\\models.py 3648 3649 3650 3651 class ModelMC711 ( BaseModelEspecOld ): \"\"\"See base class: [`BaseModelEspecOld`][pyinst.instrument_models.BaseModelEspecOld\"\"\" model = \"MC-711\" ModelMC811 \u00a4 Bases: RawSerialInstrument , TypeTS MC-811 is a chamber model by GWS. Note Before communication, some configuration should be performed on the chamber. Communication: Serial Protocol: STEN Baudrate/Parity/Bytesize/Stopbits/Termination: Correspond with the settings in the __init__ method. Default values: baudrate = 19200 parity = NONE Bytesize = 8 bits Stopbits: 1 bit Termination: <CR><LF> Device ID: None Source code in pyinst\\models.py 3660 3661 3662 3663 3664 3665 3666 3667 3668 3669 3670 3671 3672 3673 3674 3675 3676 3677 3678 3679 3680 3681 3682 3683 3684 3685 3686 3687 3688 3689 3690 3691 3692 3693 3694 3695 3696 3697 3698 3699 3700 3701 3702 3703 3704 3705 3706 3707 3708 3709 3710 3711 3712 3713 3714 3715 3716 3717 3718 3719 3720 3721 3722 3723 3724 3725 3726 3727 3728 3729 3730 3731 3732 3733 3734 3735 3736 3737 3738 3739 3740 3741 3742 3743 3744 3745 3746 3747 3748 3749 3750 class ModelMC811 ( RawSerialInstrument , TypeTS ): \"\"\"MC-811 is a chamber model by GWS. Note: Before communication, some configuration should be performed on the chamber. - Communication: Serial - Protocol: STEN - Baudrate/Parity/Bytesize/Stopbits/Termination: Correspond with the settings in the `__init__` method. Default values: - baudrate = 19200 - parity = NONE - Bytesize = 8 bits - Stopbits: 1 bit - Termination: `<CR><LF>` - Device ID: None \"\"\" model = \"MC-811\" brand = \"GWS\" def __init__ ( self , resource_name , baudrate = 19200 , bytesize = SerialByteSize . EIGHTBITS , parity = SerialParity . NONE , stopbits = SerialStopBits . ONE , termination = ' \\r\\n ' , ** kwargs ): \"\"\" Args: resource_name: Serial port name. baudrate: Baud rate such as 9600 or 115200 etc.. bytesize: SerialByteSize = SerialByteSize.EIGHTBITS, parity: SerialParity = SerialParity.NONE, stopbits: SerialStopBits = SerialStopBits.ONE, termination: The write and read termination character. **kwargs: Directly passed to `RawSerialInstrument.__init__`. \"\"\" super () . __init__ ( resource_name , baudrate = baudrate , bytesize = bytesize , parity = parity , stopbits = stopbits , write_termination = termination , read_termination = termination , ** kwargs ) @property def ts_type ( self ) -> TemperatureSourceType : return TemperatureSourceType . CHAMBER # def check_connection(self) -> ConnectionStatus: # try: # self.get_target_temp() # return ConnectionStatus(True) # except Exception as e: # return ConnectionStatus(False, e.args[0] if e.args else None) def run ( self , en : bool = True ) -> None : \"\"\"TODO\"\"\" def stop ( self ) -> None : self . run ( False ) def is_running ( self ) -> bool : \"\"\"TODO\"\"\" def set_target_temp ( self , value : int | float ) -> None : value = round ( value , 1 ) cmd = 'TEMP, S {value:.1f} ' . format ( value = value ) self . write ( cmd ) def get_target_temp ( self ) -> float : cmd = 'TEMP?' temp = float ( self . query ( cmd ) . split ( ',' )[ 1 ]) return temp def get_current_temp ( self ) -> float : cmd = 'TEMP?' temp = float ( self . query ( cmd ) . split ( ',' )[ 0 ]) return temp def set_temp_unit ( self , unit : TemperatureUnit ) -> None : if unit != TemperatureUnit . C : raise ValueError ( 'The temperature unit of this Chamber is fixed to C.' ) def get_temp_unit ( self ) -> TemperatureUnit : return TemperatureUnit . C __init__ ( resource_name , baudrate = 19200 , bytesize = SerialByteSize . EIGHTBITS , parity = SerialParity . NONE , stopbits = SerialStopBits . ONE , termination = ' \\r\\n ' , ** kwargs ) \u00a4 Parameters: Name Type Description Default resource_name Serial port name. required baudrate Baud rate such as 9600 or 115200 etc.. 19200 bytesize SerialByteSize = SerialByteSize.EIGHTBITS, SerialByteSize.EIGHTBITS parity SerialParity = SerialParity.NONE, SerialParity.NONE stopbits SerialStopBits = SerialStopBits.ONE, SerialStopBits.ONE termination The write and read termination character. '\\r\\n' **kwargs Directly passed to RawSerialInstrument.__init__ . {} Source code in pyinst\\models.py 3681 3682 3683 3684 3685 3686 3687 3688 3689 3690 3691 3692 3693 3694 3695 3696 3697 3698 3699 3700 3701 3702 3703 3704 3705 3706 3707 3708 def __init__ ( self , resource_name , baudrate = 19200 , bytesize = SerialByteSize . EIGHTBITS , parity = SerialParity . NONE , stopbits = SerialStopBits . ONE , termination = ' \\r\\n ' , ** kwargs ): \"\"\" Args: resource_name: Serial port name. baudrate: Baud rate such as 9600 or 115200 etc.. bytesize: SerialByteSize = SerialByteSize.EIGHTBITS, parity: SerialParity = SerialParity.NONE, stopbits: SerialStopBits = SerialStopBits.ONE, termination: The write and read termination character. **kwargs: Directly passed to `RawSerialInstrument.__init__`. \"\"\" super () . __init__ ( resource_name , baudrate = baudrate , bytesize = bytesize , parity = parity , stopbits = stopbits , write_termination = termination , read_termination = termination , ** kwargs ) is_running () \u00a4 TODO Source code in pyinst\\models.py 3727 3728 def is_running ( self ) -> bool : \"\"\"TODO\"\"\" run ( en = True ) \u00a4 TODO Source code in pyinst\\models.py 3721 3722 def run ( self , en : bool = True ) -> None : \"\"\"TODO\"\"\" ModelMPC202 \u00a4 Bases: VisaInstrument , TypePOLC Source code in pyinst\\models.py 5267 5268 5269 5270 5271 5272 5273 5274 5275 5276 5277 5278 5279 5280 5281 5282 5283 5284 5285 5286 5287 5288 5289 5290 5291 5292 5293 5294 5295 5296 5297 5298 5299 5300 5301 5302 5303 5304 5305 5306 5307 5308 5309 5310 5311 5312 5313 5314 5315 5316 5317 5318 5319 5320 5321 5322 5323 5324 5325 5326 5327 5328 5329 5330 5331 5332 5333 5334 5335 5336 5337 5338 5339 5340 5341 5342 5343 5344 5345 5346 5347 5348 5349 5350 5351 5352 5353 5354 5355 5356 5357 5358 5359 5360 5361 5362 5363 5364 5365 5366 5367 5368 5369 5370 5371 5372 5373 5374 5375 5376 5377 5378 5379 5380 5381 5382 5383 5384 5385 5386 5387 5388 5389 5390 5391 5392 5393 5394 5395 5396 5397 5398 5399 5400 5401 5402 5403 5404 5405 5406 5407 5408 5409 5410 5411 5412 5413 5414 5415 5416 5417 5418 5419 5420 5421 5422 5423 class ModelMPC202 ( VisaInstrument , TypePOLC ): model = \"MPC-202\" brand = \"General Photonics\" details = { 'Wavelength Range' : '1260 ~ 1650 nm' , 'Scrambling Modes' : 'Discrete, Tornado, Rayleigh, Triangle' , 'Tornado Rate' : '0 to 60,000 Rev/s' , 'Rayleigh Rate' : '0 to 2000 rad/s' , 'Triangle Rate' : '0 to 2000 x 2\u03c0 rad/s' , 'Discrete Rate' : '0 to 20,000 points/s' } def __init__ ( self , resource_name : str , read_termination : str = ' \\r\\n ' , write_termination : str = ' \\r\\n ' , ** kwargs ): super () . __init__ ( resource_name , read_termination , write_termination , ** kwargs ) @property def min_frequency ( self ) -> float : return super () . min_frequency @property def max_frequency ( self ) -> float : return super () . max_frequency @property def min_wavelength ( self ) -> float : return 1260.0 @property def max_wavelength ( self ) -> float : return 1650.0 def get_frequency ( self ) -> float : return super () . get_frequency () def set_frequency ( self , frequency : int | float ) -> None : return super () . set_frequency ( frequency ) def get_wavelength ( self ) -> float : cmd = \":CONFigure:WLENgth?\" wl = float ( self . query ( cmd )) return wl def set_wavelength ( self , wavelength : int | float ) -> None : if not self . min_wavelength <= wavelength <= self . max_wavelength : raise ValueError ( f \"Parameter wavelength is out of range: { wavelength !r} \" ) cmd = f \":CONFigure:WLENgth { wavelength : d } \" self . command ( cmd ) def _discrete_scramble ( self , state : bool , rate : Optional [ int | float ] = None ) -> None : \"\"\"Set discrete scrambling rate and state. Args: state: `True` = Enable scrambling, `False` = Disable scrambling. rate: The scrambling rate in points/s. \"\"\" if rate is not None : if not 0.01 <= rate <= 20000 : raise ValueError ( f 'Parameter rate is out of range: { rate !r} ' ) cmd1 = f \":SCRamble:DISCrete:RATE { rate : .2f } \" self . command ( cmd1 ) cmd2 = f \":SCRamble:DISCrete:STATe { [ 'OFF' , 'ON' ][ state ] } \" self . command ( cmd2 ) def _triangle_scramble ( self , state : bool , rate : Optional [ int | float ] = None ) -> None : \"\"\"Set triangle scrambling rate and state. Args: state: `True` = Enable scrambling, `False` = Disable scrambling. rate: The scrambling rate in 2\u03c0 rad/s. \"\"\" if rate is not None : if not 0.01 <= rate <= 2000 : raise ValueError ( f 'Parameter rate is out of range: { rate !r} ' ) cmd1 = f \":SCRamble:TRIangle:RATE { rate : .2f } \" self . command ( cmd1 ) cmd2 = f \":SCRamble:TRIangle:STATe { [ 'OFF' , 'ON' ][ state ] } \" self . command ( cmd2 ) def _rayleigh_scramble ( self , state : bool , rate : Optional [ int | float ] = None ) -> None : \"\"\"Set Rayleigh scrambling rate and state. Args: state: `True` = Enable scrambling, `False` = Disable scrambling. rate: The scrambling rate in rad/s. \"\"\" if rate is not None : if not 0.01 <= rate <= 2000 : raise ValueError ( f 'Parameter rate is out of range: { rate !r} ' ) cmd1 = f \":SCRamble:RAYLeigh:RATE { rate : .2f } \" self . command ( cmd1 ) cmd2 = f \":SCRamble:RAYLeigh:STATe { [ 'OFF' , 'ON' ][ state ] } \" self . command ( cmd2 ) def _tornado_scramble ( self , state : bool , _type : Optional [ int ], rate : Optional [ int | float ]) -> None : \"\"\"Set tornado scrambling rate, type and state. Args: state: `True` = Enable scrambling, `False` = Disable scrambling. _type: The scrambling type of tornado. `0` = Fixed rotation axis, `1` = Moving rotation axis. rate: The scrambling rate in rev/s. \"\"\" if _type is not None : cmd1 = f \":SCRamble:TORNado:TYPE { _type : d } \" self . command ( cmd1 ) if rate is not None : if not 0.01 <= rate <= 60000 : raise ValueError ( f 'Parameter rate is out of range: { rate !r} ' ) cmd2 = f \":SCRamble:TORNado:RATE { rate : .2f } \" self . command ( cmd2 ) cmd3 = f \":SCRamble:TORNado:STATe { [ 'OFF' , 'ON' ][ state ] } \" self . command ( cmd3 ) def start_scrambling ( self , mode : str , rate : int | float , ** params ) -> None : \"\"\"Start scrambling with specified mode and speed. Args: mode: Scrambling mode. - `DISCrete`: Discrete scrambling. - `TRIangle`: Triangle scrambling. - `RAYLeigh`: Rayleigh scrambling. - `TORNado`: Tornado scrambling. Additional scrambling parameter `_type` is required. rate: Scrambling rate. Different mode may have different units. params: Additional scrambling params if any. * `_type (int)`: For `TORNado` mode only. `0` = Fixed axis, `1` = Rotating axis. Note: Different mode has different unit for scrambling rate: - Discrete: points/s - Triangle: 2\u03c0 rad/s - Rayleigh: rad/s - Tornado: rev/s \"\"\" if mode . upper () . startswith ( 'DISC' ): self . _discrete_scramble ( True , rate = rate ) elif mode . upper () . startswith ( 'TRI' ): self . _triangle_scramble ( True , rate = rate ) elif mode . upper () . startswith ( 'RAYL' ): self . _rayleigh_scramble ( True , rate = rate ) elif mode . upper () . startswith ( 'TORN' ): self . _tornado_scramble ( True , _type = params [ '_type' ], rate = rate ) else : raise ValueError ( f \"Invalid mode: { mode !r} \" ) def stop_scrambling ( self ) -> None : self . _tornado_scramble ( False ) start_scrambling ( mode , rate , ** params ) \u00a4 Start scrambling with specified mode and speed. Parameters: Name Type Description Default mode str Scrambling mode. DISCrete : Discrete scrambling. TRIangle : Triangle scrambling. RAYLeigh : Rayleigh scrambling. TORNado : Tornado scrambling. Additional scrambling parameter _type is required. required rate int | float Scrambling rate. Different mode may have different units. required params Additional scrambling params if any. _type (int) : For TORNado mode only. 0 = Fixed axis, 1 = Rotating axis. required Note Different mode has different unit for scrambling rate: Discrete: points/s Triangle: 2\u03c0 rad/s Rayleigh: rad/s Tornado: rev/s Source code in pyinst\\models.py 5388 5389 5390 5391 5392 5393 5394 5395 5396 5397 5398 5399 5400 5401 5402 5403 5404 5405 5406 5407 5408 5409 5410 5411 5412 5413 5414 5415 5416 5417 5418 5419 5420 def start_scrambling ( self , mode : str , rate : int | float , ** params ) -> None : \"\"\"Start scrambling with specified mode and speed. Args: mode: Scrambling mode. - `DISCrete`: Discrete scrambling. - `TRIangle`: Triangle scrambling. - `RAYLeigh`: Rayleigh scrambling. - `TORNado`: Tornado scrambling. Additional scrambling parameter `_type` is required. rate: Scrambling rate. Different mode may have different units. params: Additional scrambling params if any. * `_type (int)`: For `TORNado` mode only. `0` = Fixed axis, `1` = Rotating axis. Note: Different mode has different unit for scrambling rate: - Discrete: points/s - Triangle: 2\u03c0 rad/s - Rayleigh: rad/s - Tornado: rev/s \"\"\" if mode . upper () . startswith ( 'DISC' ): self . _discrete_scramble ( True , rate = rate ) elif mode . upper () . startswith ( 'TRI' ): self . _triangle_scramble ( True , rate = rate ) elif mode . upper () . startswith ( 'RAYL' ): self . _rayleigh_scramble ( True , rate = rate ) elif mode . upper () . startswith ( 'TORN' ): self . _tornado_scramble ( True , _type = params [ '_type' ], rate = rate ) else : raise ValueError ( f \"Invalid mode: { mode !r} \" ) ModelMT3065 \u00a4 Bases: BaseModelEspecOld See base class: BaseModelEspecOld Source code in pyinst\\models.py 3654 3655 3656 3657 class ModelMT3065 ( BaseModelEspecOld ): \"\"\"See base class: `BaseModelEspecOld`\"\"\" model = \"MT3065\" ModelN4392A \u00a4 Bases: BaseModelVSA89600_OMA N4392A Optical Modulation Analyzer. Source code in pyinst\\models.py 2296 2297 2298 2299 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 2311 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 2323 2324 2325 2326 2327 2328 2329 class ModelN4392A ( BaseModelVSA89600_OMA ): \"\"\"N4392A Optical Modulation Analyzer.\"\"\" model = \"N4392A\" brand = \"Keysight\" details = { \"Maximum detectable baud rate\" : \"46 Gbaud\" , \"Optical frequency range\" : \"196.25 ~ 190.95 THz\" , \"External LO input power range\" : \"-3 ~ +16 dBm\" , } def __init__ ( self , resource_name , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. kwargs: directly passed to `VisaInstrument.__init__`. \"\"\" super ( ModelN4392A , self ) . __init__ ( resource_name , ** kwargs ) @property def min_frequency ( self ) -> float : return 190.95 @property def max_frequency ( self ) -> float : return 196.25 @property def min_wavelength ( self ) -> float : return super () . min_wavelength @property def max_wavelength ( self ) -> float : return super () . max_wavelength __init__ ( resource_name , ** kwargs ) \u00a4 Parameters: Name Type Description Default resource_name Resource name or alias of the VISA resource to open. required kwargs directly passed to VisaInstrument.__init__ . required Source code in pyinst\\models.py 2307 2308 2309 2310 2311 2312 2313 def __init__ ( self , resource_name , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. kwargs: directly passed to `VisaInstrument.__init__`. \"\"\" super ( ModelN4392A , self ) . __init__ ( resource_name , ** kwargs ) ModelN7744A \u00a4 Bases: BaseModelN77xx_OPM Keysight N7744A multi-channel optical power meter. Source code in pyinst\\models.py 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 class ModelN7744A ( BaseModelN77xx_OPM ): \"\"\"Keysight N7744A multi-channel optical power meter.\"\"\" brand = \"Keysight\" model = \"N7744A\" details = { \"Wavelength Range\" : \"1250 ~ 1625 nm\" , \"Input Power Range\" : \"-80 ~ +10 dBm\" , \"Safe Power\" : \"+16 dBm\" , \"Averaging Time\" : \"1 us ~ 10 s\" , } params = [ { \"name\" : \"slot\" , \"type\" : \"int\" , \"options\" : [ 1 , 2 , 3 , 4 ], } ] @property def _max_slot ( self ): return 4 ModelN7752A \u00a4 Bases: BaseModelN77xx_VOA_with_OPM , BaseModelN77xx_OPM Keysight N7752A 2-channel optical attenuator and 2-channel power meter. Source code in pyinst\\models.py 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 class ModelN7752A ( BaseModelN77xx_VOA_with_OPM , BaseModelN77xx_OPM ): \"\"\"Keysight N7752A 2-channel optical attenuator and 2-channel power meter. \"\"\" brand = \"Keysight\" model = \"N7752A\" details = { \"Wavelength Range\" : \"1260~1640 nm\" , \"(slot 1~4) Att Range\" : \"0 ~ 45 dB\" , \"(slot 1~4) Safe Power\" : \"+23 dBm\" , \"(slot 5~6) Input Power Range\" : \"-80 ~ +10 dBm\" , \"(slot 5~6) Safe Power\" : \"+16 dBm\" , \"Averaging Time\" : \"2 ms ~ 10 s\" , } params = [ { \"name\" : \"slot\" , \"type\" : \"int\" , \"options\" : [ 1 , 3 , 5 , 6 ] } ] def __init__ ( self , resource_name : str , slot : int , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: The slot number in the frame. **kwargs: Directly passed to `VisaInstrument.__init__`. \"\"\" super ( ModelN7752A , self ) . __init__ ( resource_name , slot , ** kwargs ) __topology = { 1 : 'voa_with_opm' , 2 : 'voa_with_opm' , 3 : 'voa_with_opm' , 4 : 'voa_with_opm' , 5 : 'opm' , 6 : 'opm' , } self . __slot_type = __slot_type = __topology [ slot ] self . __Base = BaseModelN77xx_OPM if __slot_type == 'opm' else BaseModelN77xx_VOA_with_OPM def __raise_NotImplementedError ( self ): raise NotImplementedError ( f \"This function is not implemented for slot { self . _slot } .\" ) @property def _max_slot ( self ): return 6 @property def min_frequency ( self ) -> float : \"\"\"The minimum settable optical frequency value in THz.\"\"\" return super () . min_frequency @property def max_frequency ( self ) -> float : \"\"\"The maximum settable optical frequency value in THz.\"\"\" return super () . max_frequency @property def min_wavelength ( self ) -> float : \"\"\"The minimum settable optical wavelength value in nm.\"\"\" return self . __Base . min_wavelength . __get__ ( self ) @property def max_wavelength ( self ) -> float : \"\"\"The maximum settable optical wavelength value in nm.\"\"\" return self . __Base . max_wavelength . __get__ ( self ) @property def min_avg_time ( self ) -> float : \"\"\"The minimum averaging time in ms.\"\"\" return 2.0 # 2ms @property def max_avg_time ( self ) -> float : \"\"\"The maximum averaging time in ms.\"\"\" return 10000.0 # 10s @property def min_pow_cal ( self ) -> float : \"\"\"The minimum power calibration value in dB.\"\"\" return self . __Base . min_pow_cal . __get__ ( self ) @property def max_pow_cal ( self ) -> float : \"\"\"The maximum power calibration value in dB.\"\"\" return self . __Base . max_pow_cal . __get__ ( self ) @property def min_att ( self ) -> float : \"\"\"Minimum settable attenuation in dB. The minimum settable attenuation = 0 dB + the optical attenuation offset value. \"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . min_att @property def max_att ( self ) -> float : \"\"\"Maximum settable attenuation in dB. The maximum settable attenuation = The maximum attenuation + the optical attenuation offset value. \"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . max_att @property def min_att_offset ( self ) -> float : \"\"\"Minimum attenuation offset value in dB.\"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . min_att_offset @property def max_att_offset ( self ) -> float : \"\"\"Maximum attenuation offset value in dB.\"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . max_att_offset def get_frequency ( self ) -> float : \"\"\" Queries the optical frequency setting of the instrument in THz. Returns: The optical frequency setting value in THz. \"\"\" return super () . get_frequency () def set_frequency ( self , frequency : int | float ) -> None : \"\"\"Set optical frequency. Args: frequency: The optical frequency setting in THz. \"\"\" return super () . set_frequency ( frequency ) def get_wavelength ( self ) -> float : \"\"\"Queries the optical wavelength setting of the instrument in nm. Returns: The optical wavelength setting value in nm. \"\"\" return self . __Base . get_wavelength ( self ) def set_wavelength ( self , wavelength : int | float ) -> None : \"\"\"Set optical wavelength. Args: wavelength: The optical wavelength setting in nm. \"\"\" return self . __Base . set_wavelength ( self , wavelength ) def get_power_value ( self ) -> float : \"\"\"Fetch the value of measured optical power in current unit setting. The measured value includes the power calibration. Measured value (dBm) = the actual measured value (dBm) + power calibration (dB) Refer to `get_pow_cal` and `set_pow_cal` to operate with the power calibration. Returns: The value of the optical power. \"\"\" return self . __Base . get_power_value ( self ) def get_power_unit ( self ) -> OpticalPowerUnit : \"\"\"Get optical power unit setting. Returns: The unit of the optical power. \"\"\" return self . __Base . get_power_unit ( self ) def set_power_unit ( self , unit : OpticalPowerUnit ) -> None : \"\"\"Set the unit of optical power. Args: unit: The unit of the optical power. \"\"\" return self . __Base . set_power_unit ( self , unit ) def get_pow_cal ( self ) -> float : \"\"\" Get the power calibration offset in dB. Note: The power calibration value defined here is opposite in sign with the instrument display value. This is to unify the definition of power calibration across different models of OPMs. Please refer to `get_power_value` for the math equation. Returns: The power calibration offset in dB. \"\"\" return self . __Base . get_pow_cal ( self ) def set_pow_cal ( self , value : int | float ) -> None : \"\"\" Set the power calibration offset in dB. Args: value: The power calibration offset in dB. \"\"\" return self . __Base . set_pow_cal ( self , value ) def get_avg_time ( self ) -> float : \"\"\" Get the averaging time in ms. Returns: The averaging time in ms. \"\"\" return self . __Base . get_avg_time ( self ) def set_avg_time ( self , value : int | float ) -> None : \"\"\" Set the averaging time in ms. Args: value: The averaging time in ms. \"\"\" return self . __Base . set_avg_time ( self , value ) def enable ( self , en : bool = True ) -> None : \"\"\" Enable (disable) the optical output. Args: en: True = Enable, False = Disable. \"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . enable ( en ) def disable ( self ) -> None : \"\"\"Disable the optical output.\"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () self . enable ( False ) def is_enabled ( self ) -> bool : \"\"\" Returns: Whether the optical output is enabled. \"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . is_enabled () def get_att ( self ) -> float : \"\"\" Get the current attenuation value in dB. Includes the attenuation offset. Queried attenuator = the actual attenuator value + attenuator offset Use `get_att_offset` and `set_att_offset` to operate with the attenuator offset. Returns: The attenuation value in dB. \"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . get_att () def set_att ( self , att : int | float ) -> None : \"\"\" Set attenuation value in dB. Includes the attenuation offset. Refer to `get_att` for more information. Args: att: The attenuation value in dB. \"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . set_att ( att ) def get_att_offset ( self ) -> float : \"\"\" Get the attenuation offset value in dB. Returns: The attenuation offset in dB. \"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . get_att_offset () def set_att_offset ( self , offset : int | float ) -> None : \"\"\" Set the attenuation offset value in dB. Args: offset: The attenuation offset in dB. \"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . set_att_offset ( offset ) __init__ ( resource_name , slot , ** kwargs ) \u00a4 Parameters: Name Type Description Default resource_name str Resource name or alias of the VISA resource to open. required slot int The slot number in the frame. required **kwargs Directly passed to VisaInstrument.__init__ . {} Source code in pyinst\\models.py 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 def __init__ ( self , resource_name : str , slot : int , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: The slot number in the frame. **kwargs: Directly passed to `VisaInstrument.__init__`. \"\"\" super ( ModelN7752A , self ) . __init__ ( resource_name , slot , ** kwargs ) __topology = { 1 : 'voa_with_opm' , 2 : 'voa_with_opm' , 3 : 'voa_with_opm' , 4 : 'voa_with_opm' , 5 : 'opm' , 6 : 'opm' , } self . __slot_type = __slot_type = __topology [ slot ] self . __Base = BaseModelN77xx_OPM if __slot_type == 'opm' else BaseModelN77xx_VOA_with_OPM disable () \u00a4 Disable the optical output. Source code in pyinst\\models.py 841 842 843 844 845 def disable ( self ) -> None : \"\"\"Disable the optical output.\"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () self . enable ( False ) enable ( en = True ) \u00a4 Enable (disable) the optical output. Parameters: Name Type Description Default en bool True = Enable, False = Disable. True Source code in pyinst\\models.py 830 831 832 833 834 835 836 837 838 839 def enable ( self , en : bool = True ) -> None : \"\"\" Enable (disable) the optical output. Args: en: True = Enable, False = Disable. \"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . enable ( en ) get_att () \u00a4 Get the current attenuation value in dB. Includes the attenuation offset. Queried attenuator = the actual attenuator value + attenuator offset Use get_att_offset and set_att_offset to operate with the attenuator offset. Returns: Type Description float The attenuation value in dB. Source code in pyinst\\models.py 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 def get_att ( self ) -> float : \"\"\" Get the current attenuation value in dB. Includes the attenuation offset. Queried attenuator = the actual attenuator value + attenuator offset Use `get_att_offset` and `set_att_offset` to operate with the attenuator offset. Returns: The attenuation value in dB. \"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . get_att () get_att_offset () \u00a4 Get the attenuation offset value in dB. Returns: Type Description float The attenuation offset in dB. Source code in pyinst\\models.py 888 889 890 891 892 893 894 895 896 897 def get_att_offset ( self ) -> float : \"\"\" Get the attenuation offset value in dB. Returns: The attenuation offset in dB. \"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . get_att_offset () get_avg_time () \u00a4 Get the averaging time in ms. Returns: Type Description float The averaging time in ms. Source code in pyinst\\models.py 812 813 814 815 816 817 818 819 def get_avg_time ( self ) -> float : \"\"\" Get the averaging time in ms. Returns: The averaging time in ms. \"\"\" return self . __Base . get_avg_time ( self ) get_frequency () \u00a4 Queries the optical frequency setting of the instrument in THz. Returns: Type Description float The optical frequency setting value in THz. Source code in pyinst\\models.py 725 726 727 728 729 730 731 732 def get_frequency ( self ) -> float : \"\"\" Queries the optical frequency setting of the instrument in THz. Returns: The optical frequency setting value in THz. \"\"\" return super () . get_frequency () get_pow_cal () \u00a4 Get the power calibration offset in dB. Note The power calibration value defined here is opposite in sign with the instrument display value. This is to unify the definition of power calibration across different models of OPMs. Please refer to get_power_value for the math equation. Returns: Type Description float The power calibration offset in dB. Source code in pyinst\\models.py 788 789 790 791 792 793 794 795 796 797 798 799 800 801 def get_pow_cal ( self ) -> float : \"\"\" Get the power calibration offset in dB. Note: The power calibration value defined here is opposite in sign with the instrument display value. This is to unify the definition of power calibration across different models of OPMs. Please refer to `get_power_value` for the math equation. Returns: The power calibration offset in dB. \"\"\" return self . __Base . get_pow_cal ( self ) get_power_unit () \u00a4 Get optical power unit setting. Returns: Type Description OpticalPowerUnit The unit of the optical power. Source code in pyinst\\models.py 772 773 774 775 776 777 778 def get_power_unit ( self ) -> OpticalPowerUnit : \"\"\"Get optical power unit setting. Returns: The unit of the optical power. \"\"\" return self . __Base . get_power_unit ( self ) get_power_value () \u00a4 Fetch the value of measured optical power in current unit setting. The measured value includes the power calibration. Measured value (dBm) = the actual measured value (dBm) + power calibration (dB) Refer to get_pow_cal and set_pow_cal to operate with the power calibration. Returns: Type Description float The value of the optical power. Source code in pyinst\\models.py 758 759 760 761 762 763 764 765 766 767 768 769 770 def get_power_value ( self ) -> float : \"\"\"Fetch the value of measured optical power in current unit setting. The measured value includes the power calibration. Measured value (dBm) = the actual measured value (dBm) + power calibration (dB) Refer to `get_pow_cal` and `set_pow_cal` to operate with the power calibration. Returns: The value of the optical power. \"\"\" return self . __Base . get_power_value ( self ) get_wavelength () \u00a4 Queries the optical wavelength setting of the instrument in nm. Returns: Type Description float The optical wavelength setting value in nm. Source code in pyinst\\models.py 742 743 744 745 746 747 748 def get_wavelength ( self ) -> float : \"\"\"Queries the optical wavelength setting of the instrument in nm. Returns: The optical wavelength setting value in nm. \"\"\" return self . __Base . get_wavelength ( self ) is_enabled () \u00a4 Returns: Type Description bool Whether the optical output is enabled. Source code in pyinst\\models.py 847 848 849 850 851 852 853 854 def is_enabled ( self ) -> bool : \"\"\" Returns: Whether the optical output is enabled. \"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . is_enabled () max_att () property \u00a4 Maximum settable attenuation in dB. The maximum settable attenuation = The maximum attenuation + the optical attenuation offset value. Source code in pyinst\\models.py 700 701 702 703 704 705 706 707 708 709 @property def max_att ( self ) -> float : \"\"\"Maximum settable attenuation in dB. The maximum settable attenuation = The maximum attenuation + the optical attenuation offset value. \"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . max_att max_att_offset () property \u00a4 Maximum attenuation offset value in dB. Source code in pyinst\\models.py 718 719 720 721 722 723 @property def max_att_offset ( self ) -> float : \"\"\"Maximum attenuation offset value in dB.\"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . max_att_offset max_avg_time () property \u00a4 The maximum averaging time in ms. Source code in pyinst\\models.py 674 675 676 677 @property def max_avg_time ( self ) -> float : \"\"\"The maximum averaging time in ms.\"\"\" return 10000.0 # 10s max_frequency () property \u00a4 The maximum settable optical frequency value in THz. Source code in pyinst\\models.py 654 655 656 657 @property def max_frequency ( self ) -> float : \"\"\"The maximum settable optical frequency value in THz.\"\"\" return super () . max_frequency max_pow_cal () property \u00a4 The maximum power calibration value in dB. Source code in pyinst\\models.py 684 685 686 687 @property def max_pow_cal ( self ) -> float : \"\"\"The maximum power calibration value in dB.\"\"\" return self . __Base . max_pow_cal . __get__ ( self ) max_wavelength () property \u00a4 The maximum settable optical wavelength value in nm. Source code in pyinst\\models.py 664 665 666 667 @property def max_wavelength ( self ) -> float : \"\"\"The maximum settable optical wavelength value in nm.\"\"\" return self . __Base . max_wavelength . __get__ ( self ) min_att () property \u00a4 Minimum settable attenuation in dB. The minimum settable attenuation = 0 dB + the optical attenuation offset value. Source code in pyinst\\models.py 689 690 691 692 693 694 695 696 697 698 @property def min_att ( self ) -> float : \"\"\"Minimum settable attenuation in dB. The minimum settable attenuation = 0 dB + the optical attenuation offset value. \"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . min_att min_att_offset () property \u00a4 Minimum attenuation offset value in dB. Source code in pyinst\\models.py 711 712 713 714 715 716 @property def min_att_offset ( self ) -> float : \"\"\"Minimum attenuation offset value in dB.\"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . min_att_offset min_avg_time () property \u00a4 The minimum averaging time in ms. Source code in pyinst\\models.py 669 670 671 672 @property def min_avg_time ( self ) -> float : \"\"\"The minimum averaging time in ms.\"\"\" return 2.0 # 2ms min_frequency () property \u00a4 The minimum settable optical frequency value in THz. Source code in pyinst\\models.py 649 650 651 652 @property def min_frequency ( self ) -> float : \"\"\"The minimum settable optical frequency value in THz.\"\"\" return super () . min_frequency min_pow_cal () property \u00a4 The minimum power calibration value in dB. Source code in pyinst\\models.py 679 680 681 682 @property def min_pow_cal ( self ) -> float : \"\"\"The minimum power calibration value in dB.\"\"\" return self . __Base . min_pow_cal . __get__ ( self ) min_wavelength () property \u00a4 The minimum settable optical wavelength value in nm. Source code in pyinst\\models.py 659 660 661 662 @property def min_wavelength ( self ) -> float : \"\"\"The minimum settable optical wavelength value in nm.\"\"\" return self . __Base . min_wavelength . __get__ ( self ) set_att ( att ) \u00a4 Set attenuation value in dB. Includes the attenuation offset. Refer to get_att for more information. Parameters: Name Type Description Default att int | float The attenuation value in dB. required Source code in pyinst\\models.py 874 875 876 877 878 879 880 881 882 883 884 885 886 def set_att ( self , att : int | float ) -> None : \"\"\" Set attenuation value in dB. Includes the attenuation offset. Refer to `get_att` for more information. Args: att: The attenuation value in dB. \"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . set_att ( att ) set_att_offset ( offset ) \u00a4 Set the attenuation offset value in dB. Parameters: Name Type Description Default offset int | float The attenuation offset in dB. required Source code in pyinst\\models.py 899 900 901 902 903 904 905 906 907 908 def set_att_offset ( self , offset : int | float ) -> None : \"\"\" Set the attenuation offset value in dB. Args: offset: The attenuation offset in dB. \"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . set_att_offset ( offset ) set_avg_time ( value ) \u00a4 Set the averaging time in ms. Parameters: Name Type Description Default value int | float The averaging time in ms. required Source code in pyinst\\models.py 821 822 823 824 825 826 827 828 def set_avg_time ( self , value : int | float ) -> None : \"\"\" Set the averaging time in ms. Args: value: The averaging time in ms. \"\"\" return self . __Base . set_avg_time ( self , value ) set_frequency ( frequency ) \u00a4 Set optical frequency. Parameters: Name Type Description Default frequency int | float The optical frequency setting in THz. required Source code in pyinst\\models.py 734 735 736 737 738 739 740 def set_frequency ( self , frequency : int | float ) -> None : \"\"\"Set optical frequency. Args: frequency: The optical frequency setting in THz. \"\"\" return super () . set_frequency ( frequency ) set_pow_cal ( value ) \u00a4 Set the power calibration offset in dB. Parameters: Name Type Description Default value int | float The power calibration offset in dB. required Source code in pyinst\\models.py 803 804 805 806 807 808 809 810 def set_pow_cal ( self , value : int | float ) -> None : \"\"\" Set the power calibration offset in dB. Args: value: The power calibration offset in dB. \"\"\" return self . __Base . set_pow_cal ( self , value ) set_power_unit ( unit ) \u00a4 Set the unit of optical power. Parameters: Name Type Description Default unit OpticalPowerUnit The unit of the optical power. required Source code in pyinst\\models.py 780 781 782 783 784 785 786 def set_power_unit ( self , unit : OpticalPowerUnit ) -> None : \"\"\"Set the unit of optical power. Args: unit: The unit of the optical power. \"\"\" return self . __Base . set_power_unit ( self , unit ) set_wavelength ( wavelength ) \u00a4 Set optical wavelength. Parameters: Name Type Description Default wavelength int | float The optical wavelength setting in nm. required Source code in pyinst\\models.py 750 751 752 753 754 755 756 def set_wavelength ( self , wavelength : int | float ) -> None : \"\"\"Set optical wavelength. Args: wavelength: The optical wavelength setting in nm. \"\"\" return self . __Base . set_wavelength ( self , wavelength ) ModelN7764A \u00a4 Bases: BaseModelN77xx_VOA_with_OPM Keysight N7764A 4-channel variable optical attenuator with built-in power meter. Source code in pyinst\\models.py 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 class ModelN7764A ( BaseModelN77xx_VOA_with_OPM ): \"\"\"Keysight N7764A 4-channel variable optical attenuator with built-in power meter.\"\"\" brand = \"Keysight\" model = \"N7764A\" details = { \"Wavelength Range\" : \"1260~1640 nm\" , \"Att Range\" : \"0 ~ 45 dB\" , \"Safe Power\" : \"+23 dBm\" , \"Averaging Time\" : \"2 ms ~ 10 s\" , } params = [ { \"name\" : \"slot\" , \"type\" : \"int\" , \"options\" : [ 1 , 3 , 5 , 7 ] } ] def __init__ ( self , resource_name : str , slot : int , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: The slot number in the frame. **kwargs: Directly passed to `VisaInstrument.__init__` \"\"\" super ( ModelN7764A , self ) . __init__ ( resource_name , slot ) @property def _max_slot ( self ): return 8 __init__ ( resource_name , slot , ** kwargs ) \u00a4 Parameters: Name Type Description Default resource_name str Resource name or alias of the VISA resource to open. required slot int The slot number in the frame. required **kwargs Directly passed to VisaInstrument.__init__ {} Source code in pyinst\\models.py 932 933 934 935 936 937 938 939 def __init__ ( self , resource_name : str , slot : int , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: The slot number in the frame. **kwargs: Directly passed to `VisaInstrument.__init__` \"\"\" super ( ModelN7764A , self ) . __init__ ( resource_name , slot ) ModelNSW \u00a4 Bases: BaseInstrument , TypeSW The Smart Optical Switch produced by NeoPhotonics. Source code in pyinst\\models.py 4335 4336 4337 4338 4339 4340 4341 4342 4343 4344 4345 4346 4347 4348 4349 4350 4351 4352 4353 4354 4355 4356 4357 4358 4359 4360 4361 4362 4363 4364 4365 4366 4367 4368 4369 4370 4371 4372 4373 4374 4375 4376 4377 4378 4379 4380 4381 4382 4383 4384 4385 4386 4387 4388 4389 4390 4391 4392 4393 4394 4395 4396 4397 4398 4399 4400 4401 4402 4403 4404 4405 4406 4407 4408 class ModelNSW ( BaseInstrument , TypeSW ): \"\"\"The Smart Optical Switch produced by NeoPhotonics.\"\"\" model = \"Neo_SW\" brand = \"NeoPhotonics\" params = [ { \"name\" : \"slot_or_type\" , \"type\" : \"str\" , \"options\" : [ '1' , '2' , '3' , '1*8' , '1*16' ] } ] def __init__ ( self , resource_name : str , slot_or_type : int | str ) -> None : \"\"\" Args: resource_name: The USB S/N of the device. You can use get_usb_devices() method to list all the available devices. slot_or_type: For optical switch with 1x2/2x2/1x4 optical switch slots, this parameter is the slot in the frame. For 1x8 and 1x16 optical switch, this parameter defines the type of the optical switch. - `1`|`2`|`3`: The slot in the frame. - '1*8': This optical switch is 1x8 type. - '1*16': This optical switch is 1x16 type. \"\"\" super ( ModelNSW , self ) . __init__ () if isinstance ( slot_or_type , int ): self . __index = slot_or_type - 1 else : index_map = { '1' : 0 , '2' : 1 , '3' : 2 , '1*8' : 3 , '1*16' : 4 , } try : self . __index = index_map [ slot_or_type ] except KeyError : raise KeyError ( 'Invalid value for slot_or_type: %r ' % slot_or_type ) self . __usb_dev = NeoUsbDevice ( resource_name ) self . __reg_ch_sel = 16 * self . __index + 130 @property def resource_name ( self ) -> str : \"\"\"The USB S/N of the device.\"\"\" return super () . resource_name @classmethod def get_usb_devices ( cls ) -> List [ str ]: \"\"\"The USB S/N of all the available devices.\"\"\" return [ i [ \"Serial Number\" ] . upper () for i in NeoUsbDevice . get_devices_information ()] def close ( self ) -> None : pass # def check_connection(self) -> ConnectionStatus: # try: # self.get_channel() # return ConnectionStatus(True) # except Exception as e: # return ConnectionStatus(False, e.args[0] if e.args else None) def set_channel ( self , channel : int ) -> None : self . __usb_dev . write_registers ( 0xC2 , self . __reg_ch_sel , channel . to_bytes ( 1 , 'big' )) time . sleep ( 0.4 ) if self . get_channel () != channel : raise ValueError ( 'Set switch channel failed.' ) def get_channel ( self ) -> None : channel = int . from_bytes ( self . __usb_dev . read_registers ( 0xC2 , self . __reg_ch_sel , 1 ), 'big' ) if channel <= 0 : raise ValueError ( 'Invalid channel number.' ) return channel __init__ ( resource_name , slot_or_type ) \u00a4 Parameters: Name Type Description Default resource_name str The USB S/N of the device. You can use get_usb_devices() method to list all the available devices. required slot_or_type int | str For optical switch with 1x2/2x2/1x4 optical switch slots, this parameter is the slot in the frame. For 1x8 and 1x16 optical switch, this parameter defines the type of the optical switch. - 1 | 2 | 3 : The slot in the frame. - '1 8': This optical switch is 1x8 type. - '1 16': This optical switch is 1x16 type. required Source code in pyinst\\models.py 4347 4348 4349 4350 4351 4352 4353 4354 4355 4356 4357 4358 4359 4360 4361 4362 4363 4364 4365 4366 4367 4368 4369 4370 4371 4372 4373 4374 4375 4376 def __init__ ( self , resource_name : str , slot_or_type : int | str ) -> None : \"\"\" Args: resource_name: The USB S/N of the device. You can use get_usb_devices() method to list all the available devices. slot_or_type: For optical switch with 1x2/2x2/1x4 optical switch slots, this parameter is the slot in the frame. For 1x8 and 1x16 optical switch, this parameter defines the type of the optical switch. - `1`|`2`|`3`: The slot in the frame. - '1*8': This optical switch is 1x8 type. - '1*16': This optical switch is 1x16 type. \"\"\" super ( ModelNSW , self ) . __init__ () if isinstance ( slot_or_type , int ): self . __index = slot_or_type - 1 else : index_map = { '1' : 0 , '2' : 1 , '3' : 2 , '1*8' : 3 , '1*16' : 4 , } try : self . __index = index_map [ slot_or_type ] except KeyError : raise KeyError ( 'Invalid value for slot_or_type: %r ' % slot_or_type ) self . __usb_dev = NeoUsbDevice ( resource_name ) self . __reg_ch_sel = 16 * self . __index + 130 get_usb_devices () classmethod \u00a4 The USB S/N of all the available devices. Source code in pyinst\\models.py 4383 4384 4385 4386 @classmethod def get_usb_devices ( cls ) -> List [ str ]: \"\"\"The USB S/N of all the available devices.\"\"\" return [ i [ \"Serial Number\" ] . upper () for i in NeoUsbDevice . get_devices_information ()] resource_name () property \u00a4 The USB S/N of the device. Source code in pyinst\\models.py 4378 4379 4380 4381 @property def resource_name ( self ) -> str : \"\"\"The USB S/N of the device.\"\"\" return super () . resource_name ModelOTF930 \u00a4 Bases: VisaInstrument , TypeOTF Source code in pyinst\\models.py 4140 4141 4142 4143 4144 4145 4146 4147 4148 4149 4150 4151 4152 4153 4154 4155 4156 4157 4158 4159 4160 4161 4162 4163 4164 4165 4166 4167 4168 4169 4170 4171 4172 4173 4174 4175 4176 4177 4178 4179 4180 4181 4182 4183 4184 4185 4186 4187 4188 4189 4190 4191 4192 4193 4194 4195 4196 4197 4198 4199 4200 4201 4202 4203 4204 4205 4206 4207 4208 4209 4210 4211 4212 4213 4214 4215 4216 4217 4218 4219 4220 4221 4222 4223 class ModelOTF930 ( VisaInstrument , TypeOTF ): model = \"OTF-930\" brand = \"Santec\" details = { \"Wavelength Range\" : \"1520 ~ 1610 nm\" , \"Frequency Range\" : \"186.2 ~ 197.2 THz\" , \"Bandwidth\" : \"Fixed and different between bandwidth types\" , \"Max Input Power\" : \"+20 dBm\" } def __init__ ( self , resource_name : str , read_termination : str = ' \\r\\n ' , write_termination : str = ' \\r\\n ' , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. read_termination: Read termination character. write_termination: Write termination character. \"\"\" super () . __init__ ( resource_name , read_termination = read_termination , write_termination = write_termination , ** kwargs ) @property def min_frequency ( self ) -> float : return super () . min_frequency @property def max_frequency ( self ) -> float : return super () . max_frequency @property def min_wavelength ( self ) -> float : return 1520.0 @property def max_wavelength ( self ) -> float : return 1610.0 @property def min_bandwidth_in_nm ( self ) -> float : return float ( 'nan' ) @property def max_bandwidth_in_nm ( self ) -> float : return float ( 'nan' ) @property def min_bandwidth_in_ghz ( self ) -> float : return float ( 'nan' ) @property def max_bandwidth_in_ghz ( self ) -> float : return float ( 'nan' ) def get_wavelength ( self ) -> float : cmd = 'WA' wl = float ( self . query ( cmd )) return wl def set_wavelength ( self , wavelength : int | float ) -> None : if not self . min_wavelength <= wavelength <= self . max_wavelength : raise ValueError ( 'Parameter wavelength out of range: {wl!r} ' . format ( wl = wavelength )) cmd = 'WA {wl:.3f} ' . format ( wl = wavelength ) self . command ( cmd ) def get_frequency ( self ) -> float : return super () . get_frequency () def set_frequency ( self , frequency : int | float ) -> None : return super () . set_frequency ( frequency ) def get_bandwidth_in_nm ( self ) -> float : raise Error ( 'The bandwidth of this OTF model is not tunable.' ) def set_bandwidth_in_nm ( self , value : int | float ) -> None : raise Error ( 'The bandwidth of this OTF model is not tunable.' ) def get_bandwidth_in_ghz ( self ) -> float : raise Error ( 'The bandwidth of this OTF model is not tunable.' ) def set_bandwidth_in_ghz ( self , value : int | float ) -> None : raise Error ( 'The bandwidth of this OTF model is not tunable.' ) __init__ ( resource_name , read_termination = ' \\r\\n ' , write_termination = ' \\r\\n ' , ** kwargs ) \u00a4 Parameters: Name Type Description Default resource_name str Resource name or alias of the VISA resource to open. required read_termination str Read termination character. '\\r\\n' write_termination str Write termination character. '\\r\\n' Source code in pyinst\\models.py 4151 4152 4153 4154 4155 4156 4157 4158 4159 4160 4161 4162 def __init__ ( self , resource_name : str , read_termination : str = ' \\r\\n ' , write_termination : str = ' \\r\\n ' , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. read_termination: Read termination character. write_termination: Write termination character. \"\"\" super () . __init__ ( resource_name , read_termination = read_termination , write_termination = write_termination , ** kwargs ) ModelPMD1000 \u00a4 Bases: VisaInstrument , TypePMDE Source code in pyinst\\models.py 5641 5642 5643 5644 5645 5646 5647 5648 5649 5650 5651 5652 5653 5654 5655 5656 5657 5658 5659 5660 5661 5662 5663 5664 5665 5666 5667 5668 5669 5670 5671 5672 5673 5674 5675 5676 5677 5678 5679 5680 5681 5682 5683 5684 5685 5686 5687 5688 5689 5690 5691 5692 5693 5694 5695 5696 5697 5698 5699 5700 5701 5702 5703 5704 5705 5706 5707 5708 5709 5710 5711 5712 5713 5714 5715 5716 5717 5718 5719 5720 5721 5722 5723 5724 class ModelPMD1000 ( VisaInstrument , TypePMDE ): model = \"PMD-1000\" brand = \"General Photonics\" details = { \"Wavelength Range\" : \"C Band\" , \"Insertion Loss\" : \"5.5 dB\" , \"1st Order PMD Range\" : \"0.36 to 182.4 ps\" , \"2nd Order PMD Range\" : \"8100 ps2\" } def __init__ ( self , resource_name : str , read_termination : str = '' , write_termination : str = '#' , ** kwargs ): super () . __init__ ( resource_name , read_termination , write_termination , ** kwargs ) def _formatted_query ( self , cmd ): return self . query ( cmd )[ 1 :] @property def min_frequency ( self ) -> float : return 191.6 @property def max_frequency ( self ) -> float : return 195.9 @property def min_wavelength ( self ) -> float : return super () . min_wavelength @property def max_wavelength ( self ) -> float : return super () . max_wavelength def get_frequency ( self ) -> float : ch_str = self . _formatted_query ( '*CHA?' ) if ch_str [ 0 ] != 'C' : raise ValueError ( 'Unexpected Reply' ) ch = int ( ch_str [ 1 :]) freq = 191.6 + ( ch - 1 ) * 0.05 return freq def set_frequency ( self , frequency : int | float ) -> None : \"\"\"Set optical frequency value. Note: The PMD-1000 can only set to several discrete values on the ITU C-band: frequency = 191.6 + n*0.05, 0 <= n <= 86 If the frequency is not on the ITU grid, it will be set to the nearest valid value, and no exception will be raised. Args: frequency: optical frequency in THz. \"\"\" if not self . min_frequency <= frequency <= self . max_frequency : raise ValueError ( f 'frequency is out of range: { frequency !r} ' ) ch = round (( frequency - 191.6 ) / 0.05 ) + 1 self . command ( '*CHC %03d #' % ch ) def get_wavelength ( self ) -> float : return super () . get_wavelength () def set_wavelength ( self , wavelength : int | float ) -> None : return super () . set_wavelength ( wavelength ) def get_pmd_value ( self ) -> Tuple [ float , float ]: cmd = \"*PMD:CON CAL?\" r = self . _formatted_query ( cmd ) pmd , sopmd = ( float ( i ) for i in r . split ( ',' )) return pmd , sopmd def set_pmd_value ( self , pmd : int | float , sopmd : int | float ) -> None : \"\"\" Note: The pmd and sopmd setting of the PMD-1000 is not continuous. The pmd and sopmd will be set to the nearest supported values, so the real value will not be exactly the same with the setting values. \"\"\" if not 0 <= pmd <= 182.4 : raise ValueError ( f 'pmd is out of range: { pmd } ' ) if not 0 <= sopmd <= 8319.9 : raise ValueError ( f 'sopmd is out of range: { sopmd } ' ) self . command ( '*PMD:CON %.2f , %.2f #' % ( pmd , sopmd )) set_frequency ( frequency ) \u00a4 Set optical frequency value. Note The PMD-1000 can only set to several discrete values on the ITU C-band: frequency = 191.6 + n*0.05, 0 <= n <= 86 If the frequency is not on the ITU grid, it will be set to the nearest valid value, and no exception will be raised. Parameters: Name Type Description Default frequency int | float optical frequency in THz. required Source code in pyinst\\models.py 5681 5682 5683 5684 5685 5686 5687 5688 5689 5690 5691 5692 5693 5694 5695 5696 5697 5698 5699 def set_frequency ( self , frequency : int | float ) -> None : \"\"\"Set optical frequency value. Note: The PMD-1000 can only set to several discrete values on the ITU C-band: frequency = 191.6 + n*0.05, 0 <= n <= 86 If the frequency is not on the ITU grid, it will be set to the nearest valid value, and no exception will be raised. Args: frequency: optical frequency in THz. \"\"\" if not self . min_frequency <= frequency <= self . max_frequency : raise ValueError ( f 'frequency is out of range: { frequency !r} ' ) ch = round (( frequency - 191.6 ) / 0.05 ) + 1 self . command ( '*CHC %03d #' % ch ) set_pmd_value ( pmd , sopmd ) \u00a4 Note The pmd and sopmd setting of the PMD-1000 is not continuous. The pmd and sopmd will be set to the nearest supported values, so the real value will not be exactly the same with the setting values. Source code in pyinst\\models.py 5713 5714 5715 5716 5717 5718 5719 5720 5721 5722 5723 5724 def set_pmd_value ( self , pmd : int | float , sopmd : int | float ) -> None : \"\"\" Note: The pmd and sopmd setting of the PMD-1000 is not continuous. The pmd and sopmd will be set to the nearest supported values, so the real value will not be exactly the same with the setting values. \"\"\" if not 0 <= pmd <= 182.4 : raise ValueError ( f 'pmd is out of range: { pmd } ' ) if not 0 <= sopmd <= 8319.9 : raise ValueError ( f 'sopmd is out of range: { sopmd } ' ) self . command ( '*PMD:CON %.2f , %.2f #' % ( pmd , sopmd )) ModelPSY101 \u00a4 Bases: VisaInstrument , TypePOLC Source code in pyinst\\models.py 5152 5153 5154 5155 5156 5157 5158 5159 5160 5161 5162 5163 5164 5165 5166 5167 5168 5169 5170 5171 5172 5173 5174 5175 5176 5177 5178 5179 5180 5181 5182 5183 5184 5185 5186 5187 5188 5189 5190 5191 5192 5193 5194 5195 5196 5197 5198 5199 5200 5201 5202 5203 5204 5205 5206 5207 5208 5209 5210 5211 5212 5213 5214 5215 5216 5217 5218 5219 5220 5221 5222 5223 5224 5225 5226 5227 5228 5229 5230 5231 5232 5233 5234 5235 5236 5237 5238 5239 5240 5241 5242 5243 5244 5245 5246 5247 5248 5249 5250 5251 5252 5253 5254 5255 5256 5257 5258 5259 5260 5261 5262 5263 5264 class ModelPSY101 ( VisaInstrument , TypePOLC ): model = \"PSY-101\" brand = \"General Photonics\" details = { \"Wavelength Range\" : \"1500 ~ 1600 nm\" , \"Operating Power Range\" : \"-15 ~ 10 dBm\" } def __init__ ( self , resource_name : str , read_termination : str = '#' , write_termination : str = '' , ** kwargs ): super () . __init__ ( resource_name , read_termination , write_termination , ** kwargs ) def __format_result ( self , result : str ) -> str : return result [ 1 :] @property def min_frequency ( self ) -> float : return super () . min_frequency @property def max_frequency ( self ) -> float : return super () . max_frequency @property def min_wavelength ( self ) -> float : return 1500.0 @property def max_wavelength ( self ) -> float : return 1600.0 def get_frequency ( self ) -> float : return super () . get_frequency () def set_frequency ( self , frequency : int | float ) -> None : return super () . set_frequency ( frequency ) def get_wavelength ( self ) -> float : cmd = \"*WAV?\" wl = float ( self . __format_result ( self . query ( cmd ))) return wl def set_wavelength ( self , wavelength : int | float ) -> None : if not self . min_wavelength <= wavelength <= self . max_wavelength : raise ValueError ( f \"The parameter wavelength is out of range: { wavelength !r} \" ) cmd = f \"*WAV { wavelength : d } #\" err_code = self . __format_result ( self . query ( cmd )) if err_code != 'E00' : raise Error ( f 'Error code: { err_code } ' ) def _random_scramble ( self , state : bool , rate : Optional [ int | float ] = None ) -> None : \"\"\"Set random scrambling rate and state. Args: state: `True` = Enable scrambling, `False` = Disable scrambling. rate: The scrambling rate in Hz. \"\"\" if rate is not None : if not 1 <= rate <= 6000 : raise ValueError ( f \"Parameter rate is out of range: { rate !r} \" ) cmd1 = f \"*RAN:FRQ { rate : d } #\" err_code = self . __format_result ( self . query ( cmd1 )) if err_code != 'E00' : raise Error ( f 'Error code: { err_code } ' ) cmd2 = f \"*RAN:ENA { [ 'OFF' , 'ON' ][ state ] } #\" err_code = self . __format_result ( self . query ( cmd2 )) if err_code != 'E00' : raise Error ( f 'Error code: { err_code } ' ) def _saw_scramble ( self , state : bool , rate : Optional [ int | float ] = None ) -> None : \"\"\"Set saw wave scrambling rate and state. Args: state: `True` = Enable scrambling, `False` = Disable scrambling. rate: The scrambling rate in Hz. \"\"\" if rate is not None : if not 0.1 <= rate <= 500.0 : raise ValueError ( f \"Parameter rate is out of range: { rate !r} \" ) cmd1 = f \"*SAW:FRQ { rate : .1f } #\" err_code = self . __format_result ( self . query ( cmd1 )) if err_code != 'E00' : raise Error ( f 'Error code: { err_code } ' ) cmd2 = f \"*SAW:ENA { [ 'OFF' , 'ON' ][ state ] } #\" err_code = self . __format_result ( self . query ( cmd2 )) if err_code != 'E00' : raise Error ( f 'Error code: { err_code } ' ) def start_scrambling ( self , mode : str , rate : int | float , ** params ) -> None : \"\"\"Start scrambling with specified mode and speed. Args: mode: Scrambling mode. - `RANdom`: Random scrambling. - `SAW`: Saw wave scrambling. rate: Scrambling rate in Hz. params: Not used for PSY-101. \"\"\" if mode . upper () . startswith ( 'RAN' ): self . _random_scramble ( True , rate = rate ) if mode . upper () . startswith ( 'SAW' ): self . _saw_scramble ( True , rate = rate ) else : raise ValueError ( f \"Invalid mode: { mode !r} \" ) def stop_scrambling ( self ) -> None : self . _random_scramble ( False ) start_scrambling ( mode , rate , ** params ) \u00a4 Start scrambling with specified mode and speed. Parameters: Name Type Description Default mode str Scrambling mode. RANdom : Random scrambling. SAW : Saw wave scrambling. required rate int | float Scrambling rate in Hz. required params Not used for PSY-101. required Source code in pyinst\\models.py 5244 5245 5246 5247 5248 5249 5250 5251 5252 5253 5254 5255 5256 5257 5258 5259 5260 5261 def start_scrambling ( self , mode : str , rate : int | float , ** params ) -> None : \"\"\"Start scrambling with specified mode and speed. Args: mode: Scrambling mode. - `RANdom`: Random scrambling. - `SAW`: Saw wave scrambling. rate: Scrambling rate in Hz. params: Not used for PSY-101. \"\"\" if mode . upper () . startswith ( 'RAN' ): self . _random_scramble ( True , rate = rate ) if mode . upper () . startswith ( 'SAW' ): self . _saw_scramble ( True , rate = rate ) else : raise ValueError ( f \"Invalid mode: { mode !r} \" ) ModelPSY201 \u00a4 Bases: VisaInstrument , TypePOLC Source code in pyinst\\models.py 4951 4952 4953 4954 4955 4956 4957 4958 4959 4960 4961 4962 4963 4964 4965 4966 4967 4968 4969 4970 4971 4972 4973 4974 4975 4976 4977 4978 4979 4980 4981 4982 4983 4984 4985 4986 4987 4988 4989 4990 4991 4992 4993 4994 4995 4996 4997 4998 4999 5000 5001 5002 5003 5004 5005 5006 5007 5008 5009 5010 5011 5012 5013 5014 5015 5016 5017 5018 5019 5020 5021 5022 5023 5024 5025 5026 5027 5028 5029 5030 5031 5032 5033 5034 5035 5036 5037 5038 5039 5040 5041 5042 5043 5044 5045 5046 5047 5048 5049 5050 5051 5052 5053 5054 5055 5056 5057 5058 5059 5060 5061 5062 5063 5064 5065 5066 5067 5068 5069 5070 5071 5072 5073 5074 5075 5076 5077 5078 5079 5080 5081 5082 5083 5084 5085 5086 5087 5088 5089 5090 5091 5092 5093 5094 5095 5096 5097 5098 5099 5100 5101 5102 5103 5104 5105 5106 5107 5108 5109 5110 5111 5112 5113 5114 5115 5116 5117 5118 5119 5120 5121 5122 5123 5124 5125 5126 5127 5128 5129 5130 5131 5132 5133 5134 5135 5136 5137 5138 5139 5140 5141 5142 5143 5144 5145 5146 5147 5148 5149 class ModelPSY201 ( VisaInstrument , TypePOLC ): model = \"PSY-201\" brand = \"General Photonics\" details = { \"Wavelength Range\" : \"1480 ~ 1620 nm\" , \"Operating power range\" : \"-35 ~ 10 dBm\" } def __init__ ( self , resource_name : str , write_termination : str = ' \\r\\n ' , read_termination : str = ' \\r\\n ' , ** kwargs ): super ( ModelPSY201 , self ) . __init__ ( resource_name , write_termination = write_termination , read_termination = read_termination , ** kwargs ) @property def min_frequency ( self ) -> float : return super () . min_frequency @property def max_frequency ( self ) -> float : return super () . max_frequency @property def min_wavelength ( self ) -> float : return 1480.0 @property def max_wavelength ( self ) -> float : return 1620.0 def get_frequency ( self ) -> float : return super () . get_frequency () def set_frequency ( self , frequency : int | float ) -> None : return super () . set_frequency ( frequency ) def get_wavelength ( self ) -> float : cmd = \":CONFigure:WLENgth?\" wl = float ( self . query ( cmd )) return wl def set_wavelength ( self , wavelength : int | float ) -> None : \"\"\"Set optical wavelength value. Wavelength setting rounds to the nearest multiple of 5. Args: wavelength: The optical wavelength in nm. \"\"\" if not self . min_wavelength <= wavelength <= self . max_wavelength : raise ValueError ( f \"Parameter wavelength is out of range: { wavelength !r} \" ) cmd = f \":CONFigure:WLENgth { wavelength : d } \" self . command ( cmd ) def _discrete_scramble ( self , state : bool , rate : Optional [ int | float ] = None ) -> None : \"\"\"Set discrete scrambling rate and state. Args: state: `True` = Enable scrambling, `False` = Disable scrambling. rate: The scrambling rate in points/s. \"\"\" if rate is not None : if not 0.01 <= rate <= 20000 : raise ValueError ( f 'Parameter rate is out of range: { rate !r} ' ) cmd1 = f \":CONTrol:SCRamble:DISCrete:RATE { rate : .2f } \" self . command ( cmd1 ) cmd2 = f \":CONTrol:SCRamble:DISCrete:STATe { state : d } \" self . command ( cmd2 ) def _triangle_scramble ( self , state : bool , rate : Optional [ int | float ] = None ) -> None : \"\"\"Set triangle scrambling rate and state. Args: state: `True` = Enable scrambling, `False` = Disable scrambling. rate: The scrambling rate in 2\u03c0 rad/s. \"\"\" if rate is not None : if not 0.01 <= rate <= 2000 : raise ValueError ( f 'Parameter rate is out of range: { rate !r} ' ) cmd1 = f \":CONTrol:SCRamble:TRIangle:RATE { rate : .2f } \" self . command ( cmd1 ) cmd2 = f \":CONTrol:SCRamble:TRIangle:STATe { state : d } \" self . command ( cmd2 ) def _tornado_scramble ( self , state : bool , _type : Optional [ int ], rate : Optional [ int | float ]) -> None : \"\"\"Set tornado scrambling rate, type and state. Args: state: `True` = Enable scrambling, `False` = Disable scrambling. _type: The scrambling type of tornado. `0` = Fixed axis, `1` = Rotating axis. rate: The scrambling rate in Rev/s. \"\"\" if _type is not None : cmd1 = f \":CONTrol:SCRamble:TORNado:TYPE { _type : d } \" self . command ( cmd1 ) if rate is not None : if not 0.01 <= rate <= 2000 : raise ValueError ( f 'Parameter rate is out of range: { rate !r} ' ) cmd2 = f \":CONTrol:SCRamble:TORNado:RATE { rate : .2f } \" self . command ( cmd2 ) cmd3 = f \":CONTrol:SCRamble:TORNado:STATe { state : d } \" self . command ( cmd3 ) def get_sop ( self ) -> Tuple [ float , float , float ]: \"\"\"Query measured SOP (Stokes parameters) S1, S2, S3. Returns: The stokes parameters S1, S2, S3. \"\"\" cmd = \":MEASure:SOP? \" s1 , s2 , s3 = ( float ( i ) for i in self . query ( cmd ) . split ( ',' )) return s1 , s2 , s3 def get_dop ( self ) -> float : \"\"\"Query measured degree of polarization. Returns: The degree of polarization. \"\"\" cmd = ':MEASure:DOP?' dop = float ( self . query ( cmd )) return dop def set_sop ( self , s1 : int | float , s2 : int | float , s3 : int | float ) -> None : \"\"\"Set SOP by Stokes parameters and enable tracking. Args: s1: 1st dimention of the Stokes parameters. s2: 2nd dimention of the Stokes parameters. s3: 3rd dimention of the Stokes parameters. Tips: Stokes parameters are auto-normalized to unit vector before tracking: SOP will be set to `(s1/A, s2/A, s3/A)` where `A = sqrt(s1*s1, s2*s2, s3*s3)` Note: `s1=s2=s3=0` is not allowed. \"\"\" if s1 == s2 == s3 == 0 : raise ValueError ( \"s1=s2=s3=0 is not allowed.\" ) cmd = f \":CONTrol:SOP { s1 : .2f } , { s2 : .2f } , { s3 : .2f } \" self . command ( cmd ) def set_sop_in_spherical ( self , theta : int | float , phi : int | float ) -> None : \"\"\" Set SOP in spherical coordinates and enable tracking. Args: theta: 1st dimension in degree of the spherical coordinates. 0 to 360 (degrees). phi: 2nd dimention in degree of the spherical cordinates. 0 to 180 (degrees). \"\"\" if not 0 <= theta <= 360 : raise ValueError ( f \"Parameter theta is out of range: { theta !r} \" ) if not 0 <= phi <= 180 : raise ValueError ( f \"Parameter phi is out of range: { phi !r} \" ) cmd = f \":CONTrol:ANGLe { theta : .2f } , { phi : .2f } \" self . command ( cmd ) def start_scrambling ( self , mode : str , rate : int | float , ** params ) -> None : \"\"\"Start scrambling with specified mode and speed. Args: mode: Scrambling mode. - `DISCrete`: Discrete scrambling. - `TRIangle`: Triangle scrambling. - `TORNado`: Tornado scrambling. Additional scrambling parameter `_type` is required. rate: Scrambling rate. Different mode may have different units. params: Additional scrambling params if any. * `_type (int)`: For `TORNado` mode only. `0` = Fixed axis, `1` = Rotating axis. Note: Different mode has different unit for scrambling rate: - Discrete: points/s - Triangle: 2\u03c0 rad/s - Tornado: rev/s \"\"\" if mode . upper () . startswith ( 'DISC' ): self . _discrete_scramble ( True , rate = rate ) elif mode . upper () . startswith ( 'TRI' ): self . _triangle_scramble ( True , rate = rate ) elif mode . upper () . startswith ( 'TORN' ): self . _tornado_scramble ( True , _type = params [ '_type' ], rate = rate ) else : raise ValueError ( f \"Invalid mode: { mode !r} \" ) def stop_scrambling ( self ) -> None : self . _tornado_scramble ( False ) get_dop () \u00a4 Query measured degree of polarization. Returns: Type Description float The degree of polarization. Source code in pyinst\\models.py 5070 5071 5072 5073 5074 5075 5076 5077 5078 def get_dop ( self ) -> float : \"\"\"Query measured degree of polarization. Returns: The degree of polarization. \"\"\" cmd = ':MEASure:DOP?' dop = float ( self . query ( cmd )) return dop get_sop () \u00a4 Query measured SOP (Stokes parameters) S1, S2, S3. Returns: Type Description Tuple [ float , float , float ] The stokes parameters S1, S2, S3. Source code in pyinst\\models.py 5060 5061 5062 5063 5064 5065 5066 5067 5068 def get_sop ( self ) -> Tuple [ float , float , float ]: \"\"\"Query measured SOP (Stokes parameters) S1, S2, S3. Returns: The stokes parameters S1, S2, S3. \"\"\" cmd = \":MEASure:SOP? \" s1 , s2 , s3 = ( float ( i ) for i in self . query ( cmd ) . split ( ',' )) return s1 , s2 , s3 set_sop ( s1 , s2 , s3 ) \u00a4 Set SOP by Stokes parameters and enable tracking. Parameters: Name Type Description Default s1 int | float 1st dimention of the Stokes parameters. required s2 int | float 2nd dimention of the Stokes parameters. required s3 int | float 3rd dimention of the Stokes parameters. required Tips Stokes parameters are auto-normalized to unit vector before tracking: SOP will be set to (s1/A, s2/A, s3/A) where A = sqrt(s1*s1, s2*s2, s3*s3) Note s1=s2=s3=0 is not allowed. Source code in pyinst\\models.py 5080 5081 5082 5083 5084 5085 5086 5087 5088 5089 5090 5091 5092 5093 5094 5095 5096 5097 5098 5099 5100 5101 5102 def set_sop ( self , s1 : int | float , s2 : int | float , s3 : int | float ) -> None : \"\"\"Set SOP by Stokes parameters and enable tracking. Args: s1: 1st dimention of the Stokes parameters. s2: 2nd dimention of the Stokes parameters. s3: 3rd dimention of the Stokes parameters. Tips: Stokes parameters are auto-normalized to unit vector before tracking: SOP will be set to `(s1/A, s2/A, s3/A)` where `A = sqrt(s1*s1, s2*s2, s3*s3)` Note: `s1=s2=s3=0` is not allowed. \"\"\" if s1 == s2 == s3 == 0 : raise ValueError ( \"s1=s2=s3=0 is not allowed.\" ) cmd = f \":CONTrol:SOP { s1 : .2f } , { s2 : .2f } , { s3 : .2f } \" self . command ( cmd ) set_sop_in_spherical ( theta , phi ) \u00a4 Set SOP in spherical coordinates and enable tracking. Parameters: Name Type Description Default theta int | float 1st dimension in degree of the spherical coordinates. 0 to 360 (degrees). required phi int | float 2nd dimention in degree of the spherical cordinates. 0 to 180 (degrees). required Source code in pyinst\\models.py 5104 5105 5106 5107 5108 5109 5110 5111 5112 5113 5114 5115 5116 def set_sop_in_spherical ( self , theta : int | float , phi : int | float ) -> None : \"\"\" Set SOP in spherical coordinates and enable tracking. Args: theta: 1st dimension in degree of the spherical coordinates. 0 to 360 (degrees). phi: 2nd dimention in degree of the spherical cordinates. 0 to 180 (degrees). \"\"\" if not 0 <= theta <= 360 : raise ValueError ( f \"Parameter theta is out of range: { theta !r} \" ) if not 0 <= phi <= 180 : raise ValueError ( f \"Parameter phi is out of range: { phi !r} \" ) cmd = f \":CONTrol:ANGLe { theta : .2f } , { phi : .2f } \" self . command ( cmd ) set_wavelength ( wavelength ) \u00a4 Set optical wavelength value. Wavelength setting rounds to the nearest multiple of 5. Parameters: Name Type Description Default wavelength int | float The optical wavelength in nm. required Source code in pyinst\\models.py 4994 4995 4996 4997 4998 4999 5000 5001 5002 5003 5004 def set_wavelength ( self , wavelength : int | float ) -> None : \"\"\"Set optical wavelength value. Wavelength setting rounds to the nearest multiple of 5. Args: wavelength: The optical wavelength in nm. \"\"\" if not self . min_wavelength <= wavelength <= self . max_wavelength : raise ValueError ( f \"Parameter wavelength is out of range: { wavelength !r} \" ) cmd = f \":CONFigure:WLENgth { wavelength : d } \" self . command ( cmd ) start_scrambling ( mode , rate , ** params ) \u00a4 Start scrambling with specified mode and speed. Parameters: Name Type Description Default mode str Scrambling mode. DISCrete : Discrete scrambling. TRIangle : Triangle scrambling. TORNado : Tornado scrambling. Additional scrambling parameter _type is required. required rate int | float Scrambling rate. Different mode may have different units. required params Additional scrambling params if any. _type (int) : For TORNado mode only. 0 = Fixed axis, 1 = Rotating axis. required Note Different mode has different unit for scrambling rate: Discrete: points/s Triangle: 2\u03c0 rad/s Tornado: rev/s Source code in pyinst\\models.py 5118 5119 5120 5121 5122 5123 5124 5125 5126 5127 5128 5129 5130 5131 5132 5133 5134 5135 5136 5137 5138 5139 5140 5141 5142 5143 5144 5145 5146 def start_scrambling ( self , mode : str , rate : int | float , ** params ) -> None : \"\"\"Start scrambling with specified mode and speed. Args: mode: Scrambling mode. - `DISCrete`: Discrete scrambling. - `TRIangle`: Triangle scrambling. - `TORNado`: Tornado scrambling. Additional scrambling parameter `_type` is required. rate: Scrambling rate. Different mode may have different units. params: Additional scrambling params if any. * `_type (int)`: For `TORNado` mode only. `0` = Fixed axis, `1` = Rotating axis. Note: Different mode has different unit for scrambling rate: - Discrete: points/s - Triangle: 2\u03c0 rad/s - Tornado: rev/s \"\"\" if mode . upper () . startswith ( 'DISC' ): self . _discrete_scramble ( True , rate = rate ) elif mode . upper () . startswith ( 'TRI' ): self . _triangle_scramble ( True , rate = rate ) elif mode . upper () . startswith ( 'TORN' ): self . _tornado_scramble ( True , _type = params [ '_type' ], rate = rate ) else : raise ValueError ( f \"Invalid mode: { mode !r} \" ) ModelTC3625 \u00a4 Bases: RawSerialInstrument , TypeTS TC-36-25 is a TEC model by TE Technology. You may have to configure some parameters via the GUI provided by the vendor before your first use, this class will only perform the temperature control. Source code in pyinst\\models.py 3919 3920 3921 3922 3923 3924 3925 3926 3927 3928 3929 3930 3931 3932 3933 3934 3935 3936 3937 3938 3939 3940 3941 3942 3943 3944 3945 3946 3947 3948 3949 3950 3951 3952 3953 3954 3955 3956 3957 3958 3959 3960 3961 3962 3963 3964 3965 3966 3967 3968 3969 3970 3971 3972 3973 3974 3975 3976 3977 3978 3979 3980 3981 3982 3983 3984 3985 3986 3987 3988 3989 3990 3991 3992 3993 3994 3995 3996 3997 3998 3999 4000 4001 4002 4003 4004 4005 4006 4007 4008 4009 4010 4011 4012 4013 4014 4015 class ModelTC3625 ( RawSerialInstrument , TypeTS ): \"\"\"TC-36-25 is a TEC model by TE Technology. You may have to configure some parameters via the GUI provided by the vendor before your first use, this class will only perform the temperature control. \"\"\" model = \"TC-36-25\" brand = \"TE Technology\" def __init__ ( self , resource_name , baudrate = 9600 , read_termination = '^' , write_termination = ' \\r ' , ** kwargs ): \"\"\" Args: resource_name: Serial port name. baudrate: Baud rate such as 9600 or 115200 etc.. read_termination: Read termination character. write_termination: Write termination character. \"\"\" super ( ModelTC3625 , self ) . __init__ ( resource_name , baudrate = baudrate , read_termination = read_termination , write_termination = write_termination , ** kwargs ) @property def ts_type ( self ) -> TemperatureSourceType : return TemperatureSourceType . TEC def formatted_query ( self , cmd_code : int , value : int = 0 ) -> int : \"\"\" Send a formated command to the TEC and return the result value. Args: cmd_code: Comand code is an int between 0 and 0xFF. value: An int value sent with the command. Defaults to 0 if it is not needed. Between -0x80000000 and 0x7FFFFFFF. Returns: The \"\"\" if not 0 <= value <= 0xFF : raise ValueError ( 'Parameter cmd_code out of range: {!r} ' . format ( cmd_code )) if not - 0x80000000 <= value <= 0x7FFFFFFF : raise ValueError ( 'Parameter value out of range: {!r} ' . format ( value )) STX = '*' # Start of text character that always prepend to the cmd. ADDR = 0 # The address of this device is fixed to 0 cmd_body = ' {addr:02x}{cmd_code:02x}{val:08x} ' . format ( addr = ADDR , cmd_code = cmd_code , val = signed_to_unsigned ( value , byte_count = 4 )) check_sum = calc_check_sum ( cmd_body . encode ()) cmd = ' {pre}{cmd_body}{check_sum:02x} ' . format ( pre = STX , cmd_body = cmd_body , check_sum = check_sum ) result = self . query ( cmd )[ 1 :] result_content = result [ 0 : - 2 ] result_check_sum = int ( result [ - 2 :], base = 16 ) calculated_check_sum = calc_check_sum ( result_content . encode ()) if result_check_sum != calculated_check_sum : raise ValueError ( \"Mismatched checksum of the reply.\" ) if result_content == \"X\" * 8 : raise ValueError ( \"Mismatched checksum of the command.\" ) result_value = unsigned_to_signed ( int ( result_content , base = 16 ), 4 ) return result_value # def check_connection(self) -> ConnectionStatus: # try: # self.get_target_temp() # return ConnectionStatus(True) # except Exception as e: # return ConnectionStatus(False, e.args[0] if e.args else None) def set_target_temp ( self , value : int | float ) -> None : cmd_value = round ( value * 100 ) rtn_value = self . formatted_query ( 0x1c , cmd_value ) if cmd_value != rtn_value : raise ValueError ( 'The return value mismatched with the cmd value: {!r} / {!r} ' . format ( rtn_value , cmd_value )) def get_target_temp ( self ) -> float : rtn_value = self . formatted_query ( 0x03 ) t = rtn_value / 100 return t def get_current_temp ( self ) -> float : rtn_value = self . formatted_query ( 0x01 ) t = rtn_value / 100 return t def set_temp_unit ( self , unit : TemperatureUnit ) -> None : unit = TemperatureUnit ( unit ) rtn_value = self . formatted_query ( 0x32 , unit . value ) if rtn_value != unit . value : raise ValueError ( 'The return value mismatched with the cmd value: {!r} / {!r} ' . format ( rtn_value , unit )) def get_temp_unit ( self ) -> TemperatureUnit : rtn_value = self . formatted_query ( 0x4b ) return TemperatureUnit ( rtn_value ) __init__ ( resource_name , baudrate = 9600 , read_termination = '^' , write_termination = ' \\r ' , ** kwargs ) \u00a4 Parameters: Name Type Description Default resource_name Serial port name. required baudrate Baud rate such as 9600 or 115200 etc.. 9600 read_termination Read termination character. '^' write_termination Write termination character. '\\r' Source code in pyinst\\models.py 3927 3928 3929 3930 3931 3932 3933 3934 3935 3936 3937 3938 3939 3940 3941 3942 3943 3944 def __init__ ( self , resource_name , baudrate = 9600 , read_termination = '^' , write_termination = ' \\r ' , ** kwargs ): \"\"\" Args: resource_name: Serial port name. baudrate: Baud rate such as 9600 or 115200 etc.. read_termination: Read termination character. write_termination: Write termination character. \"\"\" super ( ModelTC3625 , self ) . __init__ ( resource_name , baudrate = baudrate , read_termination = read_termination , write_termination = write_termination , ** kwargs ) formatted_query ( cmd_code , value = 0 ) \u00a4 Send a formated command to the TEC and return the result value. Parameters: Name Type Description Default cmd_code int Comand code is an int between 0 and 0xFF. required value int An int value sent with the command. Defaults to 0 if it is not needed. Between -0x80000000 and 0x7FFFFFFF. 0 Returns: Type Description int The Source code in pyinst\\models.py 3950 3951 3952 3953 3954 3955 3956 3957 3958 3959 3960 3961 3962 3963 3964 3965 3966 3967 3968 3969 3970 3971 3972 3973 3974 3975 3976 3977 3978 3979 3980 3981 3982 def formatted_query ( self , cmd_code : int , value : int = 0 ) -> int : \"\"\" Send a formated command to the TEC and return the result value. Args: cmd_code: Comand code is an int between 0 and 0xFF. value: An int value sent with the command. Defaults to 0 if it is not needed. Between -0x80000000 and 0x7FFFFFFF. Returns: The \"\"\" if not 0 <= value <= 0xFF : raise ValueError ( 'Parameter cmd_code out of range: {!r} ' . format ( cmd_code )) if not - 0x80000000 <= value <= 0x7FFFFFFF : raise ValueError ( 'Parameter value out of range: {!r} ' . format ( value )) STX = '*' # Start of text character that always prepend to the cmd. ADDR = 0 # The address of this device is fixed to 0 cmd_body = ' {addr:02x}{cmd_code:02x}{val:08x} ' . format ( addr = ADDR , cmd_code = cmd_code , val = signed_to_unsigned ( value , byte_count = 4 )) check_sum = calc_check_sum ( cmd_body . encode ()) cmd = ' {pre}{cmd_body}{check_sum:02x} ' . format ( pre = STX , cmd_body = cmd_body , check_sum = check_sum ) result = self . query ( cmd )[ 1 :] result_content = result [ 0 : - 2 ] result_check_sum = int ( result [ - 2 :], base = 16 ) calculated_check_sum = calc_check_sum ( result_content . encode ()) if result_check_sum != calculated_check_sum : raise ValueError ( \"Mismatched checksum of the reply.\" ) if result_content == \"X\" * 8 : raise ValueError ( \"Mismatched checksum of the command.\" ) result_value = unsigned_to_signed ( int ( result_content , base = 16 ), 4 ) return result_value","title":"Instrument Models"},{"location":"api/models/#pyinst.models.BaseModel815x_VOA","text":"Bases: VisaInstrument , TypeVOA Base class of Keysight 815x variable optical attenuators. Source code in pyinst\\models.py 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 class BaseModel815x_VOA ( VisaInstrument , TypeVOA ): \"\"\"Base class of Keysight 815x variable optical attenuators.\"\"\" def __init__ ( self , resource_name : str , slot : int , channel : int , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: slot number in the frame. channel: channel number. kwargs: directly passed to `VisaInstrument.__init__` \"\"\" super () . __init__ ( resource_name , ** kwargs ) self . _slot = slot self . _channel = channel @property def min_frequency ( self ) -> float : return super () . min_frequency @property def max_frequency ( self ) -> float : return super () . max_frequency @property def min_wavelength ( self ) -> float : cmd = \":INPut {slot:d} :CHANnel {channel:d} :WAVelength? MIN\" . format ( slot = self . _slot , channel = self . _channel ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl @property def max_wavelength ( self ) -> float : cmd = \":INPut {slot:d} :CHANnel {channel:d} :WAVelength? MAX\" . format ( slot = self . _slot , channel = self . _channel ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl @property def min_att ( self ) -> float : cmd = \":INPut {slot:d} :CHANnel {channel:d} :ATTenuation? MIN\" . format ( slot = self . _slot , channel = self . _channel ) att = float ( self . query ( cmd )) return att @property def max_att ( self ) -> float : cmd = \":INPut {slot:d} :CHANnel {channel:d} :ATTenuation? MAX\" . format ( slot = self . _slot , channel = self . _channel ) att = float ( self . query ( cmd )) return att @property def min_att_offset ( self ) -> float : cmd = \":INPut {slot:d} :CHANnel {channel:d} :OFFSet? MIN\" . format ( slot = self . _slot , channel = self . _channel ) offset = float ( self . query ( cmd )) return offset @property def max_att_offset ( self ) -> float : cmd = \":INPut {slot:d} :CHANnel {channel:d} :OFFSet? MAX\" . format ( slot = self . _slot , channel = self . _channel ) offset = float ( self . query ( cmd )) return offset def get_frequency ( self ) -> float : return super () . get_frequency () def set_frequency ( self , frequency : int | float ) -> None : return super () . set_frequency ( frequency ) def get_wavelength ( self ) -> float : cmd = \":INPut {slot:d} :CHANnel {channel:d} :WAVelength?\" . format ( slot = self . _slot , channel = self . _channel ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl def set_wavelength ( self , wavelength : int | float ) -> None : if not self . min_wavelength <= wavelength <= self . max_wavelength : raise ValueError ( \"param wavelength out of range: {wl} \" . format ( wl = wavelength )) cmd = \":INPut {slot:d} :CHANnel {channel:d} :WAVelength {wl:.4f} NM\" . format ( slot = self . _slot , channel = self . _channel , wl = wavelength ) self . command ( cmd ) def enable ( self , en : bool = True ) -> None : if not isinstance ( en , bool ): raise TypeError ( \"param en should be bool\" ) cmd = \":OUTPut {slot:d} :CHANnel {channel:d} :STATe {state:d} \" . format ( slot = self . _slot , channel = self . _channel , state = en ) self . command ( cmd ) def disable ( self ) -> None : self . enable ( False ) def is_enabled ( self ) -> bool : cmd = \":OUTPut {slot:d} :CHANnel {channel:d} :STATe?\" . format ( slot = self . _slot , channel = self . _channel ) status = bool ( int ( self . query ( cmd ))) return status def get_att ( self ) -> float : cmd = \":INPut {slot:d} :CHANnel {channel:d} :ATTenuation?\" . format ( slot = self . _slot , channel = self . _channel ) att = float ( self . query ( cmd )) return att def set_att ( self , att : int | float ) -> None : if not self . min_att <= att <= self . max_att : raise ValueError ( \"param att out of range: {att} \" . format ( att = att )) cmd = \":INPut {slot:d} :CHANnel {channel:d} :ATTenuation {att:.3f} DB\" . format ( slot = self . _slot , channel = self . _channel , att = att ) self . command ( cmd ) def get_att_offset ( self ) -> float : cmd = \":INPut {slot:d} :CHANnel {channel:d} :OFFSet?\" . format ( slot = self . _slot , channel = self . _channel ) offset = float ( self . query ( cmd )) return offset def set_att_offset ( self , offset : int | float ) -> None : if not self . min_att_offset <= offset <= self . max_att_offset : raise ValueError ( \"param offset out of range: {offset} \" . format ( offset = offset )) cmd = \":INPut {slot:d} :CHANnel {channel:d} :OFFSet {offset:.3f} DB\" . format ( slot = self . _slot , channel = self . _channel , offset = offset ) self . command ( cmd )","title":"BaseModel815x_VOA"},{"location":"api/models/#pyinst.models.BaseModel815x_VOA.__init__","text":"Parameters: Name Type Description Default resource_name str Resource name or alias of the VISA resource to open. required slot int slot number in the frame. required channel int channel number. required kwargs directly passed to VisaInstrument.__init__ required Source code in pyinst\\models.py 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 def __init__ ( self , resource_name : str , slot : int , channel : int , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: slot number in the frame. channel: channel number. kwargs: directly passed to `VisaInstrument.__init__` \"\"\" super () . __init__ ( resource_name , ** kwargs ) self . _slot = slot self . _channel = channel","title":"__init__()"},{"location":"api/models/#pyinst.models.BaseModel816x_OPM","text":"Bases: VisaInstrument , TypeOPM Base class of Keysight 816x optical power meters. Source code in pyinst\\models.py 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 1791 1792 1793 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 class BaseModel816x_OPM ( VisaInstrument , TypeOPM ): \"\"\"Base class of Keysight 816x optical power meters.\"\"\" def __init__ ( self , resource_name : str , slot : int , channel : int , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: slot number in the frame. channel: channel number. kwargs: directly passed to `VisaInstrument.__init__`. \"\"\" super () . __init__ ( resource_name , ** kwargs ) self . _slot = slot self . _channel = channel @property def min_frequency ( self ) -> float : return super () . min_frequency @property def max_frequency ( self ) -> float : return super () . max_frequency @property def min_wavelength ( self ) -> float : cmd = \":SENSe {slot:d} :CHANnel {channel:d} :POWer:WAVelength? MIN\" . format ( slot = self . _slot , channel = self . _channel ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl @property def max_wavelength ( self ) -> float : cmd = \":SENSe {slot:d} :CHANnel {channel:d} :POWer:WAVelength? MAX\" . format ( slot = self . _slot , channel = self . _channel ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl @property def min_avg_time ( self ) -> float : return 0.1 # 100us @property def max_avg_time ( self ) -> float : return 10000 # 10s @property def min_pow_cal ( self ) -> float : return - 200 @property def max_pow_cal ( self ) -> float : return 200 def get_frequency ( self ) -> float : return super () . get_frequency () def set_frequency ( self , frequency : int | float ) -> None : return super () . set_frequency ( frequency ) def get_wavelength ( self ) -> float : cmd = \":SENSe {slot:d} :CHANnel {channel:d} :POWer:WAVelength?\" . format ( slot = self . _slot , channel = self . _channel ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl def set_wavelength ( self , wavelength : int | float ) -> None : if not self . min_wavelength <= wavelength <= self . max_wavelength : raise ValueError ( \"param wavelength out of range: {wl} \" . format ( wl = wavelength )) cmd = \":SENSe {slot:d} :CHANnel {channel:d} :POWer:WAVelength {wl:.4f} NM\" . format ( slot = self . _slot , channel = self . _channel , wl = wavelength ) self . command ( cmd ) def get_power_value ( self ) -> float : cmd = \":FETCh {slot:d} :CHANnel {channel:d} :POWer?\" . format ( slot = self . _slot , channel = self . _channel ) value = float ( self . query ( cmd )) return value def get_power_unit ( self ) -> OpticalPowerUnit : cmd = \":SENSe {slot:d} :CHANnel {channel:d} :POWer:UNIT?\" . format ( slot = self . _slot , channel = self . _channel ) unit_int = int ( self . query ( cmd )) return OpticalPowerUnit ( unit_int ) def set_power_unit ( self , unit : OpticalPowerUnit ) -> None : unit = OpticalPowerUnit ( unit ) cmd = \":SENSe {slot:d} :CHANnel {channel:d} :POWer:UNIT {unit:d} \" . format ( slot = self . _slot , channel = self . _channel , unit = unit ) self . command ( cmd ) def get_pow_cal ( self ) -> float : cmd = \":SENSe {slot:d} :CHANnel {channel:d} :CORRection?\" . format ( slot = self . _slot , channel = self . _channel ) cal = float ( self . query ( cmd )) return cal def set_pow_cal ( self , value : int | float ) -> None : if not self . min_pow_cal <= value <= self . max_pow_cal : raise ValueError ( \"param value out of range: {value} \" . format ( value = value )) cmd = \":SENSe {slot:d} :CHANnel {channel:d} :CORRection {value:.4f} DB\" . format ( slot = self . _slot , channel = self . _channel , value = value ) self . command ( cmd ) def get_avg_time ( self ) -> float : cmd = \":SENSe {slot:d} :CHANnel {channel:d} :POWer:ATIMe?\" . format ( slot = self . _slot , channel = self . _channel ) avg_t = float ( self . query ( cmd )) * 1000 return avg_t def set_avg_time ( self , value : int | float ) -> None : if not self . min_avg_time <= value <= self . max_avg_time : raise ValueError ( \"param value out of range: {value} \" . format ( value = value )) cmd = \":SENSe {slot:d} :CHANnel {channel:d} :POWer:ATIMe {value:.4f} \" . format ( slot = self . _slot , channel = self . _channel , value = value ) self . command ( cmd )","title":"BaseModel816x_OPM"},{"location":"api/models/#pyinst.models.BaseModel816x_OPM.__init__","text":"Parameters: Name Type Description Default resource_name str Resource name or alias of the VISA resource to open. required slot int slot number in the frame. required channel int channel number. required kwargs directly passed to VisaInstrument.__init__ . required Source code in pyinst\\models.py 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 def __init__ ( self , resource_name : str , slot : int , channel : int , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: slot number in the frame. channel: channel number. kwargs: directly passed to `VisaInstrument.__init__`. \"\"\" super () . __init__ ( resource_name , ** kwargs ) self . _slot = slot self . _channel = channel","title":"__init__()"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_OPM","text":"Bases: VisaInstrument , TypeOPM Base Model of AQ2200 Series, application type Sensor. Source code in pyinst\\models.py 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 class BaseModelAQ2200_OPM ( VisaInstrument , TypeOPM ): \"\"\"Base Model of AQ2200 Series, application type Sensor.\"\"\" def __init__ ( self , resource_name : str , slot : int , channel : int , ** kwargs ) -> None : \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: slot number in the frame channel: channel number kwargs: directly passed to `VisaInstrument.__init__` \"\"\" super ( BaseModelAQ2200_OPM , self ) . __init__ ( resource_name , read_termination = '' , ** kwargs ) self . _slot = slot self . _channel = channel @property def min_frequency ( self ) -> float : return super () . min_frequency @property def max_frequency ( self ) -> float : return super () . max_frequency @property def min_wavelength ( self ) -> float : cmd = \":SENS {slot:d} :CHAN {slot:d} :POW:WAV? MIN\" . format ( slot = self . _slot , channel = self . _channel ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl @property def max_wavelength ( self ) -> float : cmd = \":SENS {slot:d} :CHAN {slot:d} :POW:WAV? MAX\" . format ( slot = self . _slot , channel = self . _channel ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl @property def min_avg_time ( self ) -> float : return 0.1 # 100us @property def max_avg_time ( self ) -> float : return 10000 # 10s @property def avg_time_table ( self ) -> tuple : \"\"\" AQ-2200 Series OPM only support discrete averaging values. This table contains all the valid averaging time value. If the averaging time value set with self.set_avg_time() is not valid, a warning will be displayed and the value will fall back to the closest value in this table. No exception will be raised. \"\"\" return ( 0.1 , 0.2 , 0.5 , 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 , 500 , 1000 , 2000 , 5000 , 10000 , ) @property def min_pow_cal ( self ) -> float : return - 180 @property def max_pow_cal ( self ) -> float : return 200 def get_frequency ( self ) -> float : return super () . get_frequency () def set_frequency ( self , frequency : int | float ) -> None : return super () . set_frequency ( frequency ) def get_wavelength ( self ) -> float : cmd = \":SENS {slot:d} :CHAN {channel:d} :POW:WAV?\" . format ( slot = self . _slot , channel = self . _channel ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl def set_wavelength ( self , wavelength : int | float ) -> None : if not self . min_wavelength <= wavelength <= self . max_wavelength : raise ValueError ( \"param wavelength out of range: {wl} \" . format ( wl = wavelength )) cmd = \":SENS {slot:d} :CHAN {channel:d} :POW:WAV {wl} NM\" . format ( slot = self . _slot , channel = self . _channel , wl = wavelength ) self . command ( cmd ) def get_power_value ( self ) -> float : cmd = \":FETC {slot} :CHAN {channel} :POW?\" . format ( slot = self . _slot , channel = self . _channel ) power = float ( self . query ( cmd )) return power def get_power_unit ( self ) -> OpticalPowerUnit : cmd = \":SENS {slot:d} :CHAN {channel:d} :POW:UNIT?\" . format ( slot = self . _slot , channel = self . _channel ) unit_int = int ( self . query ( cmd )) return OpticalPowerUnit ( unit_int ) def set_power_unit ( self , unit : OpticalPowerUnit ) -> None : unit = OpticalPowerUnit ( unit ) cmd = \":SENS {slot:d} :CHAN {channel:d} :POW:UNIT {unit:d} \" . format ( slot = self . _slot , channel = self . _channel , unit = unit ) self . command ( cmd ) def get_pow_cal ( self ) -> float : cmd = \":SENS {slot:d} :CHAN {channel:d} :CORR?\" . format ( slot = self . _slot , channel = self . _channel ) cal = float ( self . query ( cmd )) return cal def set_pow_cal ( self , value : int | float ) -> None : if not self . min_pow_cal <= value <= self . max_pow_cal : raise ValueError ( \"param value out of range: {value} \" . format ( value = value )) cmd = \":SENS {slot:d} :CHAN {channel:d} :CORR {value:.4f} DB\" . format ( slot = self . _slot , channel = self . _channel , value = value ) self . command ( cmd ) def get_avg_time ( self ) -> float : cmd = \":SENS {slot:d} :CHAN {channel:d} :POW:ATIM?\" . format ( slot = self . _slot , channel = self . _channel ) avg_t = float ( self . query ( cmd )) * 1000 return avg_t def set_avg_time ( self , value : int | float ) -> None : if not self . min_avg_time <= value <= self . max_avg_time : raise ValueError ( \"param value out of range: {value} \" . format ( value = value )) value = round ( value , 1 ) if value in self . avg_time_table : valid_value = value else : l = list ( self . avg_time_table ) l . sort ( key = lambda x : abs ( x - value )) valid_value = l [ 0 ] warnings . warn ( \"Averaging time value {value} not valid. \" \"Fall back to the closest valid value {valid_value} .\" . format ( value = value , valid_value = valid_value ), InstrWarning ) if valid_value < 1 : v = round ( valid_value * 1000 ) u = \"US\" else : v = valid_value u = \"MS\" cmd = \":SENS {slot:d} :CHAN {channel:d} :POW:ATIM {value:d}{unit} \" . format ( slot = self . _slot , channel = self . _channel , value = v , unit = u ) self . command ( cmd )","title":"BaseModelAQ2200_OPM"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_OPM.__init__","text":"Parameters: Name Type Description Default resource_name str Resource name or alias of the VISA resource to open. required slot int slot number in the frame required channel int channel number required kwargs directly passed to VisaInstrument.__init__ required Source code in pyinst\\models.py 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 def __init__ ( self , resource_name : str , slot : int , channel : int , ** kwargs ) -> None : \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: slot number in the frame channel: channel number kwargs: directly passed to `VisaInstrument.__init__` \"\"\" super ( BaseModelAQ2200_OPM , self ) . __init__ ( resource_name , read_termination = '' , ** kwargs ) self . _slot = slot self . _channel = channel","title":"__init__()"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_OPM.avg_time_table","text":"AQ-2200 Series OPM only support discrete averaging values. This table contains all the valid averaging time value. If the averaging time value set with self.set_avg_time() is not valid, a warning will be displayed and the value will fall back to the closest value in this table. No exception will be raised. Source code in pyinst\\models.py 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 @property def avg_time_table ( self ) -> tuple : \"\"\" AQ-2200 Series OPM only support discrete averaging values. This table contains all the valid averaging time value. If the averaging time value set with self.set_avg_time() is not valid, a warning will be displayed and the value will fall back to the closest value in this table. No exception will be raised. \"\"\" return ( 0.1 , 0.2 , 0.5 , 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 , 500 , 1000 , 2000 , 5000 , 10000 , )","title":"avg_time_table()"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_VOA","text":"Bases: VisaInstrument , TypeVOA The base class of AQ2200 Series, application type ATTN, without built-in OPM. Source code in pyinst\\models.py 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 class BaseModelAQ2200_VOA ( VisaInstrument , TypeVOA ): \"\"\"The base class of AQ2200 Series, application type ATTN, without built-in OPM.\"\"\" def __init__ ( self , resource_name : str , slot : int , channel : int , ** kwargs ) -> None : \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: The slot number in the frame. channel: The channel number. **kwargs: Directly passed to `VisaInstrument.__init__` \"\"\" super () . __init__ ( resource_name , read_termination = '' , ** kwargs ) self . _slot = slot self . _channel = channel @property def min_frequency ( self ) -> float : \"\"\"The minimum settable optical frequency value in THz.\"\"\" return super () . min_frequency @property def max_frequency ( self ) -> float : \"\"\"The maximum settable optical frequency value in THz.\"\"\" return super () . max_frequency @property def min_wavelength ( self ) -> float : \"\"\"The minimum settable optical wavelength value in nm.\"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :WAV? MIN\" . format ( slot = self . _slot , channel = self . _channel ) wl_str = self . query ( cmd ) wl = float ( wl_str ) * 10 ** 9 return wl @property def max_wavelength ( self ) -> float : \"\"\"The maximum settable optical wavelength value in nm.\"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :WAV? MAX\" . format ( slot = self . _slot , channel = self . _channel ) wl_str = self . query ( cmd ) wl = float ( wl_str ) * 10 ** 9 return wl @property def min_att ( self ) -> float : \"\"\"Minimum settable attenuation in dB. The minimum settable attenuation = 0 dB + the optical attenuation offset value. \"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :ATT? MIN\" . format ( slot = self . _slot , channel = self . _channel ) att = float ( self . query ( cmd )) return att @property def max_att ( self ) -> float : \"\"\"Maximum settable attenuation in dB. The maximum settable attenuation = The maximum attenuation + the optical attenuation offset value. \"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :ATT? MAX\" . format ( slot = self . _slot , channel = self . _channel ) att = float ( self . query ( cmd )) return att @property def min_att_offset ( self ) -> float : \"\"\"Minimum attenuation offset value in dB.\"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :OFFS? MIN\" . format ( slot = self . _slot , channel = self . _channel ) offset = float ( self . query ( cmd )) return offset @property def max_att_offset ( self ) -> float : \"\"\"Maximum attenuation offset value in dB.\"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :OFFS? MAX\" . format ( slot = self . _slot , channel = self . _channel ) offset = float ( self . query ( cmd )) return offset def get_frequency ( self ) -> float : \"\"\" Queries the optical frequency setting of the instrument in THz. Returns: The optical frequency setting value in THz. \"\"\" return super () . get_frequency () def set_frequency ( self , frequency : int | float ) -> None : \"\"\"Set optical frequency. Args: frequency: The optical frequency setting in THz. \"\"\" return super () . set_frequency ( frequency ) def get_wavelength ( self ) -> float : \"\"\"Queries the optical wavelength setting of the instrument in nm. Returns: The optical wavelength setting value in nm. \"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :WAV?\" . format ( slot = self . _slot , channel = self . _channel ) wl_str = self . query ( cmd ) wl = float ( wl_str ) * 10 ** 9 return wl def set_wavelength ( self , wavelength : int | float ) -> None : \"\"\"Set optical wavelength. Args: wavelength: The optical wavelength setting in nm. \"\"\" if not self . min_wavelength <= wavelength <= self . max_wavelength : raise ValueError ( f 'Parameter wavelength is out of range: { wavelength !r} ' ) cmd = \":INP {slot:d} :CHAN {channel:d} :WAV {wl:f} NM\" . format ( slot = self . _slot , channel = self . _channel , wl = wavelength ) self . command ( cmd ) def enable ( self , en : bool = True ) -> None : \"\"\" Enable (disable) the optical output. Args: en: True = Enable, False = Disable. \"\"\" if not isinstance ( en , bool ): raise TypeError ( f \"Parameter en must be a bool, not ' { type ( en ) . __name__ } '.\" ) cmd = \":OUTP {slot:d} :CHAN {channel:d} {en:d} \" . format ( slot = self . _slot , channel = self . _channel , en = en ) self . command ( cmd ) def disable ( self ) -> None : \"\"\"Disable the optical output.\"\"\" self . enable ( False ) def is_enabled ( self ) -> bool : \"\"\" Returns: Whether the optical output is enabled. \"\"\" cmd = \":OUTP {slot:d} :CHAN {channel:d} ?\" . format ( slot = self . _slot , channel = self . _channel ) return bool ( int ( self . query ( cmd ))) def get_att ( self ) -> float : \"\"\" Get the current attenuation value in dB. Includes the attenuation offset. Queried attenuator = the actual attenuator value + attenuator offset Use `get_att_offset` and `set_att_offset` to operate with the attenuator offset. Returns: The attenuation value in dB. \"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :ATT?\" . format ( slot = self . _slot , channel = self . _channel ) att = float ( self . query ( cmd )) return att def set_att ( self , att : int | float ) -> None : \"\"\" Set attenuation value in dB. Includes the attenuation offset. Refer to `get_att` for more information. Args: att: The attenuation value in dB. \"\"\" if not self . min_att <= att <= self . max_att : raise ValueError ( f 'Parameter att is out of range: { att !r} ' ) cmd = \":INP {slot:d} :CHAN {channel:d} :ATT {att:.3f} dB\" . format ( slot = self . _slot , channel = self . _channel , att = att ) self . command ( cmd ) def get_att_offset ( self ) -> float : \"\"\" Get the attenuation offset value in dB. Returns: The attenuation offset in dB. \"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :OFFS?\" . format ( slot = self . _slot , channel = self . _channel ) offset = float ( self . query ( cmd )) return offset def set_att_offset ( self , offset : int | float ) -> None : \"\"\" Set the attenuation offset value in dB. Args: offset: The attenuation offset in dB. \"\"\" if not self . min_att_offset <= offset <= self . max_att_offset : raise ValueError ( f \"Parameter offset is out of range: { offset !r} \" ) cmd = \":INP {slot:d} :CHAN {channel:d} :OFFS {offset:.3f} dB\" . format ( slot = self . _slot , channel = self . _channel , offset = offset ) self . command ( cmd )","title":"BaseModelAQ2200_VOA"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_VOA.__init__","text":"Parameters: Name Type Description Default resource_name str Resource name or alias of the VISA resource to open. required slot int The slot number in the frame. required channel int The channel number. required **kwargs Directly passed to VisaInstrument.__init__ {} Source code in pyinst\\models.py 950 951 952 953 954 955 956 957 958 959 960 def __init__ ( self , resource_name : str , slot : int , channel : int , ** kwargs ) -> None : \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: The slot number in the frame. channel: The channel number. **kwargs: Directly passed to `VisaInstrument.__init__` \"\"\" super () . __init__ ( resource_name , read_termination = '' , ** kwargs ) self . _slot = slot self . _channel = channel","title":"__init__()"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_VOA.disable","text":"Disable the optical output. Source code in pyinst\\models.py 1075 1076 1077 def disable ( self ) -> None : \"\"\"Disable the optical output.\"\"\" self . enable ( False )","title":"disable()"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_VOA.enable","text":"Enable (disable) the optical output. Parameters: Name Type Description Default en bool True = Enable, False = Disable. True Source code in pyinst\\models.py 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 def enable ( self , en : bool = True ) -> None : \"\"\" Enable (disable) the optical output. Args: en: True = Enable, False = Disable. \"\"\" if not isinstance ( en , bool ): raise TypeError ( f \"Parameter en must be a bool, not ' { type ( en ) . __name__ } '.\" ) cmd = \":OUTP {slot:d} :CHAN {channel:d} {en:d} \" . format ( slot = self . _slot , channel = self . _channel , en = en ) self . command ( cmd )","title":"enable()"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_VOA.get_att","text":"Get the current attenuation value in dB. Includes the attenuation offset. Queried attenuator = the actual attenuator value + attenuator offset Use get_att_offset and set_att_offset to operate with the attenuator offset. Returns: Type Description float The attenuation value in dB. Source code in pyinst\\models.py 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 def get_att ( self ) -> float : \"\"\" Get the current attenuation value in dB. Includes the attenuation offset. Queried attenuator = the actual attenuator value + attenuator offset Use `get_att_offset` and `set_att_offset` to operate with the attenuator offset. Returns: The attenuation value in dB. \"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :ATT?\" . format ( slot = self . _slot , channel = self . _channel ) att = float ( self . query ( cmd )) return att","title":"get_att()"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_VOA.get_att_offset","text":"Get the attenuation offset value in dB. Returns: Type Description float The attenuation offset in dB. Source code in pyinst\\models.py 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 def get_att_offset ( self ) -> float : \"\"\" Get the attenuation offset value in dB. Returns: The attenuation offset in dB. \"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :OFFS?\" . format ( slot = self . _slot , channel = self . _channel ) offset = float ( self . query ( cmd )) return offset","title":"get_att_offset()"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_VOA.get_frequency","text":"Queries the optical frequency setting of the instrument in THz. Returns: Type Description float The optical frequency setting value in THz. Source code in pyinst\\models.py 1024 1025 1026 1027 1028 1029 1030 1031 def get_frequency ( self ) -> float : \"\"\" Queries the optical frequency setting of the instrument in THz. Returns: The optical frequency setting value in THz. \"\"\" return super () . get_frequency ()","title":"get_frequency()"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_VOA.get_wavelength","text":"Queries the optical wavelength setting of the instrument in nm. Returns: Type Description float The optical wavelength setting value in nm. Source code in pyinst\\models.py 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 def get_wavelength ( self ) -> float : \"\"\"Queries the optical wavelength setting of the instrument in nm. Returns: The optical wavelength setting value in nm. \"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :WAV?\" . format ( slot = self . _slot , channel = self . _channel ) wl_str = self . query ( cmd ) wl = float ( wl_str ) * 10 ** 9 return wl","title":"get_wavelength()"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_VOA.is_enabled","text":"Returns: Type Description bool Whether the optical output is enabled. Source code in pyinst\\models.py 1079 1080 1081 1082 1083 1084 1085 def is_enabled ( self ) -> bool : \"\"\" Returns: Whether the optical output is enabled. \"\"\" cmd = \":OUTP {slot:d} :CHAN {channel:d} ?\" . format ( slot = self . _slot , channel = self . _channel ) return bool ( int ( self . query ( cmd )))","title":"is_enabled()"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_VOA.max_att","text":"Maximum settable attenuation in dB. The maximum settable attenuation = The maximum attenuation + the optical attenuation offset value. Source code in pyinst\\models.py 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 @property def max_att ( self ) -> float : \"\"\"Maximum settable attenuation in dB. The maximum settable attenuation = The maximum attenuation + the optical attenuation offset value. \"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :ATT? MAX\" . format ( slot = self . _slot , channel = self . _channel ) att = float ( self . query ( cmd )) return att","title":"max_att()"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_VOA.max_att_offset","text":"Maximum attenuation offset value in dB. Source code in pyinst\\models.py 1017 1018 1019 1020 1021 1022 @property def max_att_offset ( self ) -> float : \"\"\"Maximum attenuation offset value in dB.\"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :OFFS? MAX\" . format ( slot = self . _slot , channel = self . _channel ) offset = float ( self . query ( cmd )) return offset","title":"max_att_offset()"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_VOA.max_frequency","text":"The maximum settable optical frequency value in THz. Source code in pyinst\\models.py 967 968 969 970 @property def max_frequency ( self ) -> float : \"\"\"The maximum settable optical frequency value in THz.\"\"\" return super () . max_frequency","title":"max_frequency()"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_VOA.max_wavelength","text":"The maximum settable optical wavelength value in nm. Source code in pyinst\\models.py 980 981 982 983 984 985 986 @property def max_wavelength ( self ) -> float : \"\"\"The maximum settable optical wavelength value in nm.\"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :WAV? MAX\" . format ( slot = self . _slot , channel = self . _channel ) wl_str = self . query ( cmd ) wl = float ( wl_str ) * 10 ** 9 return wl","title":"max_wavelength()"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_VOA.min_att","text":"Minimum settable attenuation in dB. The minimum settable attenuation = 0 dB + the optical attenuation offset value. Source code in pyinst\\models.py 988 989 990 991 992 993 994 995 996 997 @property def min_att ( self ) -> float : \"\"\"Minimum settable attenuation in dB. The minimum settable attenuation = 0 dB + the optical attenuation offset value. \"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :ATT? MIN\" . format ( slot = self . _slot , channel = self . _channel ) att = float ( self . query ( cmd )) return att","title":"min_att()"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_VOA.min_att_offset","text":"Minimum attenuation offset value in dB. Source code in pyinst\\models.py 1010 1011 1012 1013 1014 1015 @property def min_att_offset ( self ) -> float : \"\"\"Minimum attenuation offset value in dB.\"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :OFFS? MIN\" . format ( slot = self . _slot , channel = self . _channel ) offset = float ( self . query ( cmd )) return offset","title":"min_att_offset()"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_VOA.min_frequency","text":"The minimum settable optical frequency value in THz. Source code in pyinst\\models.py 962 963 964 965 @property def min_frequency ( self ) -> float : \"\"\"The minimum settable optical frequency value in THz.\"\"\" return super () . min_frequency","title":"min_frequency()"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_VOA.min_wavelength","text":"The minimum settable optical wavelength value in nm. Source code in pyinst\\models.py 972 973 974 975 976 977 978 @property def min_wavelength ( self ) -> float : \"\"\"The minimum settable optical wavelength value in nm.\"\"\" cmd = \":INP {slot:d} :CHAN {channel:d} :WAV? MIN\" . format ( slot = self . _slot , channel = self . _channel ) wl_str = self . query ( cmd ) wl = float ( wl_str ) * 10 ** 9 return wl","title":"min_wavelength()"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_VOA.set_att","text":"Set attenuation value in dB. Includes the attenuation offset. Refer to get_att for more information. Parameters: Name Type Description Default att int | float The attenuation value in dB. required Source code in pyinst\\models.py 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 def set_att ( self , att : int | float ) -> None : \"\"\" Set attenuation value in dB. Includes the attenuation offset. Refer to `get_att` for more information. Args: att: The attenuation value in dB. \"\"\" if not self . min_att <= att <= self . max_att : raise ValueError ( f 'Parameter att is out of range: { att !r} ' ) cmd = \":INP {slot:d} :CHAN {channel:d} :ATT {att:.3f} dB\" . format ( slot = self . _slot , channel = self . _channel , att = att ) self . command ( cmd )","title":"set_att()"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_VOA.set_att_offset","text":"Set the attenuation offset value in dB. Parameters: Name Type Description Default offset int | float The attenuation offset in dB. required Source code in pyinst\\models.py 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 def set_att_offset ( self , offset : int | float ) -> None : \"\"\" Set the attenuation offset value in dB. Args: offset: The attenuation offset in dB. \"\"\" if not self . min_att_offset <= offset <= self . max_att_offset : raise ValueError ( f \"Parameter offset is out of range: { offset !r} \" ) cmd = \":INP {slot:d} :CHAN {channel:d} :OFFS {offset:.3f} dB\" . format ( slot = self . _slot , channel = self . _channel , offset = offset ) self . command ( cmd )","title":"set_att_offset()"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_VOA.set_frequency","text":"Set optical frequency. Parameters: Name Type Description Default frequency int | float The optical frequency setting in THz. required Source code in pyinst\\models.py 1033 1034 1035 1036 1037 1038 1039 def set_frequency ( self , frequency : int | float ) -> None : \"\"\"Set optical frequency. Args: frequency: The optical frequency setting in THz. \"\"\" return super () . set_frequency ( frequency )","title":"set_frequency()"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_VOA.set_wavelength","text":"Set optical wavelength. Parameters: Name Type Description Default wavelength int | float The optical wavelength setting in nm. required Source code in pyinst\\models.py 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 def set_wavelength ( self , wavelength : int | float ) -> None : \"\"\"Set optical wavelength. Args: wavelength: The optical wavelength setting in nm. \"\"\" if not self . min_wavelength <= wavelength <= self . max_wavelength : raise ValueError ( f 'Parameter wavelength is out of range: { wavelength !r} ' ) cmd = \":INP {slot:d} :CHAN {channel:d} :WAV {wl:f} NM\" . format ( slot = self . _slot , channel = self . _channel , wl = wavelength ) self . command ( cmd )","title":"set_wavelength()"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_VOA_with_OPM","text":"Bases: BaseModelAQ2200_VOA , TypeOPM The base class of AQ2200 Series, application type ATTN, with built-in OPM. Source code in pyinst\\models.py 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 class BaseModelAQ2200_VOA_with_OPM ( BaseModelAQ2200_VOA , TypeOPM ): \"\"\"The base class of AQ2200 Series, application type ATTN, with built-in OPM. \"\"\" @property def min_avg_time ( self ) -> float : \"\"\"The minimum averaging time in ms.\"\"\" return 10.0 # 10ms @property def max_avg_time ( self ) -> float : \"\"\"The maximum averaging time in ms.\"\"\" return 10000.0 # 10s @property def min_pow_cal ( self ) -> float : \"\"\"The minimum power calibration value in dB.\"\"\" cmd = \":OUTP {slot:d} :CHAN {channel:d} :POW:OFFS? MIN\" . format ( slot = self . _slot , channel = self . _channel ) cal = float ( self . query ( cmd )) return cal @property def max_pow_cal ( self ) -> float : \"\"\"The maximum power calibration value in dB.\"\"\" cmd = \":OUTP {slot:d} :CHAN {channel:d} :POW:OFFS? MAX\" . format ( slot = self . _slot , channel = self . _channel ) cal = float ( self . query ( cmd )) return cal def get_power_value ( self ) -> float : \"\"\"Fetch the value of measured optical power in current unit setting. The measured value includes the power calibration. Measured value (dBm) = the actual measured value (dBm) + power calibration (dB) Refer to `get_pow_cal` and `set_pow_cal` to operate with the power calibration. Returns: The value of the optical power. \"\"\" cmd = \":FETC {slot} :CHAN {channel} :POW?\" . format ( slot = self . _slot , channel = self . _channel ) power = float ( self . query ( cmd )) return power def get_power_unit ( self ) -> OpticalPowerUnit : \"\"\"Get optical power unit setting. Returns: The unit of the optical power. \"\"\" cmd = \":OUTP {slot:d} :CHAN {channel:d} :POW:UNIT?\" . format ( slot = self . _slot , channel = self . _channel ) unit_int = int ( self . query ( cmd )) unit = OpticalPowerUnit ( unit_int ) return unit def set_power_unit ( self , unit : OpticalPowerUnit ) -> None : \"\"\"Set the unit of optical power. Args: unit: The unit of the optical power. \"\"\" unit = OpticalPowerUnit ( unit ) cmd = \":OUTP {slot:d} :CHAN {channel:d} :POW:UNIT {unit:d} \" . format ( slot = self . _slot , channel = self . _channel , unit = unit ) self . command ( cmd ) def get_pow_cal ( self ) -> float : \"\"\" Get the power calibration offset in dB. Returns: The power calibration offset in dB. \"\"\" cmd = \":OUTP {slot:d} :CHAN {channel:d} :POW:OFFS?\" . format ( slot = self . _slot , channel = self . _channel ) cal = float ( self . query ( cmd )) return cal def set_pow_cal ( self , value : int | float ) -> None : \"\"\" Set the power calibration offset in dB. Args: value: The power calibration offset in dB. \"\"\" if not self . min_pow_cal <= value <= self . max_pow_cal : raise ValueError ( f \"Parameter value is out of range: { value !r} \" ) cmd = \":OUTP {slot:d} :CHAN {channel:d} :POW:OFFS {value:.3f} DB\" . format ( slot = self . _slot , channel = self . _channel , value = value ) self . command ( cmd ) def get_avg_time ( self ) -> float : \"\"\" Get the averaging time in ms. Returns: The averaging time in ms. \"\"\" cmd = \":OUTP {slot:d} :CHAN {channel:d} :ATIM?\" . format ( slot = self . _slot , channel = self . _channel ) avg_t = float ( self . query ( cmd )) * 1000 return avg_t def set_avg_time ( self , value : int | float ) -> None : \"\"\" Set the averaging time in ms. Args: value: The averaging time in ms. \"\"\" if not self . min_avg_time <= value <= self . max_avg_time : raise ValueError ( f \"Parameter value is out of range: { value !r} \" ) cmd = \":OUTP {slot:d} :CHAN {channel:d} :ATIM {value:d} MS\" . format ( slot = self . _slot , channel = self . _channel , value = value ) self . command ( cmd )","title":"BaseModelAQ2200_VOA_with_OPM"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_VOA_with_OPM.get_avg_time","text":"Get the averaging time in ms. Returns: Type Description float The averaging time in ms. Source code in pyinst\\models.py 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 def get_avg_time ( self ) -> float : \"\"\" Get the averaging time in ms. Returns: The averaging time in ms. \"\"\" cmd = \":OUTP {slot:d} :CHAN {channel:d} :ATIM?\" . format ( slot = self . _slot , channel = self . _channel ) avg_t = float ( self . query ( cmd )) * 1000 return avg_t","title":"get_avg_time()"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_VOA_with_OPM.get_pow_cal","text":"Get the power calibration offset in dB. Returns: Type Description float The power calibration offset in dB. Source code in pyinst\\models.py 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 def get_pow_cal ( self ) -> float : \"\"\" Get the power calibration offset in dB. Returns: The power calibration offset in dB. \"\"\" cmd = \":OUTP {slot:d} :CHAN {channel:d} :POW:OFFS?\" . format ( slot = self . _slot , channel = self . _channel ) cal = float ( self . query ( cmd )) return cal","title":"get_pow_cal()"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_VOA_with_OPM.get_power_unit","text":"Get optical power unit setting. Returns: Type Description OpticalPowerUnit The unit of the optical power. Source code in pyinst\\models.py 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 def get_power_unit ( self ) -> OpticalPowerUnit : \"\"\"Get optical power unit setting. Returns: The unit of the optical power. \"\"\" cmd = \":OUTP {slot:d} :CHAN {channel:d} :POW:UNIT?\" . format ( slot = self . _slot , channel = self . _channel ) unit_int = int ( self . query ( cmd )) unit = OpticalPowerUnit ( unit_int ) return unit","title":"get_power_unit()"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_VOA_with_OPM.get_power_value","text":"Fetch the value of measured optical power in current unit setting. The measured value includes the power calibration. Measured value (dBm) = the actual measured value (dBm) + power calibration (dB) Refer to get_pow_cal and set_pow_cal to operate with the power calibration. Returns: Type Description float The value of the optical power. Source code in pyinst\\models.py 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 def get_power_value ( self ) -> float : \"\"\"Fetch the value of measured optical power in current unit setting. The measured value includes the power calibration. Measured value (dBm) = the actual measured value (dBm) + power calibration (dB) Refer to `get_pow_cal` and `set_pow_cal` to operate with the power calibration. Returns: The value of the optical power. \"\"\" cmd = \":FETC {slot} :CHAN {channel} :POW?\" . format ( slot = self . _slot , channel = self . _channel ) power = float ( self . query ( cmd )) return power","title":"get_power_value()"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_VOA_with_OPM.max_avg_time","text":"The maximum averaging time in ms. Source code in pyinst\\models.py 1154 1155 1156 1157 @property def max_avg_time ( self ) -> float : \"\"\"The maximum averaging time in ms.\"\"\" return 10000.0 # 10s","title":"max_avg_time()"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_VOA_with_OPM.max_pow_cal","text":"The maximum power calibration value in dB. Source code in pyinst\\models.py 1166 1167 1168 1169 1170 1171 @property def max_pow_cal ( self ) -> float : \"\"\"The maximum power calibration value in dB.\"\"\" cmd = \":OUTP {slot:d} :CHAN {channel:d} :POW:OFFS? MAX\" . format ( slot = self . _slot , channel = self . _channel ) cal = float ( self . query ( cmd )) return cal","title":"max_pow_cal()"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_VOA_with_OPM.min_avg_time","text":"The minimum averaging time in ms. Source code in pyinst\\models.py 1149 1150 1151 1152 @property def min_avg_time ( self ) -> float : \"\"\"The minimum averaging time in ms.\"\"\" return 10.0 # 10ms","title":"min_avg_time()"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_VOA_with_OPM.min_pow_cal","text":"The minimum power calibration value in dB. Source code in pyinst\\models.py 1159 1160 1161 1162 1163 1164 @property def min_pow_cal ( self ) -> float : \"\"\"The minimum power calibration value in dB.\"\"\" cmd = \":OUTP {slot:d} :CHAN {channel:d} :POW:OFFS? MIN\" . format ( slot = self . _slot , channel = self . _channel ) cal = float ( self . query ( cmd )) return cal","title":"min_pow_cal()"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_VOA_with_OPM.set_avg_time","text":"Set the averaging time in ms. Parameters: Name Type Description Default value int | float The averaging time in ms. required Source code in pyinst\\models.py 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 def set_avg_time ( self , value : int | float ) -> None : \"\"\" Set the averaging time in ms. Args: value: The averaging time in ms. \"\"\" if not self . min_avg_time <= value <= self . max_avg_time : raise ValueError ( f \"Parameter value is out of range: { value !r} \" ) cmd = \":OUTP {slot:d} :CHAN {channel:d} :ATIM {value:d} MS\" . format ( slot = self . _slot , channel = self . _channel , value = value ) self . command ( cmd )","title":"set_avg_time()"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_VOA_with_OPM.set_pow_cal","text":"Set the power calibration offset in dB. Parameters: Name Type Description Default value int | float The power calibration offset in dB. required Source code in pyinst\\models.py 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 def set_pow_cal ( self , value : int | float ) -> None : \"\"\" Set the power calibration offset in dB. Args: value: The power calibration offset in dB. \"\"\" if not self . min_pow_cal <= value <= self . max_pow_cal : raise ValueError ( f \"Parameter value is out of range: { value !r} \" ) cmd = \":OUTP {slot:d} :CHAN {channel:d} :POW:OFFS {value:.3f} DB\" . format ( slot = self . _slot , channel = self . _channel , value = value ) self . command ( cmd )","title":"set_pow_cal()"},{"location":"api/models/#pyinst.models.BaseModelAQ2200_VOA_with_OPM.set_power_unit","text":"Set the unit of optical power. Parameters: Name Type Description Default unit OpticalPowerUnit The unit of the optical power. required Source code in pyinst\\models.py 1200 1201 1202 1203 1204 1205 1206 1207 1208 def set_power_unit ( self , unit : OpticalPowerUnit ) -> None : \"\"\"Set the unit of optical power. Args: unit: The unit of the optical power. \"\"\" unit = OpticalPowerUnit ( unit ) cmd = \":OUTP {slot:d} :CHAN {channel:d} :POW:UNIT {unit:d} \" . format ( slot = self . _slot , channel = self . _channel , unit = unit ) self . command ( cmd )","title":"set_power_unit()"},{"location":"api/models/#pyinst.models.BaseModelEspecOld","text":"Bases: BaseInstrument , TypeTS The base class for old chamber models by Espec MC-711 MT3065 Note Before communication, some configuration must be performed on the chamber: - Device ID: Correspond with the dev_id in the __init__ method. Defaults to 0. Source code in pyinst\\models.py 3524 3525 3526 3527 3528 3529 3530 3531 3532 3533 3534 3535 3536 3537 3538 3539 3540 3541 3542 3543 3544 3545 3546 3547 3548 3549 3550 3551 3552 3553 3554 3555 3556 3557 3558 3559 3560 3561 3562 3563 3564 3565 3566 3567 3568 3569 3570 3571 3572 3573 3574 3575 3576 3577 3578 3579 3580 3581 3582 3583 3584 3585 3586 3587 3588 3589 3590 3591 3592 3593 3594 3595 3596 3597 3598 3599 3600 3601 3602 3603 3604 3605 3606 3607 3608 3609 3610 3611 3612 3613 3614 3615 3616 3617 3618 3619 3620 3621 3622 3623 3624 3625 3626 3627 3628 3629 3630 3631 3632 3633 3634 3635 3636 3637 3638 3639 3640 3641 3642 3643 3644 3645 class BaseModelEspecOld ( BaseInstrument , TypeTS ): \"\"\"The base class for old chamber models by Espec: - MC-711 - MT3065 Note: Before communication, some configuration must be performed on the chamber: - Device ID: Correspond with the dev_id in the `__init__` method. Defaults to 0. \"\"\" brand = \"Espec\" params = [ { \"name\" : \"dev_id\" , \"type\" : \"int\" , \"min\" : 0 , \"max\" : 15 } ] def __init__ ( self , resource_name : str , dev_id : int = 0 , baud_rate : int = 19200 , read_timeout : int | float = 0.5 , ** kwargs ): \"\"\" Args: resource_name: Serial port name. dev_id: The device ID of the chamber. baudrate: Baud rate such as 9600 or 115200 etc.. read_timeout: Timeout in milliseconds for read operations. **kwargs: Directly passed to `serial.Serial()`. \"\"\" super ( BaseModelEspecOld , self ) . __init__ () if dev_id not in range ( 16 ): raise ValueError ( 'Device ID must be between 0 and 15' ) self . __dev_id = dev_id self . __serial = serial . Serial ( port = resource_name , baudrate = baud_rate , timeout = read_timeout , ** kwargs ) self . __serial . setRTS () self . __serial . setDTR () self . __serial . reset_input_buffer () self . __resource_name = resource_name @property def resource_name ( self ) -> str : return self . __resource_name @property def ts_type ( self ) -> TemperatureSourceType : return TemperatureSourceType . CHAMBER def close ( self ): self . __serial . close () def write_cmd ( self , cmd : bytes ): pre = b ' \\x05 ' b_id = ' {dev_id:02X} ' . format ( dev_id = self . __dev_id ) . encode () cmd_body = b_id + cmd checksum = ' {:02X} ' . format ( sum ( cmd_body ))[ - 2 :] . encode () t = pre + cmd_body + checksum self . __serial . reset_input_buffer () self . __serial . write ( t ) def read_reply ( self ): r = self . __serial . read ( 10240 ) if not r : raise ValueError ( 'No reply. Please check the connection and device ID setting.' ) return r # def check_connection(self) -> ConnectionStatus: # try: # self.get_target_temp() # return ConnectionStatus(True) # except Exception as e: # return ConnectionStatus(False, e.args[0] if e.args else None) def run ( self , en : bool = True ) -> None : \"\"\"TODO\"\"\" def stop ( self ) -> None : self . run ( False ) def is_running ( self ) -> bool : \"\"\"TODO\"\"\" def set_target_temp ( self , value : int | float ) -> None : value = round ( value * 10 ) if value < 0 : value = 65536 + value cmd = 'FFWW0D119705 {temp:04X} 0000000000000000' . format ( temp = value ) . encode () self . write_cmd ( cmd ) time . sleep ( 0.5 ) r = self . read_reply () if not r . startswith ( b ' \\x06 ' ): raise ValueError ( 'Unexpected reply: %r ' % r ) def get_target_temp ( self ) -> float : cmd = b 'FFWR0D111401' self . write_cmd ( cmd ) time . sleep ( 0.5 ) r = self . read_reply () if not r . startswith ( b ' \\x02 ' ): raise ValueError ( 'Unexpected reply: %r ' % r ) raw_val = int ( r [ 5 : 9 ] . decode (), 16 ) signed_val = ( raw_val - 65536 ) if raw_val >= 65536 / 2 else raw_val return signed_val / 10 def get_current_temp ( self ) -> float : cmd = b 'FFWR0D111701' self . write_cmd ( cmd ) time . sleep ( 0.5 ) r = self . read_reply () if not r . startswith ( b ' \\x02 ' ): raise ValueError ( 'Unexpected reply: %r ' % r ) raw_val = int ( r [ 5 : 9 ] . decode (), 16 ) signed_val = ( raw_val - 65536 ) if raw_val >= 65536 / 2 else raw_val return signed_val / 10 def set_temp_unit ( self , unit : TemperatureUnit ) -> None : if unit != TemperatureUnit . C : raise ValueError ( 'The temperature unit of this Chamber is fixed to C.' ) def get_temp_unit ( self ) -> TemperatureUnit : return TemperatureUnit . C","title":"BaseModelEspecOld"},{"location":"api/models/#pyinst.models.BaseModelEspecOld.__init__","text":"Parameters: Name Type Description Default resource_name str Serial port name. required dev_id int The device ID of the chamber. 0 baudrate Baud rate such as 9600 or 115200 etc.. required read_timeout int | float Timeout in milliseconds for read operations. 0.5 **kwargs Directly passed to serial.Serial() . {} Source code in pyinst\\models.py 3546 3547 3548 3549 3550 3551 3552 3553 3554 3555 3556 3557 3558 3559 3560 3561 3562 3563 def __init__ ( self , resource_name : str , dev_id : int = 0 , baud_rate : int = 19200 , read_timeout : int | float = 0.5 , ** kwargs ): \"\"\" Args: resource_name: Serial port name. dev_id: The device ID of the chamber. baudrate: Baud rate such as 9600 or 115200 etc.. read_timeout: Timeout in milliseconds for read operations. **kwargs: Directly passed to `serial.Serial()`. \"\"\" super ( BaseModelEspecOld , self ) . __init__ () if dev_id not in range ( 16 ): raise ValueError ( 'Device ID must be between 0 and 15' ) self . __dev_id = dev_id self . __serial = serial . Serial ( port = resource_name , baudrate = baud_rate , timeout = read_timeout , ** kwargs ) self . __serial . setRTS () self . __serial . setDTR () self . __serial . reset_input_buffer () self . __resource_name = resource_name","title":"__init__()"},{"location":"api/models/#pyinst.models.BaseModelEspecOld.is_running","text":"TODO Source code in pyinst\\models.py 3604 3605 def is_running ( self ) -> bool : \"\"\"TODO\"\"\"","title":"is_running()"},{"location":"api/models/#pyinst.models.BaseModelEspecOld.run","text":"TODO Source code in pyinst\\models.py 3598 3599 def run ( self , en : bool = True ) -> None : \"\"\"TODO\"\"\"","title":"run()"},{"location":"api/models/#pyinst.models.BaseModelN77xx","text":"Bases: VisaInstrument Base class for Keysight N77xx Series: N7744A, N7745A, N7747A and N7748A Optical Multiport Power Meters N7751A and N7752A Variable Optical Attenuators and 2-Channel Optical Power Meter N7761A, N7762A and N7764A Variable Optical Attenuators Source code in pyinst\\models.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 class BaseModelN77xx ( VisaInstrument ): \"\"\" Base class for Keysight N77xx Series: - N7744A, N7745A, N7747A and N7748A Optical Multiport Power Meters - N7751A and N7752A Variable Optical Attenuators and 2-Channel Optical Power Meter - N7761A, N7762A and N7764A Variable Optical Attenuators \"\"\" def __init__ ( self , resource_name : str , slot : int , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: The slot number in the frame. **kwargs: Directly passed to `VisaInstrument.__init__` \"\"\" if not 1 <= slot <= self . _max_slot : raise ValueError ( f 'Parameter slot is out of range: { slot !r} . The max slot number is { self . _max_slot } .' ) self . __slot = slot super () . __init__ ( resource_name , ** kwargs ) @property @abstractmethod def _max_slot ( self ): \"\"\"The max valid slot number for the specific instrument model. Defined by specific Instrument Model classes. \"\"\" @property def _slot ( self ): return self . __slot","title":"BaseModelN77xx"},{"location":"api/models/#pyinst.models.BaseModelN77xx.__init__","text":"Parameters: Name Type Description Default resource_name str Resource name or alias of the VISA resource to open. required slot int The slot number in the frame. required **kwargs Directly passed to VisaInstrument.__init__ {} Source code in pyinst\\models.py 81 82 83 84 85 86 87 88 89 90 91 def __init__ ( self , resource_name : str , slot : int , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: The slot number in the frame. **kwargs: Directly passed to `VisaInstrument.__init__` \"\"\" if not 1 <= slot <= self . _max_slot : raise ValueError ( f 'Parameter slot is out of range: { slot !r} . The max slot number is { self . _max_slot } .' ) self . __slot = slot super () . __init__ ( resource_name , ** kwargs )","title":"__init__()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_OPM","text":"Bases: BaseModelN77xx , TypeOPM Source code in pyinst\\models.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 class BaseModelN77xx_OPM ( BaseModelN77xx , TypeOPM ): @property def min_frequency ( self ) -> float : \"\"\"The minimum settable optical frequency value in THz.\"\"\" return super () . min_frequency @property def max_frequency ( self ) -> float : \"\"\"The maximum settable optical frequency value in THz.\"\"\" return super () . max_frequency @property def min_wavelength ( self ) -> float : \"\"\"The minimum settable optical wavelength value in nm.\"\"\" cmd = \":SENS {slot:d} :POW:WAV? MIN\" . format ( slot = self . _slot ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl @property def max_wavelength ( self ) -> float : \"\"\"The maximum settable optical wavelength value in nm.\"\"\" cmd = \":SENS {slot:d} :POW:WAV? MAX\" . format ( slot = self . _slot ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl @property def min_avg_time ( self ) -> float : \"\"\"The minimum averaging time in ms.\"\"\" return 0.001 # 1us @property def max_avg_time ( self ) -> float : \"\"\"The maximum averaging time in ms.\"\"\" return 10000.0 # 10s @property def min_pow_cal ( self ) -> float : \"\"\"The minimum power calibration value in dB.\"\"\" return - 200.0 # dB @property def max_pow_cal ( self ) -> float : \"\"\"The maximum power calibration value in dB.\"\"\" return 200.0 # dB def get_frequency ( self ) -> float : \"\"\" Queries the optical frequency setting of the instrument in THz. Returns: The optical frequency setting value in THz. \"\"\" return super () . get_frequency () def set_frequency ( self , frequency : int | float ) -> None : \"\"\"Set optical frequency. Args: frequency: The optical frequency setting in THz. \"\"\" return super () . set_frequency ( frequency ) def get_wavelength ( self ) -> float : \"\"\"Queries the optical wavelength setting of the instrument in nm. Returns: The optical wavelength setting value in nm. \"\"\" cmd = \":SENS {slot:d} :POW:WAV?\" . format ( slot = self . _slot ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl def set_wavelength ( self , wavelength : int | float ) -> None : \"\"\"Set optical wavelength. Args: wavelength: The optical wavelength setting in nm. \"\"\" if not self . min_wavelength <= wavelength <= self . max_wavelength : raise ValueError ( f \"Parameter wavelength is out of range: { wavelength !r} \" ) cmd = \":SENS {slot:d} :POW:WAV {value:f} NM\" . format ( slot = self . _slot , value = wavelength ) self . command ( cmd ) def get_power_value ( self ) -> float : \"\"\"Fetch the value of measured optical power in current unit setting. The measured value includes the power calibration. Measured value (dBm) = the actual measured value (dBm) + power calibration (dB) Refer to `get_pow_cal` and `set_pow_cal` to operate with the power calibration. Returns: The value of the optical power. \"\"\" cmd = \":FETC {slot:d} :POW?\" . format ( slot = self . _slot ) power_value = float ( self . query ( cmd )) return power_value def get_power_unit ( self ) -> OpticalPowerUnit : \"\"\"Get optical power unit setting. Returns: The unit of the optical power. \"\"\" cmd = \":SENS {slot:d} :POW:UNIT?\" . format ( slot = self . _slot ) unit_int = int ( self . query ( cmd )) return OpticalPowerUnit ( unit_int ) def set_power_unit ( self , unit : OpticalPowerUnit ) -> None : \"\"\"Set the unit of optical power. Args: unit: The unit of the optical power. \"\"\" unit = OpticalPowerUnit ( unit ) cmd = \":SENS {slot:d} :POW:UNIT {unit:d} \" . format ( slot = self . _slot , unit = unit ) self . command ( cmd ) def get_pow_cal ( self ) -> float : \"\"\" Get the power calibration offset in dB. Note: The power calibration value defined here is opposite in sign with the instrument display value. This is to unify the definition of power calibration across different models of OPMs. Please refer to `get_power_value` for the math equation. Returns: The power calibration offset in dB. \"\"\" cmd = \":SENS {slot:d} :CORR?\" . format ( slot = self . _slot ) cal = - float ( self . query ( cmd )) return cal def set_pow_cal ( self , value : int | float ) -> None : \"\"\" Set the power calibration offset in dB. Args: value: The power calibration offset in dB. \"\"\" if not self . min_pow_cal <= value <= self . max_pow_cal : raise ValueError ( \"param value out of range: {value} \" . format ( value = value )) cmd = \":SENS {slot} :CORR {value} DB\" . format ( slot = self . _slot , value =- value ) self . command ( cmd ) def get_avg_time ( self ) -> float : \"\"\" Get the averaging time in ms. Returns: The averaging time in ms. \"\"\" cmd = \":SENS {slot:d} :POW:ATIM?\" . format ( slot = self . _slot ) avg_t = float ( self . query ( cmd )) * 10 ** 3 return avg_t def set_avg_time ( self , value : int | float ) -> None : \"\"\" Set the averaging time in ms. Args: value: The averaging time in ms. \"\"\" if not self . min_avg_time <= value <= self . max_avg_time : raise ValueError ( \"param value out of range: {value} \" . format ( value = value )) cmd = \":SENS {slot} :POW:ATIM {value} MS\" . format ( slot = self . _slot , value = value ) self . command ( cmd )","title":"BaseModelN77xx_OPM"},{"location":"api/models/#pyinst.models.BaseModelN77xx_OPM.get_avg_time","text":"Get the averaging time in ms. Returns: Type Description float The averaging time in ms. Source code in pyinst\\models.py 255 256 257 258 259 260 261 262 263 264 def get_avg_time ( self ) -> float : \"\"\" Get the averaging time in ms. Returns: The averaging time in ms. \"\"\" cmd = \":SENS {slot:d} :POW:ATIM?\" . format ( slot = self . _slot ) avg_t = float ( self . query ( cmd )) * 10 ** 3 return avg_t","title":"get_avg_time()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_OPM.get_frequency","text":"Queries the optical frequency setting of the instrument in THz. Returns: Type Description float The optical frequency setting value in THz. Source code in pyinst\\models.py 152 153 154 155 156 157 158 159 def get_frequency ( self ) -> float : \"\"\" Queries the optical frequency setting of the instrument in THz. Returns: The optical frequency setting value in THz. \"\"\" return super () . get_frequency ()","title":"get_frequency()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_OPM.get_pow_cal","text":"Get the power calibration offset in dB. Note The power calibration value defined here is opposite in sign with the instrument display value. This is to unify the definition of power calibration across different models of OPMs. Please refer to get_power_value for the math equation. Returns: Type Description float The power calibration offset in dB. Source code in pyinst\\models.py 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def get_pow_cal ( self ) -> float : \"\"\" Get the power calibration offset in dB. Note: The power calibration value defined here is opposite in sign with the instrument display value. This is to unify the definition of power calibration across different models of OPMs. Please refer to `get_power_value` for the math equation. Returns: The power calibration offset in dB. \"\"\" cmd = \":SENS {slot:d} :CORR?\" . format ( slot = self . _slot ) cal = - float ( self . query ( cmd )) return cal","title":"get_pow_cal()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_OPM.get_power_unit","text":"Get optical power unit setting. Returns: Type Description OpticalPowerUnit The unit of the optical power. Source code in pyinst\\models.py 206 207 208 209 210 211 212 213 214 def get_power_unit ( self ) -> OpticalPowerUnit : \"\"\"Get optical power unit setting. Returns: The unit of the optical power. \"\"\" cmd = \":SENS {slot:d} :POW:UNIT?\" . format ( slot = self . _slot ) unit_int = int ( self . query ( cmd )) return OpticalPowerUnit ( unit_int )","title":"get_power_unit()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_OPM.get_power_value","text":"Fetch the value of measured optical power in current unit setting. The measured value includes the power calibration. Measured value (dBm) = the actual measured value (dBm) + power calibration (dB) Refer to get_pow_cal and set_pow_cal to operate with the power calibration. Returns: Type Description float The value of the optical power. Source code in pyinst\\models.py 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def get_power_value ( self ) -> float : \"\"\"Fetch the value of measured optical power in current unit setting. The measured value includes the power calibration. Measured value (dBm) = the actual measured value (dBm) + power calibration (dB) Refer to `get_pow_cal` and `set_pow_cal` to operate with the power calibration. Returns: The value of the optical power. \"\"\" cmd = \":FETC {slot:d} :POW?\" . format ( slot = self . _slot ) power_value = float ( self . query ( cmd )) return power_value","title":"get_power_value()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_OPM.get_wavelength","text":"Queries the optical wavelength setting of the instrument in nm. Returns: Type Description float The optical wavelength setting value in nm. Source code in pyinst\\models.py 169 170 171 172 173 174 175 176 177 def get_wavelength ( self ) -> float : \"\"\"Queries the optical wavelength setting of the instrument in nm. Returns: The optical wavelength setting value in nm. \"\"\" cmd = \":SENS {slot:d} :POW:WAV?\" . format ( slot = self . _slot ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl","title":"get_wavelength()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_OPM.max_avg_time","text":"The maximum averaging time in ms. Source code in pyinst\\models.py 137 138 139 140 @property def max_avg_time ( self ) -> float : \"\"\"The maximum averaging time in ms.\"\"\" return 10000.0 # 10s","title":"max_avg_time()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_OPM.max_frequency","text":"The maximum settable optical frequency value in THz. Source code in pyinst\\models.py 113 114 115 116 @property def max_frequency ( self ) -> float : \"\"\"The maximum settable optical frequency value in THz.\"\"\" return super () . max_frequency","title":"max_frequency()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_OPM.max_pow_cal","text":"The maximum power calibration value in dB. Source code in pyinst\\models.py 147 148 149 150 @property def max_pow_cal ( self ) -> float : \"\"\"The maximum power calibration value in dB.\"\"\" return 200.0 # dB","title":"max_pow_cal()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_OPM.max_wavelength","text":"The maximum settable optical wavelength value in nm. Source code in pyinst\\models.py 125 126 127 128 129 130 @property def max_wavelength ( self ) -> float : \"\"\"The maximum settable optical wavelength value in nm.\"\"\" cmd = \":SENS {slot:d} :POW:WAV? MAX\" . format ( slot = self . _slot ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl","title":"max_wavelength()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_OPM.min_avg_time","text":"The minimum averaging time in ms. Source code in pyinst\\models.py 132 133 134 135 @property def min_avg_time ( self ) -> float : \"\"\"The minimum averaging time in ms.\"\"\" return 0.001 # 1us","title":"min_avg_time()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_OPM.min_frequency","text":"The minimum settable optical frequency value in THz. Source code in pyinst\\models.py 108 109 110 111 @property def min_frequency ( self ) -> float : \"\"\"The minimum settable optical frequency value in THz.\"\"\" return super () . min_frequency","title":"min_frequency()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_OPM.min_pow_cal","text":"The minimum power calibration value in dB. Source code in pyinst\\models.py 142 143 144 145 @property def min_pow_cal ( self ) -> float : \"\"\"The minimum power calibration value in dB.\"\"\" return - 200.0 # dB","title":"min_pow_cal()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_OPM.min_wavelength","text":"The minimum settable optical wavelength value in nm. Source code in pyinst\\models.py 118 119 120 121 122 123 @property def min_wavelength ( self ) -> float : \"\"\"The minimum settable optical wavelength value in nm.\"\"\" cmd = \":SENS {slot:d} :POW:WAV? MIN\" . format ( slot = self . _slot ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl","title":"min_wavelength()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_OPM.set_avg_time","text":"Set the averaging time in ms. Parameters: Name Type Description Default value int | float The averaging time in ms. required Source code in pyinst\\models.py 266 267 268 269 270 271 272 273 274 275 276 def set_avg_time ( self , value : int | float ) -> None : \"\"\" Set the averaging time in ms. Args: value: The averaging time in ms. \"\"\" if not self . min_avg_time <= value <= self . max_avg_time : raise ValueError ( \"param value out of range: {value} \" . format ( value = value )) cmd = \":SENS {slot} :POW:ATIM {value} MS\" . format ( slot = self . _slot , value = value ) self . command ( cmd )","title":"set_avg_time()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_OPM.set_frequency","text":"Set optical frequency. Parameters: Name Type Description Default frequency int | float The optical frequency setting in THz. required Source code in pyinst\\models.py 161 162 163 164 165 166 167 def set_frequency ( self , frequency : int | float ) -> None : \"\"\"Set optical frequency. Args: frequency: The optical frequency setting in THz. \"\"\" return super () . set_frequency ( frequency )","title":"set_frequency()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_OPM.set_pow_cal","text":"Set the power calibration offset in dB. Parameters: Name Type Description Default value int | float The power calibration offset in dB. required Source code in pyinst\\models.py 243 244 245 246 247 248 249 250 251 252 253 def set_pow_cal ( self , value : int | float ) -> None : \"\"\" Set the power calibration offset in dB. Args: value: The power calibration offset in dB. \"\"\" if not self . min_pow_cal <= value <= self . max_pow_cal : raise ValueError ( \"param value out of range: {value} \" . format ( value = value )) cmd = \":SENS {slot} :CORR {value} DB\" . format ( slot = self . _slot , value =- value ) self . command ( cmd )","title":"set_pow_cal()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_OPM.set_power_unit","text":"Set the unit of optical power. Parameters: Name Type Description Default unit OpticalPowerUnit The unit of the optical power. required Source code in pyinst\\models.py 216 217 218 219 220 221 222 223 224 def set_power_unit ( self , unit : OpticalPowerUnit ) -> None : \"\"\"Set the unit of optical power. Args: unit: The unit of the optical power. \"\"\" unit = OpticalPowerUnit ( unit ) cmd = \":SENS {slot:d} :POW:UNIT {unit:d} \" . format ( slot = self . _slot , unit = unit ) self . command ( cmd )","title":"set_power_unit()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_OPM.set_wavelength","text":"Set optical wavelength. Parameters: Name Type Description Default wavelength int | float The optical wavelength setting in nm. required Source code in pyinst\\models.py 179 180 181 182 183 184 185 186 187 188 def set_wavelength ( self , wavelength : int | float ) -> None : \"\"\"Set optical wavelength. Args: wavelength: The optical wavelength setting in nm. \"\"\" if not self . min_wavelength <= wavelength <= self . max_wavelength : raise ValueError ( f \"Parameter wavelength is out of range: { wavelength !r} \" ) cmd = \":SENS {slot:d} :POW:WAV {value:f} NM\" . format ( slot = self . _slot , value = wavelength ) self . command ( cmd )","title":"set_wavelength()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_VOA_with_OPM","text":"Bases: BaseModelN77xx , TypeVOA , TypeOPM Source code in pyinst\\models.py 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 class BaseModelN77xx_VOA_with_OPM ( BaseModelN77xx , TypeVOA , TypeOPM ): @property def min_frequency ( self ) -> float : \"\"\"The minimum settable optical frequency value in THz.\"\"\" return super () . min_frequency @property def max_frequency ( self ) -> float : \"\"\"The maximum settable optical frequency value in THz.\"\"\" return super () . max_frequency @property def min_wavelength ( self ) -> float : \"\"\"The minimum settable optical wavelength value in nm.\"\"\" cmd = \":INPut {slot:d} :WAVelength? MIN\" . format ( slot = self . _slot ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl @property def max_wavelength ( self ) -> float : \"\"\"The maximum settable optical wavelength value in nm.\"\"\" cmd = \":INPut {slot:d} :WAVelength? MAX\" . format ( slot = self . _slot ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl @property def min_avg_time ( self ) -> float : \"\"\"The minimum averaging time in ms.\"\"\" return 2.0 @property def max_avg_time ( self ) -> float : \"\"\"The maximum averaging time in ms.\"\"\" return 10000.0 @property def min_pow_cal ( self ) -> float : \"\"\"The minimum power calibration value in dB.\"\"\" return - 200.0 @property def max_pow_cal ( self ) -> float : \"\"\"The maximum power calibration value in dB.\"\"\" return 200.0 @property def min_att ( self ) -> float : \"\"\"Minimum settable attenuation in dB. The minimum settable attenuation = 0 dB + the optical attenuation offset value. \"\"\" cmd = \":INP {slot:d} :ATT? MIN\" . format ( slot = self . _slot ) att = float ( self . query ( cmd )) return att @property def max_att ( self ) -> float : \"\"\"Maximum settable attenuation in dB. The maximum settable attenuation = The maximum attenuation + the optical attenuation offset value. \"\"\" cmd = \":INP {slot:d} :ATT? MAX\" . format ( slot = self . _slot ) att = float ( self . query ( cmd )) return att @property def min_att_offset ( self ) -> float : \"\"\"Minimum attenuation offset value in dB.\"\"\" cmd = \":INP {slot} :OFFS? MIN\" . format ( slot = self . _slot ) offset = float ( self . query ( cmd )) return offset @property def max_att_offset ( self ) -> float : \"\"\"Maximum attenuation offset value in dB.\"\"\" cmd = \":INP {slot} :OFFS? MAX\" . format ( slot = self . _slot ) offset = float ( self . query ( cmd )) return offset def get_frequency ( self ) -> float : \"\"\" Queries the optical frequency setting of the instrument in THz. Returns: The optical frequency setting value in THz. \"\"\" return super () . get_frequency () def set_frequency ( self , frequency : int | float ) -> None : \"\"\"Set optical frequency. Args: frequency: The optical frequency setting in THz. \"\"\" return super () . set_frequency ( frequency ) def get_wavelength ( self ) -> float : \"\"\"Queries the optical wavelength setting of the instrument in nm. Returns: The optical wavelength setting value in nm. \"\"\" cmd = \":INPut {slot:d} :WAVelength?\" . format ( slot = self . _slot ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl def set_wavelength ( self , wavelength : int | float ) -> None : \"\"\"Set optical wavelength. Args: wavelength: The optical wavelength setting in nm. \"\"\" if not self . min_wavelength <= wavelength <= self . max_wavelength : raise ValueError ( f \"Parameter wavelength is out of range: { wavelength } \" ) cmd = \":INPut {slot:d} :WAVelength {wl} NM\" . format ( slot = self . _slot , wl = wavelength ) self . command ( cmd ) def get_power_value ( self ) -> float : \"\"\"Fetch the value of measured optical power in current unit setting. The measured value includes the power calibration. Measured value (dBm) = the actual measured value (dBm) + power calibration (dB) Refer to `get_pow_cal` and `set_pow_cal` to operate with the power calibration. Returns: The value of the optical power. \"\"\" cmd = \":FETC {slot:d} :POW?\" . format ( slot = self . _slot ) power_value = float ( self . query ( cmd )) return power_value def get_power_unit ( self ) -> OpticalPowerUnit : \"\"\"Get optical power unit setting. Returns: The unit of the optical power. \"\"\" cmd = \":OUTPut {slot:d} :POWer:UNit?\" . format ( slot = self . _slot ) unit_int = int ( self . query ( cmd )) return OpticalPowerUnit ( unit_int ) def set_power_unit ( self , unit : OpticalPowerUnit ) -> None : \"\"\"Set the unit of optical power. Args: unit: The unit of the optical power. \"\"\" unit = OpticalPowerUnit ( unit ) cmd = \":OUTPut {slot:d} :POWer:UNit {unit:d} \" . format ( slot = self . _slot , unit = unit ) self . command ( cmd ) def get_pow_cal ( self ) -> float : \"\"\" Get the power calibration offset in dB. Note: The power calibration value defined here is opposite in sign with the instrument display value. This is to unify the definition of power calibration across different models of OPMs. Please refer to `get_power_value` for the math equation. Returns: The power calibration offset in dB. \"\"\" cmd = \":OUTPut {slot:d} :POWer:OFFSet?\" . format ( slot = self . _slot ) cal = - float ( self . query ( cmd )) return cal def set_pow_cal ( self , value : int | float ) -> None : \"\"\" Set the power calibration offset in dB. Args: value: The power calibration offset in dB. \"\"\" if not self . min_pow_cal <= value <= self . max_pow_cal : raise ValueError ( f \"Parameter value is out of range: { value !r} \" ) cmd = \":OUTPut {slot:d} :POWer:OFFSet {value} DB\" . format ( slot = self . _slot , value =- value ) # opposite sign self . command ( cmd ) def get_avg_time ( self ) -> float : \"\"\" Get the averaging time in ms. Returns: The averaging time in ms. \"\"\" cmd = \":OUTPut {slot:d} :ATIMe?\" . format ( slot = self . _slot ) atime = float ( self . query ( cmd )) * 10 ** 3 return atime def set_avg_time ( self , value : int | float ) -> None : \"\"\" Set the averaging time in ms. Args: value: The averaging time in ms. \"\"\" if not self . min_avg_time <= value <= self . max_avg_time : raise ValueError ( f \"Parameter value is out of range: { value !r} \" ) cmd = \":OUTPut {slot:d} :ATIMe {value} MS\" . format ( slot = self . _slot , value = value ) self . command ( cmd ) def enable ( self , en : bool = True ) -> None : \"\"\" Enable (disable) the optical output. Args: en: True = Enable, False = Disable. \"\"\" if not isinstance ( en , bool ): raise TypeError ( f \"Parameter en must be a bool, not ' { type ( en ) . __name__ } '.\" ) cmd = \":OUTP {slot:d} {status:d} \" . format ( slot = self . _slot , status = en ) self . command ( cmd ) def disable ( self ) -> None : \"\"\"Disable the optical output.\"\"\" self . enable ( False ) def is_enabled ( self ) -> bool : \"\"\" Returns: Whether the optical output is enabled. \"\"\" cmd = \":OUTP {slot:d} ?\" . format ( slot = self . _slot ) status = bool ( int ( self . query ( cmd ))) return status def get_att ( self ) -> float : \"\"\" Get the current attenuation value in dB. Includes the attenuation offset. Queried attenuator = the actual attenuator value + attenuator offset Use `get_att_offset` and `set_att_offset` to operate with the attenuator offset. Returns: The attenuation value in dB. \"\"\" cmd = \":INP {slot:d} :ATT?\" . format ( slot = self . _slot ) att = float ( self . query ( cmd )) return att def set_att ( self , att : int | float ) -> None : \"\"\" Set attenuation value in dB. Includes the attenuation offset. Refer to `get_att` for more information. Args: att: The attenuation value in dB. \"\"\" if not self . min_att <= att <= self . max_att : raise ValueError ( f 'Parameter att is out of range: { att !r} ' ) cmd = \":INP {slot:d} :ATT {value:.3f} DB\" . format ( slot = self . _slot , value = att ) self . command ( cmd ) def get_att_offset ( self ) -> float : \"\"\" Get the attenuation offset value in dB. Returns: The attenuation offset in dB. \"\"\" cmd = \":INP {slot:d} :OFFS?\" . format ( slot = self . _slot ) offset = float ( self . query ( cmd )) return offset def set_att_offset ( self , offset : int | float ) -> None : \"\"\" Set the attenuation offset value in dB. Args: offset: The attenuation offset in dB. \"\"\" if not self . min_att_offset <= offset <= self . max_att_offset : raise ValueError ( f \"Parameter offset is out of range: { offset !r} \" ) self . command ( \":INP {slot:d} :OFFS {value:.3f} DB\" . format ( slot = self . _slot , value = offset ))","title":"BaseModelN77xx_VOA_with_OPM"},{"location":"api/models/#pyinst.models.BaseModelN77xx_VOA_with_OPM.disable","text":"Disable the optical output. Source code in pyinst\\models.py 499 500 501 def disable ( self ) -> None : \"\"\"Disable the optical output.\"\"\" self . enable ( False )","title":"disable()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_VOA_with_OPM.enable","text":"Enable (disable) the optical output. Parameters: Name Type Description Default en bool True = Enable, False = Disable. True Source code in pyinst\\models.py 487 488 489 490 491 492 493 494 495 496 497 def enable ( self , en : bool = True ) -> None : \"\"\" Enable (disable) the optical output. Args: en: True = Enable, False = Disable. \"\"\" if not isinstance ( en , bool ): raise TypeError ( f \"Parameter en must be a bool, not ' { type ( en ) . __name__ } '.\" ) cmd = \":OUTP {slot:d} {status:d} \" . format ( slot = self . _slot , status = en ) self . command ( cmd )","title":"enable()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_VOA_with_OPM.get_att","text":"Get the current attenuation value in dB. Includes the attenuation offset. Queried attenuator = the actual attenuator value + attenuator offset Use get_att_offset and set_att_offset to operate with the attenuator offset. Returns: Type Description float The attenuation value in dB. Source code in pyinst\\models.py 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 def get_att ( self ) -> float : \"\"\" Get the current attenuation value in dB. Includes the attenuation offset. Queried attenuator = the actual attenuator value + attenuator offset Use `get_att_offset` and `set_att_offset` to operate with the attenuator offset. Returns: The attenuation value in dB. \"\"\" cmd = \":INP {slot:d} :ATT?\" . format ( slot = self . _slot ) att = float ( self . query ( cmd )) return att","title":"get_att()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_VOA_with_OPM.get_att_offset","text":"Get the attenuation offset value in dB. Returns: Type Description float The attenuation offset in dB. Source code in pyinst\\models.py 545 546 547 548 549 550 551 552 553 554 def get_att_offset ( self ) -> float : \"\"\" Get the attenuation offset value in dB. Returns: The attenuation offset in dB. \"\"\" cmd = \":INP {slot:d} :OFFS?\" . format ( slot = self . _slot ) offset = float ( self . query ( cmd )) return offset","title":"get_att_offset()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_VOA_with_OPM.get_avg_time","text":"Get the averaging time in ms. Returns: Type Description float The averaging time in ms. Source code in pyinst\\models.py 464 465 466 467 468 469 470 471 472 473 def get_avg_time ( self ) -> float : \"\"\" Get the averaging time in ms. Returns: The averaging time in ms. \"\"\" cmd = \":OUTPut {slot:d} :ATIMe?\" . format ( slot = self . _slot ) atime = float ( self . query ( cmd )) * 10 ** 3 return atime","title":"get_avg_time()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_VOA_with_OPM.get_frequency","text":"Queries the optical frequency setting of the instrument in THz. Returns: Type Description float The optical frequency setting value in THz. Source code in pyinst\\models.py 361 362 363 364 365 366 367 368 def get_frequency ( self ) -> float : \"\"\" Queries the optical frequency setting of the instrument in THz. Returns: The optical frequency setting value in THz. \"\"\" return super () . get_frequency ()","title":"get_frequency()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_VOA_with_OPM.get_pow_cal","text":"Get the power calibration offset in dB. Note The power calibration value defined here is opposite in sign with the instrument display value. This is to unify the definition of power calibration across different models of OPMs. Please refer to get_power_value for the math equation. Returns: Type Description float The power calibration offset in dB. Source code in pyinst\\models.py 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 def get_pow_cal ( self ) -> float : \"\"\" Get the power calibration offset in dB. Note: The power calibration value defined here is opposite in sign with the instrument display value. This is to unify the definition of power calibration across different models of OPMs. Please refer to `get_power_value` for the math equation. Returns: The power calibration offset in dB. \"\"\" cmd = \":OUTPut {slot:d} :POWer:OFFSet?\" . format ( slot = self . _slot ) cal = - float ( self . query ( cmd )) return cal","title":"get_pow_cal()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_VOA_with_OPM.get_power_unit","text":"Get optical power unit setting. Returns: Type Description OpticalPowerUnit The unit of the optical power. Source code in pyinst\\models.py 415 416 417 418 419 420 421 422 423 def get_power_unit ( self ) -> OpticalPowerUnit : \"\"\"Get optical power unit setting. Returns: The unit of the optical power. \"\"\" cmd = \":OUTPut {slot:d} :POWer:UNit?\" . format ( slot = self . _slot ) unit_int = int ( self . query ( cmd )) return OpticalPowerUnit ( unit_int )","title":"get_power_unit()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_VOA_with_OPM.get_power_value","text":"Fetch the value of measured optical power in current unit setting. The measured value includes the power calibration. Measured value (dBm) = the actual measured value (dBm) + power calibration (dB) Refer to get_pow_cal and set_pow_cal to operate with the power calibration. Returns: Type Description float The value of the optical power. Source code in pyinst\\models.py 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 def get_power_value ( self ) -> float : \"\"\"Fetch the value of measured optical power in current unit setting. The measured value includes the power calibration. Measured value (dBm) = the actual measured value (dBm) + power calibration (dB) Refer to `get_pow_cal` and `set_pow_cal` to operate with the power calibration. Returns: The value of the optical power. \"\"\" cmd = \":FETC {slot:d} :POW?\" . format ( slot = self . _slot ) power_value = float ( self . query ( cmd )) return power_value","title":"get_power_value()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_VOA_with_OPM.get_wavelength","text":"Queries the optical wavelength setting of the instrument in nm. Returns: Type Description float The optical wavelength setting value in nm. Source code in pyinst\\models.py 378 379 380 381 382 383 384 385 386 def get_wavelength ( self ) -> float : \"\"\"Queries the optical wavelength setting of the instrument in nm. Returns: The optical wavelength setting value in nm. \"\"\" cmd = \":INPut {slot:d} :WAVelength?\" . format ( slot = self . _slot ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl","title":"get_wavelength()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_VOA_with_OPM.is_enabled","text":"Returns: Type Description bool Whether the optical output is enabled. Source code in pyinst\\models.py 503 504 505 506 507 508 509 510 def is_enabled ( self ) -> bool : \"\"\" Returns: Whether the optical output is enabled. \"\"\" cmd = \":OUTP {slot:d} ?\" . format ( slot = self . _slot ) status = bool ( int ( self . query ( cmd ))) return status","title":"is_enabled()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_VOA_with_OPM.max_att","text":"Maximum settable attenuation in dB. The maximum settable attenuation = The maximum attenuation + the optical attenuation offset value. Source code in pyinst\\models.py 336 337 338 339 340 341 342 343 344 345 @property def max_att ( self ) -> float : \"\"\"Maximum settable attenuation in dB. The maximum settable attenuation = The maximum attenuation + the optical attenuation offset value. \"\"\" cmd = \":INP {slot:d} :ATT? MAX\" . format ( slot = self . _slot ) att = float ( self . query ( cmd )) return att","title":"max_att()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_VOA_with_OPM.max_att_offset","text":"Maximum attenuation offset value in dB. Source code in pyinst\\models.py 354 355 356 357 358 359 @property def max_att_offset ( self ) -> float : \"\"\"Maximum attenuation offset value in dB.\"\"\" cmd = \":INP {slot} :OFFS? MAX\" . format ( slot = self . _slot ) offset = float ( self . query ( cmd )) return offset","title":"max_att_offset()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_VOA_with_OPM.max_avg_time","text":"The maximum averaging time in ms. Source code in pyinst\\models.py 310 311 312 313 @property def max_avg_time ( self ) -> float : \"\"\"The maximum averaging time in ms.\"\"\" return 10000.0","title":"max_avg_time()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_VOA_with_OPM.max_frequency","text":"The maximum settable optical frequency value in THz. Source code in pyinst\\models.py 286 287 288 289 @property def max_frequency ( self ) -> float : \"\"\"The maximum settable optical frequency value in THz.\"\"\" return super () . max_frequency","title":"max_frequency()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_VOA_with_OPM.max_pow_cal","text":"The maximum power calibration value in dB. Source code in pyinst\\models.py 320 321 322 323 @property def max_pow_cal ( self ) -> float : \"\"\"The maximum power calibration value in dB.\"\"\" return 200.0","title":"max_pow_cal()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_VOA_with_OPM.max_wavelength","text":"The maximum settable optical wavelength value in nm. Source code in pyinst\\models.py 298 299 300 301 302 303 @property def max_wavelength ( self ) -> float : \"\"\"The maximum settable optical wavelength value in nm.\"\"\" cmd = \":INPut {slot:d} :WAVelength? MAX\" . format ( slot = self . _slot ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl","title":"max_wavelength()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_VOA_with_OPM.min_att","text":"Minimum settable attenuation in dB. The minimum settable attenuation = 0 dB + the optical attenuation offset value. Source code in pyinst\\models.py 325 326 327 328 329 330 331 332 333 334 @property def min_att ( self ) -> float : \"\"\"Minimum settable attenuation in dB. The minimum settable attenuation = 0 dB + the optical attenuation offset value. \"\"\" cmd = \":INP {slot:d} :ATT? MIN\" . format ( slot = self . _slot ) att = float ( self . query ( cmd )) return att","title":"min_att()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_VOA_with_OPM.min_att_offset","text":"Minimum attenuation offset value in dB. Source code in pyinst\\models.py 347 348 349 350 351 352 @property def min_att_offset ( self ) -> float : \"\"\"Minimum attenuation offset value in dB.\"\"\" cmd = \":INP {slot} :OFFS? MIN\" . format ( slot = self . _slot ) offset = float ( self . query ( cmd )) return offset","title":"min_att_offset()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_VOA_with_OPM.min_avg_time","text":"The minimum averaging time in ms. Source code in pyinst\\models.py 305 306 307 308 @property def min_avg_time ( self ) -> float : \"\"\"The minimum averaging time in ms.\"\"\" return 2.0","title":"min_avg_time()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_VOA_with_OPM.min_frequency","text":"The minimum settable optical frequency value in THz. Source code in pyinst\\models.py 281 282 283 284 @property def min_frequency ( self ) -> float : \"\"\"The minimum settable optical frequency value in THz.\"\"\" return super () . min_frequency","title":"min_frequency()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_VOA_with_OPM.min_pow_cal","text":"The minimum power calibration value in dB. Source code in pyinst\\models.py 315 316 317 318 @property def min_pow_cal ( self ) -> float : \"\"\"The minimum power calibration value in dB.\"\"\" return - 200.0","title":"min_pow_cal()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_VOA_with_OPM.min_wavelength","text":"The minimum settable optical wavelength value in nm. Source code in pyinst\\models.py 291 292 293 294 295 296 @property def min_wavelength ( self ) -> float : \"\"\"The minimum settable optical wavelength value in nm.\"\"\" cmd = \":INPut {slot:d} :WAVelength? MIN\" . format ( slot = self . _slot ) wl = float ( self . query ( cmd )) * 10 ** 9 return wl","title":"min_wavelength()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_VOA_with_OPM.set_att","text":"Set attenuation value in dB. Includes the attenuation offset. Refer to get_att for more information. Parameters: Name Type Description Default att int | float The attenuation value in dB. required Source code in pyinst\\models.py 530 531 532 533 534 535 536 537 538 539 540 541 542 543 def set_att ( self , att : int | float ) -> None : \"\"\" Set attenuation value in dB. Includes the attenuation offset. Refer to `get_att` for more information. Args: att: The attenuation value in dB. \"\"\" if not self . min_att <= att <= self . max_att : raise ValueError ( f 'Parameter att is out of range: { att !r} ' ) cmd = \":INP {slot:d} :ATT {value:.3f} DB\" . format ( slot = self . _slot , value = att ) self . command ( cmd )","title":"set_att()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_VOA_with_OPM.set_att_offset","text":"Set the attenuation offset value in dB. Parameters: Name Type Description Default offset int | float The attenuation offset in dB. required Source code in pyinst\\models.py 556 557 558 559 560 561 562 563 564 565 def set_att_offset ( self , offset : int | float ) -> None : \"\"\" Set the attenuation offset value in dB. Args: offset: The attenuation offset in dB. \"\"\" if not self . min_att_offset <= offset <= self . max_att_offset : raise ValueError ( f \"Parameter offset is out of range: { offset !r} \" ) self . command ( \":INP {slot:d} :OFFS {value:.3f} DB\" . format ( slot = self . _slot , value = offset ))","title":"set_att_offset()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_VOA_with_OPM.set_avg_time","text":"Set the averaging time in ms. Parameters: Name Type Description Default value int | float The averaging time in ms. required Source code in pyinst\\models.py 475 476 477 478 479 480 481 482 483 484 485 def set_avg_time ( self , value : int | float ) -> None : \"\"\" Set the averaging time in ms. Args: value: The averaging time in ms. \"\"\" if not self . min_avg_time <= value <= self . max_avg_time : raise ValueError ( f \"Parameter value is out of range: { value !r} \" ) cmd = \":OUTPut {slot:d} :ATIMe {value} MS\" . format ( slot = self . _slot , value = value ) self . command ( cmd )","title":"set_avg_time()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_VOA_with_OPM.set_frequency","text":"Set optical frequency. Parameters: Name Type Description Default frequency int | float The optical frequency setting in THz. required Source code in pyinst\\models.py 370 371 372 373 374 375 376 def set_frequency ( self , frequency : int | float ) -> None : \"\"\"Set optical frequency. Args: frequency: The optical frequency setting in THz. \"\"\" return super () . set_frequency ( frequency )","title":"set_frequency()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_VOA_with_OPM.set_pow_cal","text":"Set the power calibration offset in dB. Parameters: Name Type Description Default value int | float The power calibration offset in dB. required Source code in pyinst\\models.py 452 453 454 455 456 457 458 459 460 461 462 def set_pow_cal ( self , value : int | float ) -> None : \"\"\" Set the power calibration offset in dB. Args: value: The power calibration offset in dB. \"\"\" if not self . min_pow_cal <= value <= self . max_pow_cal : raise ValueError ( f \"Parameter value is out of range: { value !r} \" ) cmd = \":OUTPut {slot:d} :POWer:OFFSet {value} DB\" . format ( slot = self . _slot , value =- value ) # opposite sign self . command ( cmd )","title":"set_pow_cal()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_VOA_with_OPM.set_power_unit","text":"Set the unit of optical power. Parameters: Name Type Description Default unit OpticalPowerUnit The unit of the optical power. required Source code in pyinst\\models.py 425 426 427 428 429 430 431 432 433 def set_power_unit ( self , unit : OpticalPowerUnit ) -> None : \"\"\"Set the unit of optical power. Args: unit: The unit of the optical power. \"\"\" unit = OpticalPowerUnit ( unit ) cmd = \":OUTPut {slot:d} :POWer:UNit {unit:d} \" . format ( slot = self . _slot , unit = unit ) self . command ( cmd )","title":"set_power_unit()"},{"location":"api/models/#pyinst.models.BaseModelN77xx_VOA_with_OPM.set_wavelength","text":"Set optical wavelength. Parameters: Name Type Description Default wavelength int | float The optical wavelength setting in nm. required Source code in pyinst\\models.py 388 389 390 391 392 393 394 395 396 397 def set_wavelength ( self , wavelength : int | float ) -> None : \"\"\"Set optical wavelength. Args: wavelength: The optical wavelength setting in nm. \"\"\" if not self . min_wavelength <= wavelength <= self . max_wavelength : raise ValueError ( f \"Parameter wavelength is out of range: { wavelength } \" ) cmd = \":INPut {slot:d} :WAVelength {wl} NM\" . format ( slot = self . _slot , wl = wavelength ) self . command ( cmd )","title":"set_wavelength()"},{"location":"api/models/#pyinst.models.BaseModelSantecBandwidthTunableFilter","text":"Bases: VisaInstrument , TypeOTF Source code in pyinst\\models.py 4018 4019 4020 4021 4022 4023 4024 4025 4026 4027 4028 4029 4030 4031 4032 4033 4034 4035 4036 4037 4038 4039 4040 4041 4042 4043 4044 4045 4046 4047 4048 4049 4050 4051 4052 4053 4054 4055 4056 4057 4058 4059 4060 4061 4062 4063 4064 4065 4066 4067 4068 4069 4070 4071 4072 4073 4074 4075 4076 4077 4078 4079 4080 4081 4082 4083 4084 4085 4086 4087 4088 4089 4090 4091 4092 4093 4094 4095 4096 4097 4098 4099 4100 4101 4102 4103 4104 4105 4106 4107 4108 4109 4110 4111 4112 4113 4114 class BaseModelSantecBandwidthTunableFilter ( VisaInstrument , TypeOTF ): def __init__ ( self , resource_name : str , read_termination : str = ' \\r\\n ' , write_termination : str = ' \\r\\n ' , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. read_termination: Read termination character. write_termination: Write termination character. \"\"\" super () . __init__ ( resource_name , read_termination = read_termination , write_termination = write_termination , ** kwargs ) @property def min_frequency ( self ) -> float : cmd = ':FREQuency? MIN' freq = float ( self . query ( cmd )) / 10 ** 12 return freq @property def max_frequency ( self ) -> float : cmd = ':FREQuency? MAX' freq = float ( self . query ( cmd )) / 10 ** 12 return freq @property def min_wavelength ( self ) -> float : cmd = ':WAVelength? MIN' wl = float ( self . query ( cmd )) * 10 ** 9 return wl @property def max_wavelength ( self ) -> float : cmd = ':WAVelength? MAX' wl = float ( self . query ( cmd )) * 10 ** 9 return wl @property def min_bandwidth_in_nm ( self ) -> float : cmd = ':BANDwidth? MIN' bw = float ( self . query ( cmd )) * 10 ** 9 return bw @property def max_bandwidth_in_nm ( self ) -> float : cmd = ':BANDwidth? MAX' bw = float ( self . query ( cmd )) * 10 ** 9 return bw @property def min_bandwidth_in_ghz ( self ) -> float : return super () . min_bandwidth_in_ghz @property def max_bandwidth_in_ghz ( self ) -> float : return super () . max_bandwidth_in_ghz def get_wavelength ( self ) -> float : cmd = ':WAVelength?' wl = float ( self . query ( cmd )) * 10 ** 9 return wl def set_wavelength ( self , wavelength : int | float ) -> None : if not self . min_wavelength <= wavelength <= self . max_wavelength : raise ValueError ( 'Parameter wavelength out of range: {wl!r} ' . format ( wl = wavelength )) cmd = ':WAVelength {wl:.3f} nm' . format ( wl = wavelength ) self . command ( cmd ) def get_frequency ( self ) -> float : cmd = ':FREQuency?' freq = float ( self . query ( cmd )) / 10 ** 12 return freq def set_frequency ( self , frequency : int | float ) -> None : if not self . min_frequency <= frequency <= self . max_frequency : raise ValueError ( 'Parameter frequency out of range: {freq!r} ' . format ( freq = frequency )) cmd = ':FREQuency {freq:.5f} THz' . format ( freq = frequency ) self . command ( cmd ) def get_bandwidth_in_nm ( self ) -> float : cmd = ':BANDwidth?' bw = float ( self . query ( cmd )) * 10 ** 9 return bw def set_bandwidth_in_nm ( self , value : int | float ) -> None : if not self . min_bandwidth_in_nm <= value <= self . max_bandwidth_in_nm : raise ValueError ( 'Parameter value out of range: {val!r} ' . format ( val = value )) cmd = ':BANDwidth {value:.3f} nm' . format ( value ) self . command ( cmd ) def get_bandwidth_in_ghz ( self ) -> float : return super () . get_bandwidth_in_ghz () def set_bandwidth_in_ghz ( self , value : int | float ) -> None : return super () . set_bandwidth_in_ghz ( value )","title":"BaseModelSantecBandwidthTunableFilter"},{"location":"api/models/#pyinst.models.BaseModelSantecBandwidthTunableFilter.__init__","text":"Parameters: Name Type Description Default resource_name str Resource name or alias of the VISA resource to open. required read_termination str Read termination character. '\\r\\n' write_termination str Write termination character. '\\r\\n' Source code in pyinst\\models.py 4020 4021 4022 4023 4024 4025 4026 4027 4028 4029 4030 4031 def __init__ ( self , resource_name : str , read_termination : str = ' \\r\\n ' , write_termination : str = ' \\r\\n ' , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. read_termination: Read termination character. write_termination: Write termination character. \"\"\" super () . __init__ ( resource_name , read_termination = read_termination , write_termination = write_termination , ** kwargs )","title":"__init__()"},{"location":"api/models/#pyinst.models.BaseModelVSA89600","text":"Bases: VisaInstrument Base class of instrument models based on Keysight 89600 VSA software. Source code in pyinst\\models.py 1858 1859 1860 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 2167 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 class BaseModelVSA89600 ( VisaInstrument ): \"\"\" Base class of instrument models based on Keysight 89600 VSA software. \"\"\" def __init__ ( self , resource_name , encoding = 'latin1' , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. encoding: Encoding of VISA IO string. Default to `\"latin1\"` since there are some particular caractors. kwargs: directly passed to `VisaInstrument.__init__`. \"\"\" super ( BaseModelVSA89600 , self ) . __init__ ( resource_name , encoding = encoding , ** kwargs ) self . __custom_measurement_demod_filters = { \"None\" , \"Rectangular\" , \"RootRaisedCosine\" , \"Gaussian\" , \"LowPass\" } self . __custom_reference_demod_filters = { \"Rectangular\" , \"RaisedCosine\" , \"RootRaisedCosine\" , \"Gaussian\" , \"HalfSine\" } @property def CUSTOM_DEMOD_MEASUREMENT_FILTERS ( self ) -> set : \"\"\"Options for measurement filter types. Refer to `get_custom_demod_measurement_filter` and `set_custom_demod_measurement_filter`. \"\"\" return self . __custom_measurement_demod_filters @property def CUSTOM_DEMOD_REFERENCE_FILTERS ( self ) -> set : \"\"\"Options for reference filter types. Refer to `get_custom_demod_reference_filter` and `set_custom_demod_reference_filter`. \"\"\" return self . __custom_reference_demod_filters # Methods def run ( self , state : bool = True ) -> None : \"\"\"Resume or stop the measurement. - state == True: Causes the measurement to transition to the Running state. - state == False: Immediately stops the measurement, clearing all measurement data. \"\"\" if state : self . command ( \":INITiate:RESume\" ) else : self . command ( \":INITiate:ABORt\" ) def stop ( self ) -> None : \"\"\"Immediately stops the measurement, clearing all measurement data.\"\"\" self . run ( state = False ) def pause ( self ) -> None : \"\"\"Causes the measurement to transition to the Paused state.\"\"\" self . command ( \":INITiate:PAUSe\" ) def restart ( self ) -> None : \"\"\"Causes the measurement to restart. The Average count is reset to 0 and the measurement transitions to the Running State. \"\"\" self . command ( \":INITiate:RESTart\" ) def get_data_table_names ( self , trace : int ) -> List [ str ]: \"\"\" Returns a list of all names in the data table for the specified trace. Args: trace: index of trace, 1 based from A. For example, A->1, E->5 Returns: a list of all names in the data table. \"\"\" if not isinstance ( trace , int ): raise TypeError ( 'param trace should be int' ) if not trace >= 1 : raise ValueError ( 'param trace starts from 1' ) name_str = self . query ( \":TRACe {trace:d} :DATA:TABLe:NAME?\" . format ( trace = trace )) name_list = list ( map ( lambda x : x . strip ( '\"' ), name_str . split ( \",\" ))) return name_list def get_data_table_values ( self , trace : int ) -> List [ int | float | str ]: \"\"\"Gets a list of values from a data table. Enum values are returned as enum indexes. Args: trace: index of trace, 1 based from A. For example, A->1, E->5 Returns: a list of values from a data table. \"\"\" if not isinstance ( trace , int ): raise TypeError ( 'param trace should be int' ) if not trace >= 1 : raise ValueError ( 'param trace starts from 1' ) value_str = self . query ( \":TRACe {trace:d} :DATA:TABLe?\" . format ( trace = trace )) raw_values = value_str . split ( \",\" ) values = [] for r_val in raw_values : try : val = int ( r_val ) except ValueError : try : val = float ( r_val ) except : val = r_val values . append ( val ) return values def get_data_table_units ( self , trace : int ) -> List [ str ]: \"\"\" Get all the units of the specified trace. Args: trace: index of trace, 1 based from A. For example, A->1, E->5 Returns: list of trace item units. \"\"\" if not isinstance ( trace , int ): raise TypeError ( 'param trace should be int.' ) if not trace >= 1 : raise ValueError ( 'param trace starts from 1' ) unit_str = self . query ( ':TRACe {trace:d} :DATA:TABLe:UNIT?' . format ( trace = trace )) unit_list = list ( map ( lambda x : x . strip ( '\"' ), unit_str . split ( \",\" ))) return unit_list def get_data_table ( self , trace : int ) -> dict : \"\"\" Get formatted data including table item names, values, and units. Args: trace: index of trace, 1 based from A. For example, A->1, E->5 Returns: Mapping[name => (value, unit)] \"\"\" names = self . get_data_table_names ( trace ) values = self . get_data_table_values ( trace ) units = self . get_data_table_units ( trace ) if len ( names ) == len ( values ) == len ( units ): i_len = len ( names ) else : raise IndexError ( 'Numbers of names, values and units do not match.' ) data = {} for i in range ( i_len ): data [ names [ i ]] = ( values [ i ], units [ i ]) return data def get_custom_demod_measurement_filter ( self ) -> str : \"\"\"Gets the measurement filter applied during the digital demodulation measurement. Returns: `\"None\"` | `\"Rectangular\"` | `\"RootRaisedCosine\"` | `\"Gaussian\"` | `\"LowPass\"` \"\"\" cmd = \":CDEMod:FILTer?\" filter_type = self . query ( cmd ) . strip () . strip ( '\"' ) return filter_type def set_custom_demod_measurement_filter ( self , filter_type : str ) -> None : \"\"\"Sets the measurement filter applied during the digital demodulation measurement. Args: filter_type: `\"None\"` | `\"Rectangular\"` | `\"RootRaisedCosine\"` | `\"Gaussian\"` | `\"LowPass\"` \"\"\" if filter_type not in self . CUSTOM_DEMOD_MEASUREMENT_FILTERS : raise ValueError ( 'Invalid filter_type value: {filter!r} ' . format ( filter = filter_type )) cmd = \":CDEMod:FILTer \\\" {filter} \\\" \" . format ( filter = filter_type ) self . command ( cmd ) def get_custom_demod_reference_filter ( self ) -> str : \"\"\"Gets the reference filter applied during the digital demodulation measurement. Returns: `\"Rectangular\"` | `\"RaisedCosine\"` | `\"RootRaisedCosine\"` | `\"Gaussian\"` | `\"HalfSine\"` \"\"\" cmd = ':CDEMod:FILTer:REFerence?' filter_type = self . query ( cmd ) . strip () . strip ( '\"' ) return filter_type def set_custom_demod_reference_filter ( self , filter_type : str ) -> None : \"\"\"Sets the reference filter applied during the digital demodulation measurement. Args: filter_type: `\"Rectangular\"` | `\"RaisedCosine\"` | `\"RootRaisedCosine\"` | `\"Gaussian\"` | `\"HalfSine\"` \"\"\" if filter_type not in self . CUSTOM_DEMOD_REFERENCE_FILTERS : raise ValueError ( 'Invalid filter_type value: {filter!r} ' . format ( filter = filter_type )) cmd = \":CDEMod:FILTer:REFerence \\\" {filter} \\\" \" . format ( filter = filter_type ) self . command ( cmd ) def get_custom_demod_filter_abt ( self ) -> float : \"\"\" Gets the \u03b1 (alpha) or BT (bandwidth time product) parameter for measurement and reference filters. \"\"\" cmd = ':CDEMod:FILTer:ABT?' abt = float ( self . query ( cmd )) return abt def set_custom_demod_filter_abt ( self , abt : int | float ) -> None : \"\"\" Sets the \u03b1 (alpha) or BT (bandwidth time product) parameter for measurement and reference filters. Args: abt: alpha or BT value. \"\"\" cmd = ':CDEMod:FILTer:ABT {value:f} ' . format ( value = round ( abt , 6 )) self . command ( cmd ) def get_custom_demod_equalization_state ( self ) -> bool : \"\"\" Gets a value indicating whether the equalization filter is enabled. \"\"\" cmd = ':CDEMod:COMPensate:EQUalize?' state = bool ( int ( self . query ( cmd ))) return state def set_custom_demod_equalization_state ( self , enable : bool ) -> None : \"\"\" Sets a value indicating whether the equalization filter is enabled. Args: enable: True = enabled, False = disabled. \"\"\" if not isinstance ( enable , bool ): raise TypeError ( 'parameter enable should be bool.' ) cmd = ':CDEMod:COMPensate:EQUalize {state:d} ' . format ( state = enable ) self . command ( cmd ) def get_custom_demod_equalization_length ( self ) -> int : \"\"\"Gets the length of the equalization filter, in symbols. Returns: length of the equalization fileter in symbols. \"\"\" cmd = ':CDEMod:COMPensate:EQUalize:LENGth?' rpl = self . query ( cmd ) return int ( rpl ) def set_custom_demod_equalization_length ( self , symbols : int ) -> None : \"\"\"Sets the length of the equalization filter, in symbols. Args: symbols: length of the equalization fileter in symbols. \"\"\" if not symbols >= 3 : raise ValueError ( 'param symbols should >= 3: {symbols} ' . format ( symbols = symbols )) cmd = ':CDEMod:COMPensate:EQUalize:LENGth {value:d} ' . format ( value = symbols ) self . command ( cmd ) def get_custom_demod_equalization_convergence ( self ) -> float : \"\"\"Gets the convergence parameter for the Adaptive Equalizer. Returns: the convergence parameter \"\"\" cmd = \":CDEMod:COMPensate:EQUalize:CONVergence?\" param = float ( self . query ( cmd )) return param def set_custom_demod_equalization_convergence ( self , value : int | float ) -> None : \"\"\"Sets the convergence parameter for the Adaptive Equalizer. Args: value: the convergence parameter value \"\"\" if not 1E-8 <= value <= 1e-6 : raise ValueError ( 'Invalid value of EQ convergence: should between 1E-6 and 1E-8.' ) cmd = ':CDEMod:COMPensate:EQUalize:CONVergence {value:.4E} ' . format ( value = value ) self . command ( cmd ) def get_custom_demod_equalizer_run_mode ( self ) -> str : \"\"\" Gets the run mode of the Adaptive Equalizer. Returns: run mode: `\"Run\"` | `\"Hold\"` \"\"\" cmd = ':CDEMod:COMPensate:EQUalize:MODE?' mode = self . query ( cmd ) . strip () . strip ( '\"' ) return mode def set_custom_demod_equalizer_run_mode ( self , mode : str ) -> None : \"\"\" Sets the run mode of the Adaptive Equalizer. Args: mode: `\"Run\"` | `\"Hold\"` \"\"\" MODES = { \"Run\" , \"Hold\" } if mode not in MODES : raise ValueError ( 'Invalid value for Custom Demod EQ run mode: {vlaue!r} ' . format ( mode )) cmd = ':CDEMod:COMPensate:EQUalize:MODE {value} ' . format ( value = mode ) self . command ( cmd ) def reset_custom_demod_equalizer ( self ) -> None : \"\"\"Reset the equalizer filter\"\"\" cmd = ':CDEMod:COMPensate:EQUalize:RESet' self . command ( cmd ) def get_custom_demod_result_length ( self ) -> int : \"\"\"Gets the demodulation measurement result length (in symbols). Returns: result length in symbols \"\"\" cmd = ':CDEMod:RLENgth?' l = int ( self . query ( cmd )) return l def set_custom_demod_result_length ( self , length : int ) -> None : \"\"\"Gets the demodulation measurement result length (in symbols). Args: length: result length in symbols \"\"\" cmd = ':CDEMod:RLENgth {v:d} ' . format ( v = length ) self . command ( cmd )","title":"BaseModelVSA89600"},{"location":"api/models/#pyinst.models.BaseModelVSA89600.CUSTOM_DEMOD_MEASUREMENT_FILTERS","text":"Options for measurement filter types. Refer to get_custom_demod_measurement_filter and set_custom_demod_measurement_filter . Source code in pyinst\\models.py 1874 1875 1876 1877 1878 1879 1880 1881 @property def CUSTOM_DEMOD_MEASUREMENT_FILTERS ( self ) -> set : \"\"\"Options for measurement filter types. Refer to `get_custom_demod_measurement_filter` and `set_custom_demod_measurement_filter`. \"\"\" return self . __custom_measurement_demod_filters","title":"CUSTOM_DEMOD_MEASUREMENT_FILTERS()"},{"location":"api/models/#pyinst.models.BaseModelVSA89600.CUSTOM_DEMOD_REFERENCE_FILTERS","text":"Options for reference filter types. Refer to get_custom_demod_reference_filter and set_custom_demod_reference_filter . Source code in pyinst\\models.py 1883 1884 1885 1886 1887 1888 1889 1890 @property def CUSTOM_DEMOD_REFERENCE_FILTERS ( self ) -> set : \"\"\"Options for reference filter types. Refer to `get_custom_demod_reference_filter` and `set_custom_demod_reference_filter`. \"\"\" return self . __custom_reference_demod_filters","title":"CUSTOM_DEMOD_REFERENCE_FILTERS()"},{"location":"api/models/#pyinst.models.BaseModelVSA89600.__init__","text":"Parameters: Name Type Description Default resource_name Resource name or alias of the VISA resource to open. required encoding Encoding of VISA IO string. Default to \"latin1\" since there are some particular caractors. 'latin1' kwargs directly passed to VisaInstrument.__init__ . required Source code in pyinst\\models.py 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 def __init__ ( self , resource_name , encoding = 'latin1' , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. encoding: Encoding of VISA IO string. Default to `\"latin1\"` since there are some particular caractors. kwargs: directly passed to `VisaInstrument.__init__`. \"\"\" super ( BaseModelVSA89600 , self ) . __init__ ( resource_name , encoding = encoding , ** kwargs ) self . __custom_measurement_demod_filters = { \"None\" , \"Rectangular\" , \"RootRaisedCosine\" , \"Gaussian\" , \"LowPass\" } self . __custom_reference_demod_filters = { \"Rectangular\" , \"RaisedCosine\" , \"RootRaisedCosine\" , \"Gaussian\" , \"HalfSine\" }","title":"__init__()"},{"location":"api/models/#pyinst.models.BaseModelVSA89600.get_custom_demod_equalization_convergence","text":"Gets the convergence parameter for the Adaptive Equalizer. Returns: Type Description float the convergence parameter Source code in pyinst\\models.py 2111 2112 2113 2114 2115 2116 2117 2118 2119 def get_custom_demod_equalization_convergence ( self ) -> float : \"\"\"Gets the convergence parameter for the Adaptive Equalizer. Returns: the convergence parameter \"\"\" cmd = \":CDEMod:COMPensate:EQUalize:CONVergence?\" param = float ( self . query ( cmd )) return param","title":"get_custom_demod_equalization_convergence()"},{"location":"api/models/#pyinst.models.BaseModelVSA89600.get_custom_demod_equalization_length","text":"Gets the length of the equalization filter, in symbols. Returns: Type Description int length of the equalization fileter in symbols. Source code in pyinst\\models.py 2090 2091 2092 2093 2094 2095 2096 2097 2098 def get_custom_demod_equalization_length ( self ) -> int : \"\"\"Gets the length of the equalization filter, in symbols. Returns: length of the equalization fileter in symbols. \"\"\" cmd = ':CDEMod:COMPensate:EQUalize:LENGth?' rpl = self . query ( cmd ) return int ( rpl )","title":"get_custom_demod_equalization_length()"},{"location":"api/models/#pyinst.models.BaseModelVSA89600.get_custom_demod_equalization_state","text":"Gets a value indicating whether the equalization filter is enabled. Source code in pyinst\\models.py 2070 2071 2072 2073 2074 2075 2076 def get_custom_demod_equalization_state ( self ) -> bool : \"\"\" Gets a value indicating whether the equalization filter is enabled. \"\"\" cmd = ':CDEMod:COMPensate:EQUalize?' state = bool ( int ( self . query ( cmd ))) return state","title":"get_custom_demod_equalization_state()"},{"location":"api/models/#pyinst.models.BaseModelVSA89600.get_custom_demod_equalizer_run_mode","text":"Gets the run mode of the Adaptive Equalizer. Returns: Type Description str run mode: \"Run\" | \"Hold\" Source code in pyinst\\models.py 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 def get_custom_demod_equalizer_run_mode ( self ) -> str : \"\"\" Gets the run mode of the Adaptive Equalizer. Returns: run mode: `\"Run\"` | `\"Hold\"` \"\"\" cmd = ':CDEMod:COMPensate:EQUalize:MODE?' mode = self . query ( cmd ) . strip () . strip ( '\"' ) return mode","title":"get_custom_demod_equalizer_run_mode()"},{"location":"api/models/#pyinst.models.BaseModelVSA89600.get_custom_demod_filter_abt","text":"Gets the \u03b1 (alpha) or BT (bandwidth time product) parameter for measurement and reference filters. Source code in pyinst\\models.py 2052 2053 2054 2055 2056 2057 2058 def get_custom_demod_filter_abt ( self ) -> float : \"\"\" Gets the \u03b1 (alpha) or BT (bandwidth time product) parameter for measurement and reference filters. \"\"\" cmd = ':CDEMod:FILTer:ABT?' abt = float ( self . query ( cmd )) return abt","title":"get_custom_demod_filter_abt()"},{"location":"api/models/#pyinst.models.BaseModelVSA89600.get_custom_demod_measurement_filter","text":"Gets the measurement filter applied during the digital demodulation measurement. Returns: Type Description str \"None\" | \"Rectangular\" | \"RootRaisedCosine\" | \"Gaussian\" | \"LowPass\" Source code in pyinst\\models.py 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 def get_custom_demod_measurement_filter ( self ) -> str : \"\"\"Gets the measurement filter applied during the digital demodulation measurement. Returns: `\"None\"` | `\"Rectangular\"` | `\"RootRaisedCosine\"` | `\"Gaussian\"` | `\"LowPass\"` \"\"\" cmd = \":CDEMod:FILTer?\" filter_type = self . query ( cmd ) . strip () . strip ( '\"' ) return filter_type","title":"get_custom_demod_measurement_filter()"},{"location":"api/models/#pyinst.models.BaseModelVSA89600.get_custom_demod_reference_filter","text":"Gets the reference filter applied during the digital demodulation measurement. Returns: Type Description str \"Rectangular\" | \"RaisedCosine\" | \"RootRaisedCosine\" | \"Gaussian\" | \"HalfSine\" Source code in pyinst\\models.py 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 def get_custom_demod_reference_filter ( self ) -> str : \"\"\"Gets the reference filter applied during the digital demodulation measurement. Returns: `\"Rectangular\"` | `\"RaisedCosine\"` | `\"RootRaisedCosine\"` | `\"Gaussian\"` | `\"HalfSine\"` \"\"\" cmd = ':CDEMod:FILTer:REFerence?' filter_type = self . query ( cmd ) . strip () . strip ( '\"' ) return filter_type","title":"get_custom_demod_reference_filter()"},{"location":"api/models/#pyinst.models.BaseModelVSA89600.get_custom_demod_result_length","text":"Gets the demodulation measurement result length (in symbols). Returns: Type Description int result length in symbols Source code in pyinst\\models.py 2161 2162 2163 2164 2165 2166 2167 2168 2169 def get_custom_demod_result_length ( self ) -> int : \"\"\"Gets the demodulation measurement result length (in symbols). Returns: result length in symbols \"\"\" cmd = ':CDEMod:RLENgth?' l = int ( self . query ( cmd )) return l","title":"get_custom_demod_result_length()"},{"location":"api/models/#pyinst.models.BaseModelVSA89600.get_data_table","text":"Get formatted data including table item names, values, and units. Parameters: Name Type Description Default trace int index of trace, 1 based from A. For example, A->1, E->5 required Returns: Type Description dict Mapping[name => (value, unit)] Source code in pyinst\\models.py 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 def get_data_table ( self , trace : int ) -> dict : \"\"\" Get formatted data including table item names, values, and units. Args: trace: index of trace, 1 based from A. For example, A->1, E->5 Returns: Mapping[name => (value, unit)] \"\"\" names = self . get_data_table_names ( trace ) values = self . get_data_table_values ( trace ) units = self . get_data_table_units ( trace ) if len ( names ) == len ( values ) == len ( units ): i_len = len ( names ) else : raise IndexError ( 'Numbers of names, values and units do not match.' ) data = {} for i in range ( i_len ): data [ names [ i ]] = ( values [ i ], units [ i ]) return data","title":"get_data_table()"},{"location":"api/models/#pyinst.models.BaseModelVSA89600.get_data_table_names","text":"Returns a list of all names in the data table for the specified trace. Parameters: Name Type Description Default trace int index of trace, 1 based from A. For example, A->1, E->5 required Returns: Type Description List [ str ] a list of all names in the data table. Source code in pyinst\\models.py 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 def get_data_table_names ( self , trace : int ) -> List [ str ]: \"\"\" Returns a list of all names in the data table for the specified trace. Args: trace: index of trace, 1 based from A. For example, A->1, E->5 Returns: a list of all names in the data table. \"\"\" if not isinstance ( trace , int ): raise TypeError ( 'param trace should be int' ) if not trace >= 1 : raise ValueError ( 'param trace starts from 1' ) name_str = self . query ( \":TRACe {trace:d} :DATA:TABLe:NAME?\" . format ( trace = trace )) name_list = list ( map ( lambda x : x . strip ( '\"' ), name_str . split ( \",\" ))) return name_list","title":"get_data_table_names()"},{"location":"api/models/#pyinst.models.BaseModelVSA89600.get_data_table_units","text":"Get all the units of the specified trace. Parameters: Name Type Description Default trace int index of trace, 1 based from A. For example, A->1, E->5 required Returns: Type Description List [ str ] list of trace item units. Source code in pyinst\\models.py 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 def get_data_table_units ( self , trace : int ) -> List [ str ]: \"\"\" Get all the units of the specified trace. Args: trace: index of trace, 1 based from A. For example, A->1, E->5 Returns: list of trace item units. \"\"\" if not isinstance ( trace , int ): raise TypeError ( 'param trace should be int.' ) if not trace >= 1 : raise ValueError ( 'param trace starts from 1' ) unit_str = self . query ( ':TRACe {trace:d} :DATA:TABLe:UNIT?' . format ( trace = trace )) unit_list = list ( map ( lambda x : x . strip ( '\"' ), unit_str . split ( \",\" ))) return unit_list","title":"get_data_table_units()"},{"location":"api/models/#pyinst.models.BaseModelVSA89600.get_data_table_values","text":"Gets a list of values from a data table. Enum values are returned as enum indexes. Parameters: Name Type Description Default trace int index of trace, 1 based from A. For example, A->1, E->5 required Returns: Type Description List [ int | float | str ] a list of values from a data table. Source code in pyinst\\models.py 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 def get_data_table_values ( self , trace : int ) -> List [ int | float | str ]: \"\"\"Gets a list of values from a data table. Enum values are returned as enum indexes. Args: trace: index of trace, 1 based from A. For example, A->1, E->5 Returns: a list of values from a data table. \"\"\" if not isinstance ( trace , int ): raise TypeError ( 'param trace should be int' ) if not trace >= 1 : raise ValueError ( 'param trace starts from 1' ) value_str = self . query ( \":TRACe {trace:d} :DATA:TABLe?\" . format ( trace = trace )) raw_values = value_str . split ( \",\" ) values = [] for r_val in raw_values : try : val = int ( r_val ) except ValueError : try : val = float ( r_val ) except : val = r_val values . append ( val ) return values","title":"get_data_table_values()"},{"location":"api/models/#pyinst.models.BaseModelVSA89600.pause","text":"Causes the measurement to transition to the Paused state. Source code in pyinst\\models.py 1910 1911 1912 def pause ( self ) -> None : \"\"\"Causes the measurement to transition to the Paused state.\"\"\" self . command ( \":INITiate:PAUSe\" )","title":"pause()"},{"location":"api/models/#pyinst.models.BaseModelVSA89600.reset_custom_demod_equalizer","text":"Reset the equalizer filter Source code in pyinst\\models.py 2156 2157 2158 2159 def reset_custom_demod_equalizer ( self ) -> None : \"\"\"Reset the equalizer filter\"\"\" cmd = ':CDEMod:COMPensate:EQUalize:RESet' self . command ( cmd )","title":"reset_custom_demod_equalizer()"},{"location":"api/models/#pyinst.models.BaseModelVSA89600.restart","text":"Causes the measurement to restart. The Average count is reset to 0 and the measurement transitions to the Running State. Source code in pyinst\\models.py 1914 1915 1916 1917 1918 def restart ( self ) -> None : \"\"\"Causes the measurement to restart. The Average count is reset to 0 and the measurement transitions to the Running State. \"\"\" self . command ( \":INITiate:RESTart\" )","title":"restart()"},{"location":"api/models/#pyinst.models.BaseModelVSA89600.run","text":"Resume or stop the measurement. state == True: Causes the measurement to transition to the Running state. state == False: Immediately stops the measurement, clearing all measurement data. Source code in pyinst\\models.py 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 def run ( self , state : bool = True ) -> None : \"\"\"Resume or stop the measurement. - state == True: Causes the measurement to transition to the Running state. - state == False: Immediately stops the measurement, clearing all measurement data. \"\"\" if state : self . command ( \":INITiate:RESume\" ) else : self . command ( \":INITiate:ABORt\" )","title":"run()"},{"location":"api/models/#pyinst.models.BaseModelVSA89600.set_custom_demod_equalization_convergence","text":"Sets the convergence parameter for the Adaptive Equalizer. Parameters: Name Type Description Default value int | float the convergence parameter value required Source code in pyinst\\models.py 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 def set_custom_demod_equalization_convergence ( self , value : int | float ) -> None : \"\"\"Sets the convergence parameter for the Adaptive Equalizer. Args: value: the convergence parameter value \"\"\" if not 1E-8 <= value <= 1e-6 : raise ValueError ( 'Invalid value of EQ convergence: should between 1E-6 and 1E-8.' ) cmd = ':CDEMod:COMPensate:EQUalize:CONVergence {value:.4E} ' . format ( value = value ) self . command ( cmd )","title":"set_custom_demod_equalization_convergence()"},{"location":"api/models/#pyinst.models.BaseModelVSA89600.set_custom_demod_equalization_length","text":"Sets the length of the equalization filter, in symbols. Parameters: Name Type Description Default symbols int length of the equalization fileter in symbols. required Source code in pyinst\\models.py 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 def set_custom_demod_equalization_length ( self , symbols : int ) -> None : \"\"\"Sets the length of the equalization filter, in symbols. Args: symbols: length of the equalization fileter in symbols. \"\"\" if not symbols >= 3 : raise ValueError ( 'param symbols should >= 3: {symbols} ' . format ( symbols = symbols )) cmd = ':CDEMod:COMPensate:EQUalize:LENGth {value:d} ' . format ( value = symbols ) self . command ( cmd )","title":"set_custom_demod_equalization_length()"},{"location":"api/models/#pyinst.models.BaseModelVSA89600.set_custom_demod_equalization_state","text":"Sets a value indicating whether the equalization filter is enabled. Parameters: Name Type Description Default enable bool True = enabled, False = disabled. required Source code in pyinst\\models.py 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 def set_custom_demod_equalization_state ( self , enable : bool ) -> None : \"\"\" Sets a value indicating whether the equalization filter is enabled. Args: enable: True = enabled, False = disabled. \"\"\" if not isinstance ( enable , bool ): raise TypeError ( 'parameter enable should be bool.' ) cmd = ':CDEMod:COMPensate:EQUalize {state:d} ' . format ( state = enable ) self . command ( cmd )","title":"set_custom_demod_equalization_state()"},{"location":"api/models/#pyinst.models.BaseModelVSA89600.set_custom_demod_equalizer_run_mode","text":"Sets the run mode of the Adaptive Equalizer. Parameters: Name Type Description Default mode str \"Run\" | \"Hold\" required Source code in pyinst\\models.py 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 def set_custom_demod_equalizer_run_mode ( self , mode : str ) -> None : \"\"\" Sets the run mode of the Adaptive Equalizer. Args: mode: `\"Run\"` | `\"Hold\"` \"\"\" MODES = { \"Run\" , \"Hold\" } if mode not in MODES : raise ValueError ( 'Invalid value for Custom Demod EQ run mode: {vlaue!r} ' . format ( mode )) cmd = ':CDEMod:COMPensate:EQUalize:MODE {value} ' . format ( value = mode ) self . command ( cmd )","title":"set_custom_demod_equalizer_run_mode()"},{"location":"api/models/#pyinst.models.BaseModelVSA89600.set_custom_demod_filter_abt","text":"Sets the \u03b1 (alpha) or BT (bandwidth time product) parameter for measurement and reference filters. Parameters: Name Type Description Default abt int | float alpha or BT value. required Source code in pyinst\\models.py 2060 2061 2062 2063 2064 2065 2066 2067 2068 def set_custom_demod_filter_abt ( self , abt : int | float ) -> None : \"\"\" Sets the \u03b1 (alpha) or BT (bandwidth time product) parameter for measurement and reference filters. Args: abt: alpha or BT value. \"\"\" cmd = ':CDEMod:FILTer:ABT {value:f} ' . format ( value = round ( abt , 6 )) self . command ( cmd )","title":"set_custom_demod_filter_abt()"},{"location":"api/models/#pyinst.models.BaseModelVSA89600.set_custom_demod_measurement_filter","text":"Sets the measurement filter applied during the digital demodulation measurement. Parameters: Name Type Description Default filter_type str \"None\" | \"Rectangular\" | \"RootRaisedCosine\" | \"Gaussian\" | \"LowPass\" required Source code in pyinst\\models.py 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 def set_custom_demod_measurement_filter ( self , filter_type : str ) -> None : \"\"\"Sets the measurement filter applied during the digital demodulation measurement. Args: filter_type: `\"None\"` | `\"Rectangular\"` | `\"RootRaisedCosine\"` | `\"Gaussian\"` | `\"LowPass\"` \"\"\" if filter_type not in self . CUSTOM_DEMOD_MEASUREMENT_FILTERS : raise ValueError ( 'Invalid filter_type value: {filter!r} ' . format ( filter = filter_type )) cmd = \":CDEMod:FILTer \\\" {filter} \\\" \" . format ( filter = filter_type ) self . command ( cmd )","title":"set_custom_demod_measurement_filter()"},{"location":"api/models/#pyinst.models.BaseModelVSA89600.set_custom_demod_reference_filter","text":"Sets the reference filter applied during the digital demodulation measurement. Parameters: Name Type Description Default filter_type str \"Rectangular\" | \"RaisedCosine\" | \"RootRaisedCosine\" | \"Gaussian\" | \"HalfSine\" required Source code in pyinst\\models.py 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 def set_custom_demod_reference_filter ( self , filter_type : str ) -> None : \"\"\"Sets the reference filter applied during the digital demodulation measurement. Args: filter_type: `\"Rectangular\"` | `\"RaisedCosine\"` | `\"RootRaisedCosine\"` | `\"Gaussian\"` | `\"HalfSine\"` \"\"\" if filter_type not in self . CUSTOM_DEMOD_REFERENCE_FILTERS : raise ValueError ( 'Invalid filter_type value: {filter!r} ' . format ( filter = filter_type )) cmd = \":CDEMod:FILTer:REFerence \\\" {filter} \\\" \" . format ( filter = filter_type ) self . command ( cmd )","title":"set_custom_demod_reference_filter()"},{"location":"api/models/#pyinst.models.BaseModelVSA89600.set_custom_demod_result_length","text":"Gets the demodulation measurement result length (in symbols). Parameters: Name Type Description Default length int result length in symbols required Source code in pyinst\\models.py 2171 2172 2173 2174 2175 2176 2177 2178 def set_custom_demod_result_length ( self , length : int ) -> None : \"\"\"Gets the demodulation measurement result length (in symbols). Args: length: result length in symbols \"\"\" cmd = ':CDEMod:RLENgth {v:d} ' . format ( v = length ) self . command ( cmd )","title":"set_custom_demod_result_length()"},{"location":"api/models/#pyinst.models.BaseModelVSA89600.stop","text":"Immediately stops the measurement, clearing all measurement data. Source code in pyinst\\models.py 1906 1907 1908 def stop ( self ) -> None : \"\"\"Immediately stops the measurement, clearing all measurement data.\"\"\" self . run ( state = False )","title":"stop()"},{"location":"api/models/#pyinst.models.BaseModelVSA89600_OMA","text":"Bases: BaseModelVSA89600 , TypeOMA Base class for Keysight OMAs based on VSA 89600 software: M8290A and N4392A Optical Modulation Analyzers Source code in pyinst\\models.py 2181 2182 2183 2184 2185 2186 2187 2188 2189 2190 2191 2192 2193 2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 2212 2213 2214 2215 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 2250 2251 2252 2253 2254 2255 2256 2257 2258 2259 2260 2261 2262 2263 2264 2265 2266 2267 2268 2269 2270 2271 2272 2273 2274 2275 2276 2277 2278 2279 2280 2281 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 2293 class BaseModelVSA89600_OMA ( BaseModelVSA89600 , TypeOMA ): \"\"\"Base class for Keysight OMAs based on VSA 89600 software: - M8290A and N4392A Optical Modulation Analyzers \"\"\" @property def DEMOD_FORMATS ( self ): options = ( \"Qam16\" , \"Qam32\" , \"Qam64\" , \"Qam256\" , \"Qpsk\" , \"DifferentialQpsk\" , \"Pi4DifferentialQpsk\" , \"OffsetQpsk\" , \"Bpsk\" , \"Psk8\" , \"Msk\" , \"Msk2\" , \"Fsk2\" , \"Fsk4\" , \"DvbQam16\" , \"DvbQam32\" , \"DvbQam64\" , \"Vsb8\" , \"Vsb16\" , \"Edge\" , \"Fsk8\" , \"Fsk16\" , \"Qam128\" , \"DifferentialPsk8\" , \"Qam512\" , \"Qam1024\" , \"Apsk16\" , \"Apsk16Dvb\" , \"Apsk32\" , \"Apsk32Dvb\" , \"DvbQam128\" , \"DvbQam256\" , \"Pi8DifferentialPsk8\" , \"CpmFM\" , \"Star16Qam\" , \"Star32Qam\" , \"CustomApsk\" , \"ShapedOffsetQpsk\" ) return options @property def POLARIZATIONS ( self ): options = ( \"Single\" , \"Dual\" , \"Auto\" ) return options def get_frequency ( self ) -> float : cmd = \":OMA:SMartSEtup:CarrierFrequency:FRErequency?\" freq = float ( self . query ( cmd )) / 10 ** 12 return freq def get_wavelength ( self ) -> float : cmd = \":OMA:SMartSEtup:CarrierFrequency:WaVeLength?\" wl = float ( self . query ( cmd )) return wl def set_frequency ( self , frequency : int | float ) -> None : self . smart_setup ( freq = frequency , pre_set_layout = False ) def set_wavelength ( self , wavelength : int | float ) -> None : return super () . set_wavelength ( wavelength ) def smart_setup ( self , execute : bool = True , frequency : Optional [ int | float ] = None , symbol_rate : Optional [ int | float ] = None , fine_tune_symbol_rate : Optional [ bool ] = None , demodulation_format : Optional [ str ] = None , polarization : Optional [ str ] = None , pre_set_layout : Optional [ bool ] = None , compensate_cd : Optional [ bool ] = None , compensate_pmd : Optional [ bool ] = None ): \"\"\"Perform smart setup of the OMA. Use parameter `execute` to choose whether to execute the changed settings or not. If a setting parameter is not explicitly given (default as None), the old setting will be kept. Args: execute: Whether to execute smart setup with the new settings. If set to False, the settings of smart setup will be changed, but the OMA will not execute smart setup. frequency: The carrier frequency in THz. symbol_rate: The symbol rate in GHz. fine_tune_symbol_rate: Whether the system should try to fine tune the symbol rate. demodulation_format: The selected digital demodulation format. Refer to `DEMOD_FORMATS` for options. polarization: The expected polarization or if auto detection should be used. options: `\"Single\"` | `\"Dual\"` | `\"Auto\"`. pre_set_layout: Whether a preset of the trace layout should be performed. compensate_cd: A value indicating whether CD should be compensated. compensate_pmd: A value indicating whether PMD should be compensated. \"\"\" if frequency is not None : self . command ( ':OMA:SMartSEtup:CarrierFrequency:FRErequency {value:d} ' . format ( value = round ( frequency * 10 ** 12 ))) if symbol_rate is not None : self . command ( ':OMA:SMartSEtup:SYMBRate {value:d} ' . format ( value = round ( symbol_rate * 10 ** 9 ))) if fine_tune_symbol_rate is not None : if not isinstance ( fine_tune_symbol_rate , bool ): raise TypeError ( 'param fine_tune_symbol_rate should be bool: {val} ' . format ( val = fine_tune_symbol_rate )) self . command ( ':OMA:SMartSEtup:FINetuneSymbolRate {enable:d} ' . format ( enable = fine_tune_symbol_rate )) if demodulation_format is not None : if demodulation_format not in self . DEMOD_FORMATS : raise ValueError ( 'Invalid modulation demodulation format: {format!r} ' . format ( format = demodulation_format )) self . command ( ':OMA:SMartSEtup:FORMat \" {format} \"' . format ( format = demodulation_format )) if polarization is not None : if not polarization in self . POLARIZATIONS : raise ValueError ( 'Invalid polarization: {pol!r} ' . format ( pol = polarization )) self . command ( ':OMA:SMartSEtup:POLarization \" {pol} \"' . format ( pol = polarization )) if pre_set_layout is not None : if not isinstance ( pre_set_layout , bool ): raise TypeError ( 'param pre_set_layout should be bool.' ) self . command ( ':OMA:SMartSEtup:PREsetLAyout {enable:d} ' . format ( enable = pre_set_layout )) if compensate_cd is not None : if not isinstance ( compensate_cd , bool ): raise TypeError ( 'param compensate_cd should be bool.' ) self . command ( ':OMA:SMartSEtup:COmpensateCD {:d} ' . format ( compensate_cd )) if compensate_pmd is not None : if not isinstance ( compensate_pmd , bool ): raise TypeError ( 'param sompensate_pmd should be bool.' ) self . command ( ':OMA:SMartSEtup:COmpensatePMD {:d} ' . format ( compensate_pmd )) if execute : self . command ( ':OMA:SMartSEtup:PERformProposedActions' )","title":"BaseModelVSA89600_OMA"},{"location":"api/models/#pyinst.models.BaseModelVSA89600_OMA.smart_setup","text":"Perform smart setup of the OMA. Use parameter execute to choose whether to execute the changed settings or not. If a setting parameter is not explicitly given (default as None), the old setting will be kept. Parameters: Name Type Description Default execute bool Whether to execute smart setup with the new settings. If set to False, the settings of smart setup will be changed, but the OMA will not execute smart setup. True frequency Optional [ int | float ] The carrier frequency in THz. None symbol_rate Optional [ int | float ] The symbol rate in GHz. None fine_tune_symbol_rate Optional [ bool ] Whether the system should try to fine tune the symbol rate. None demodulation_format Optional [ str ] The selected digital demodulation format. Refer to DEMOD_FORMATS for options. None polarization Optional [ str ] The expected polarization or if auto detection should be used. options: \"Single\" | \"Dual\" | \"Auto\" . None pre_set_layout Optional [ bool ] Whether a preset of the trace layout should be performed. None compensate_cd Optional [ bool ] A value indicating whether CD should be compensated. None compensate_pmd Optional [ bool ] A value indicating whether PMD should be compensated. None Source code in pyinst\\models.py 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 2250 2251 2252 2253 2254 2255 2256 2257 2258 2259 2260 2261 2262 2263 2264 2265 2266 2267 2268 2269 2270 2271 2272 2273 2274 2275 2276 2277 2278 2279 2280 2281 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 2293 def smart_setup ( self , execute : bool = True , frequency : Optional [ int | float ] = None , symbol_rate : Optional [ int | float ] = None , fine_tune_symbol_rate : Optional [ bool ] = None , demodulation_format : Optional [ str ] = None , polarization : Optional [ str ] = None , pre_set_layout : Optional [ bool ] = None , compensate_cd : Optional [ bool ] = None , compensate_pmd : Optional [ bool ] = None ): \"\"\"Perform smart setup of the OMA. Use parameter `execute` to choose whether to execute the changed settings or not. If a setting parameter is not explicitly given (default as None), the old setting will be kept. Args: execute: Whether to execute smart setup with the new settings. If set to False, the settings of smart setup will be changed, but the OMA will not execute smart setup. frequency: The carrier frequency in THz. symbol_rate: The symbol rate in GHz. fine_tune_symbol_rate: Whether the system should try to fine tune the symbol rate. demodulation_format: The selected digital demodulation format. Refer to `DEMOD_FORMATS` for options. polarization: The expected polarization or if auto detection should be used. options: `\"Single\"` | `\"Dual\"` | `\"Auto\"`. pre_set_layout: Whether a preset of the trace layout should be performed. compensate_cd: A value indicating whether CD should be compensated. compensate_pmd: A value indicating whether PMD should be compensated. \"\"\" if frequency is not None : self . command ( ':OMA:SMartSEtup:CarrierFrequency:FRErequency {value:d} ' . format ( value = round ( frequency * 10 ** 12 ))) if symbol_rate is not None : self . command ( ':OMA:SMartSEtup:SYMBRate {value:d} ' . format ( value = round ( symbol_rate * 10 ** 9 ))) if fine_tune_symbol_rate is not None : if not isinstance ( fine_tune_symbol_rate , bool ): raise TypeError ( 'param fine_tune_symbol_rate should be bool: {val} ' . format ( val = fine_tune_symbol_rate )) self . command ( ':OMA:SMartSEtup:FINetuneSymbolRate {enable:d} ' . format ( enable = fine_tune_symbol_rate )) if demodulation_format is not None : if demodulation_format not in self . DEMOD_FORMATS : raise ValueError ( 'Invalid modulation demodulation format: {format!r} ' . format ( format = demodulation_format )) self . command ( ':OMA:SMartSEtup:FORMat \" {format} \"' . format ( format = demodulation_format )) if polarization is not None : if not polarization in self . POLARIZATIONS : raise ValueError ( 'Invalid polarization: {pol!r} ' . format ( pol = polarization )) self . command ( ':OMA:SMartSEtup:POLarization \" {pol} \"' . format ( pol = polarization )) if pre_set_layout is not None : if not isinstance ( pre_set_layout , bool ): raise TypeError ( 'param pre_set_layout should be bool.' ) self . command ( ':OMA:SMartSEtup:PREsetLAyout {enable:d} ' . format ( enable = pre_set_layout )) if compensate_cd is not None : if not isinstance ( compensate_cd , bool ): raise TypeError ( 'param compensate_cd should be bool.' ) self . command ( ':OMA:SMartSEtup:COmpensateCD {:d} ' . format ( compensate_cd )) if compensate_pmd is not None : if not isinstance ( compensate_pmd , bool ): raise TypeError ( 'param sompensate_pmd should be bool.' ) self . command ( ':OMA:SMartSEtup:COmpensatePMD {:d} ' . format ( compensate_pmd )) if execute : self . command ( ':OMA:SMartSEtup:PERformProposedActions' )","title":"smart_setup()"},{"location":"api/models/#pyinst.models.Model81571A","text":"Bases: BaseModel815x_VOA Keysight 81571A variable optical attenuator. Source code in pyinst\\models.py 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 class Model81571A ( BaseModel815x_VOA ): \"\"\"Keysight 81571A variable optical attenuator.\"\"\" model = \"81571A\" brand = \"Keysight\" details = { \"Wavelength Range\" : \"1200 ~ 1700 nm\" , \"Att Range\" : \"0 ~ 60 dB\" , \"Max Safe Input Power\" : \"+33 dBm\" } params = [ { \"name\" : \"slot\" , \"type\" : \"int\" , \"options\" : [ 1 , 2 , 3 , 4 ] } ] def __init__ ( self , resource_name : str , slot : int , ** kwargs ): super () . __init__ ( resource_name , slot , channel = 1 , ** kwargs )","title":"Model81571A"},{"location":"api/models/#pyinst.models.Model81635A","text":"Bases: BaseModel816x_OPM Keysight 81635A optical power meter. Source code in pyinst\\models.py 1830 1831 1832 1833 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 class Model81635A ( BaseModel816x_OPM ): \"\"\"Keysight 81635A optical power meter.\"\"\" brand = \"Keysight\" model = \"81635A\" details = { \"Wavelength Range\" : \"800 ~ 1650 nm\" , \"Input Power Range\" : \"-80 ~ +10 dBm\" , \"Max Safe Input Power\" : \"+16 dBm\" , \"Averaging Time\" : \"100 us ~ 10 s\" , # TODO: verify averaging time } params = [ { \"name\" : \"slot\" , \"type\" : \"int\" , \"options\" : [ 1 , 2 , 3 , 4 ] }, { \"name\" : \"channel\" , \"type\" : \"int\" , \"options\" : [ 1 , 2 ] } ]","title":"Model81635A"},{"location":"api/models/#pyinst.models.ModelAQ2200_215","text":"Bases: BaseModelAQ2200_OPM Yokogawa AQ2200-215 optical power meter. Source code in pyinst\\models.py 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 class ModelAQ2200_215 ( BaseModelAQ2200_OPM ): \"\"\"Yokogawa AQ2200-215 optical power meter.\"\"\" model = \"AQ2200-215\" brand = \"Yokogawa\" details = { \"Wavelength Range\" : \"970 ~ 1660 nm\" , \"Input Power Range\" : \"-70 ~ +30 dBm\" , \"Averaging Time\" : \"100us ~ 10s\" , } params = [ { \"name\" : \"slot\" , \"type\" : \"int\" , \"min\" : 1 , \"max\" : 10 } ] def __init__ ( self , resource_name : str , slot : int , ** kwargs ) -> None : \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: slot number in the frame kwargs: directly passed to `VisaInstrument.__init__` \"\"\" super () . __init__ ( resource_name , slot , channel = 1 , ** kwargs )","title":"ModelAQ2200_215"},{"location":"api/models/#pyinst.models.ModelAQ2200_215.__init__","text":"Parameters: Name Type Description Default resource_name str Resource name or alias of the VISA resource to open. required slot int slot number in the frame required kwargs directly passed to VisaInstrument.__init__ required Source code in pyinst\\models.py 1423 1424 1425 1426 1427 1428 1429 1430 def __init__ ( self , resource_name : str , slot : int , ** kwargs ) -> None : \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: slot number in the frame kwargs: directly passed to `VisaInstrument.__init__` \"\"\" super () . __init__ ( resource_name , slot , channel = 1 , ** kwargs )","title":"__init__()"},{"location":"api/models/#pyinst.models.ModelAQ2200_221","text":"Bases: BaseModelAQ2200_OPM Yokogawa AQ2200-221 2-channel optical power meter. Source code in pyinst\\models.py 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 class ModelAQ2200_221 ( BaseModelAQ2200_OPM ): \"\"\"Yokogawa AQ2200-221 2-channel optical power meter.\"\"\" model = \"AQ2200-221\" brand = \"Yokogawa\" details = { \"Wavelength Range\" : \"800 ~ 1700 nm\" , \"Input Power Range\" : \"-70 ~ +10 dBm\" , \"Averaging Time\" : \"200us ~ 10s\" , } params = [ { \"name\" : \"slot\" , \"type\" : \"int\" , \"min\" : 1 , \"max\" : 10 }, { \"name\" : \"channel\" , \"type\" : \"int\" , \"options\" : [ 1 , 2 ] } ] @property def min_avg_time ( self ) -> float : return 0.2 @property def avg_time_table ( self ) -> tuple : return ( 0.2 , 0.5 , 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 , 500 , 1000 , 2000 , 5000 , 10000 , )","title":"ModelAQ2200_221"},{"location":"api/models/#pyinst.models.ModelAQ2200_311","text":"Bases: BaseModelAQ2200_VOA Yokogawa AQ2200-311 variable optical attenuator. Source code in pyinst\\models.py 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 class ModelAQ2200_311 ( BaseModelAQ2200_VOA ): \"\"\"Yokogawa AQ2200-311 variable optical attenuator.\"\"\" model = \"AQ2200-311\" brand = \"Yokogawa\" details = { \"Wavelength Range\" : \"1200 ~ 1700 nm\" , \"Max Att\" : \"60 dB\" , \"Max Safe Input Power\" : \"+23 dBm\" , \"Averaging Time\" : \"100 us ~ 10 s\" , } params = [ { \"name\" : \"slot\" , \"type\" : \"int\" , \"min\" : 1 , \"max\" : 10 } ] def __init__ ( self , resource_name , slot , ** kwargs ) -> None : \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: slot number in the frame kwargs: directly passed to `VisaInstrument.__init__` \"\"\" super () . __init__ ( resource_name , slot , channel = 1 , ** kwargs )","title":"ModelAQ2200_311"},{"location":"api/models/#pyinst.models.ModelAQ2200_311.__init__","text":"Parameters: Name Type Description Default resource_name Resource name or alias of the VISA resource to open. required slot slot number in the frame required kwargs directly passed to VisaInstrument.__init__ required Source code in pyinst\\models.py 1492 1493 1494 1495 1496 1497 1498 1499 def __init__ ( self , resource_name , slot , ** kwargs ) -> None : \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: slot number in the frame kwargs: directly passed to `VisaInstrument.__init__` \"\"\" super () . __init__ ( resource_name , slot , channel = 1 , ** kwargs )","title":"__init__()"},{"location":"api/models/#pyinst.models.ModelAQ2200_311A","text":"Bases: BaseModelAQ2200_VOA Yokogawa AQ2200-311A variable optical attenuator. Source code in pyinst\\models.py 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 class ModelAQ2200_311A ( BaseModelAQ2200_VOA ): \"\"\"Yokogawa AQ2200-311A variable optical attenuator.\"\"\" model = \"AQ2200-311A\" brand = \"Yokogawa\" details = { \"Wavelength Range\" : \"1200 ~ 1700 nm\" , \"Max Att\" : \"60 dB\" , \"Max Safe Input Power\" : \"+23 dBm\" , \"Averaging Time\" : \"100 us ~ 10 s\" , } params = [ { \"name\" : \"slot\" , \"type\" : \"int\" , \"min\" : 1 , \"max\" : 10 } ] def __init__ ( self , resource_name , slot , ** kwargs ) -> None : \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: slot number in the frame kwargs: directly passed to `VisaInstrument.__init__` \"\"\" super () . __init__ ( resource_name , slot , channel = 1 , ** kwargs )","title":"ModelAQ2200_311A"},{"location":"api/models/#pyinst.models.ModelAQ2200_311A.__init__","text":"Parameters: Name Type Description Default resource_name Resource name or alias of the VISA resource to open. required slot slot number in the frame required kwargs directly passed to VisaInstrument.__init__ required Source code in pyinst\\models.py 1522 1523 1524 1525 1526 1527 1528 1529 def __init__ ( self , resource_name , slot , ** kwargs ) -> None : \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: slot number in the frame kwargs: directly passed to `VisaInstrument.__init__` \"\"\" super () . __init__ ( resource_name , slot , channel = 1 , ** kwargs )","title":"__init__()"},{"location":"api/models/#pyinst.models.ModelAQ2200_331","text":"Bases: BaseModelAQ2200_VOA_with_OPM Yokogawa AQ2200-331 variable optical attenuator with built-in power meter. Source code in pyinst\\models.py 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 class ModelAQ2200_331 ( BaseModelAQ2200_VOA_with_OPM ): \"\"\"Yokogawa AQ2200-331 variable optical attenuator with built-in power meter.\"\"\" model = \"AQ2200-331\" brand = \"Yokogawa\" details = { \"Wavelength Range\" : \"1200 ~ 1700 nm\" , \"Max Att\" : \"60 dB\" , \"Max Safe Input Power\" : \"+23 dBm\" , \"Averaging Time\" : \"100 us ~ 10 s\" , } params = [ { \"name\" : \"slot\" , \"type\" : \"int\" , \"min\" : 1 , \"max\" : 10 } ] def __init__ ( self , resource_name , slot , ** kwargs ) -> None : \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: slot number in the frame kwargs: directly passed to `VisaInstrument.__init__` \"\"\" super () . __init__ ( resource_name , slot , channel = 1 , ** kwargs )","title":"ModelAQ2200_331"},{"location":"api/models/#pyinst.models.ModelAQ2200_331.__init__","text":"Parameters: Name Type Description Default resource_name Resource name or alias of the VISA resource to open. required slot slot number in the frame required kwargs directly passed to VisaInstrument.__init__ required Source code in pyinst\\models.py 1552 1553 1554 1555 1556 1557 1558 1559 def __init__ ( self , resource_name , slot , ** kwargs ) -> None : \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: slot number in the frame kwargs: directly passed to `VisaInstrument.__init__` \"\"\" super () . __init__ ( resource_name , slot , channel = 1 , ** kwargs )","title":"__init__()"},{"location":"api/models/#pyinst.models.ModelAQ2200_342","text":"Bases: BaseModelAQ2200_VOA_with_OPM Yokogawa AQ2200-342 variable optical attenuator with built-in power meter. Source code in pyinst\\models.py 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 class ModelAQ2200_342 ( BaseModelAQ2200_VOA_with_OPM ): \"\"\"Yokogawa AQ2200-342 variable optical attenuator with built-in power meter.\"\"\" model = \"AQ2200-342\" brand = \"Yokogawa\" details = { \"Wavelength Range\" : \"1260 ~ 1640 nm\" , \"Max Att\" : \"40 dB Min\" , \"Max Safe Input Power\" : \"+23 dBm\" , \"Averaging Time\" : \"100 us ~ 10 s\" , } params = [ { \"name\" : \"slot\" , \"type\" : \"int\" , \"min\" : 1 , \"max\" : 10 }, { \"name\" : \"channel\" , \"type\" : \"int\" , \"options\" : [ 1 , 2 ] } ]","title":"ModelAQ2200_342"},{"location":"api/models/#pyinst.models.ModelAQ6150","text":"Bases: VisaInstrument , TypeWM Source code in pyinst\\models.py 3458 3459 3460 3461 3462 3463 3464 3465 3466 3467 3468 3469 3470 3471 3472 3473 3474 3475 3476 3477 3478 3479 3480 3481 3482 3483 3484 3485 3486 3487 3488 3489 3490 3491 3492 3493 3494 3495 3496 3497 3498 3499 3500 3501 3502 3503 3504 3505 3506 3507 3508 3509 3510 3511 3512 3513 3514 3515 3516 3517 3518 3519 3520 3521 class ModelAQ6150 ( VisaInstrument , TypeWM ): model = [ \"AQ6150\" , \"AQ6151\" ] brand = \"Yokogawa\" details = { \"Wavelength Range\" : \"1270 ~ 1650 nm\" , \"Input Power Range\" : \"-30 ~ 10 dBm\" , \"Safe Max Input Power\" : \"+18 dBm\" } def __init__ ( self , resource_name , ** kwargs ): super ( ModelAQ6150 , self ) . __init__ ( resource_name , ** kwargs ) def run ( self , state : bool = True ) -> None : \"\"\" Executes (stops) repeat measurement. Args: state: `True` = Execute, `False` = Stop. \"\"\" if not isinstance ( state , bool ): raise TypeError ( 'Parameter state must be bool type.' ) cmd = ':INITiate:CONTinuous {state:d} ' . format ( state = state ) self . command ( cmd ) def stop ( self ): \"\"\" Stops repeat measurement. \"\"\" self . run ( False ) def is_running ( self ) -> bool : \"\"\" Queries the repeat measurement state. Returns: `True` = Execute, `False` = Stop. \"\"\" cmd = ':INITiate:CONTinuous?' state = bool ( int ( self . query ( cmd ))) return state def get_frequency ( self ) -> float : \"\"\"Queries the peak frequency in single view mode for single measurement. Returns: The peak frequency in THz. \"\"\" cmd = \":MEASure:POWer:FREQuency?\" freq = float ( self . query ( cmd )) / 10 ** 12 if freq == 0 : raise ValueError ( 'No optical input signal.' ) return freq def get_wavelength ( self ): \"\"\"Queries the peak wavelength in single view mode for single measurement. Returns: The peak wavelength in nm. \"\"\" cmd = \":MEASure:POWer:WAVelength?\" wl = float ( self . query ( cmd )) * 10 ** 9 if wl == 0 : raise ValueError ( 'No optical input signal.' ) return wl","title":"ModelAQ6150"},{"location":"api/models/#pyinst.models.ModelAQ6150.get_frequency","text":"Queries the peak frequency in single view mode for single measurement. Returns: Type Description float The peak frequency in THz. Source code in pyinst\\models.py 3499 3500 3501 3502 3503 3504 3505 3506 3507 3508 3509 def get_frequency ( self ) -> float : \"\"\"Queries the peak frequency in single view mode for single measurement. Returns: The peak frequency in THz. \"\"\" cmd = \":MEASure:POWer:FREQuency?\" freq = float ( self . query ( cmd )) / 10 ** 12 if freq == 0 : raise ValueError ( 'No optical input signal.' ) return freq","title":"get_frequency()"},{"location":"api/models/#pyinst.models.ModelAQ6150.get_wavelength","text":"Queries the peak wavelength in single view mode for single measurement. Returns: Type Description The peak wavelength in nm. Source code in pyinst\\models.py 3511 3512 3513 3514 3515 3516 3517 3518 3519 3520 3521 def get_wavelength ( self ): \"\"\"Queries the peak wavelength in single view mode for single measurement. Returns: The peak wavelength in nm. \"\"\" cmd = \":MEASure:POWer:WAVelength?\" wl = float ( self . query ( cmd )) * 10 ** 9 if wl == 0 : raise ValueError ( 'No optical input signal.' ) return wl","title":"get_wavelength()"},{"location":"api/models/#pyinst.models.ModelAQ6150.is_running","text":"Queries the repeat measurement state. Returns: Type Description bool True = Execute, False = Stop. Source code in pyinst\\models.py 3488 3489 3490 3491 3492 3493 3494 3495 3496 3497 def is_running ( self ) -> bool : \"\"\" Queries the repeat measurement state. Returns: `True` = Execute, `False` = Stop. \"\"\" cmd = ':INITiate:CONTinuous?' state = bool ( int ( self . query ( cmd ))) return state","title":"is_running()"},{"location":"api/models/#pyinst.models.ModelAQ6150.run","text":"Executes (stops) repeat measurement. Parameters: Name Type Description Default state bool True = Execute, False = Stop. True Source code in pyinst\\models.py 3470 3471 3472 3473 3474 3475 3476 3477 3478 3479 3480 def run ( self , state : bool = True ) -> None : \"\"\" Executes (stops) repeat measurement. Args: state: `True` = Execute, `False` = Stop. \"\"\" if not isinstance ( state , bool ): raise TypeError ( 'Parameter state must be bool type.' ) cmd = ':INITiate:CONTinuous {state:d} ' . format ( state = state ) self . command ( cmd )","title":"run()"},{"location":"api/models/#pyinst.models.ModelAQ6150.stop","text":"Stops repeat measurement. Source code in pyinst\\models.py 3482 3483 3484 3485 3486 def stop ( self ): \"\"\" Stops repeat measurement. \"\"\" self . run ( False )","title":"stop()"},{"location":"api/models/#pyinst.models.ModelAQ6370","text":"Bases: VisaInstrument , TypeOSA OSA Source code in pyinst\\models.py 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 2447 2448 2449 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 2460 2461 2462 2463 2464 2465 2466 2467 2468 2469 2470 2471 2472 2473 2474 2475 2476 2477 2478 2479 2480 2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 2495 2496 2497 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 2511 2512 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 2534 2535 2536 2537 2538 2539 2540 2541 2542 2543 2544 2545 2546 2547 2548 2549 2550 2551 2552 2553 2554 2555 2556 2557 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 2578 2579 2580 2581 2582 2583 2584 2585 2586 2587 2588 2589 2590 2591 2592 2593 2594 2595 2596 2597 2598 2599 2600 2601 2602 2603 2604 2605 2606 2607 2608 2609 2610 2611 2612 2613 2614 2615 2616 2617 2618 2619 2620 2621 2622 2623 2624 2625 2626 2627 2628 2629 2630 2631 2632 2633 2634 2635 2636 2637 2638 2639 2640 2641 2642 2643 2644 2645 2646 2647 2648 2649 2650 2651 2652 2653 2654 2655 2656 2657 2658 2659 2660 2661 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 2674 2675 2676 2677 2678 2679 2680 2681 2682 2683 2684 2685 2686 2687 2688 2689 2690 2691 2692 2693 2694 2695 2696 2697 2698 2699 2700 2701 2702 2703 2704 2705 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 2718 2719 2720 2721 2722 2723 2724 2725 2726 2727 2728 2729 2730 2731 2732 2733 2734 2735 2736 2737 2738 2739 2740 2741 2742 2743 2744 2745 2746 2747 2748 2749 2750 2751 2752 2753 2754 2755 2756 2757 2758 2759 2760 2761 2762 2763 2764 2765 2766 2767 2768 2769 2770 2771 2772 2773 2774 2775 2776 2777 2778 2779 2780 2781 2782 2783 2784 2785 2786 2787 2788 2789 2790 2791 2792 2793 2794 2795 2796 2797 2798 2799 2800 2801 2802 2803 2804 2805 2806 2807 2808 2809 2810 2811 2812 2813 2814 2815 2816 2817 2818 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 2829 2830 2831 2832 2833 2834 2835 2836 2837 2838 2839 2840 2841 2842 2843 2844 2845 2846 2847 2848 2849 2850 2851 2852 2853 2854 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 2866 2867 2868 2869 2870 2871 2872 2873 2874 2875 2876 2877 2878 2879 2880 2881 2882 2883 2884 2885 2886 2887 2888 2889 2890 2891 2892 2893 2894 2895 2896 2897 2898 2899 2900 2901 2902 2903 2904 2905 2906 2907 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 2919 2920 2921 2922 2923 2924 2925 2926 2927 2928 2929 2930 2931 2932 2933 2934 2935 2936 2937 2938 2939 2940 2941 2942 2943 2944 2945 2946 2947 2948 2949 2950 2951 2952 2953 2954 2955 2956 2957 2958 2959 2960 2961 2962 2963 2964 2965 2966 2967 2968 2969 2970 2971 2972 2973 2974 2975 2976 2977 2978 2979 2980 2981 2982 2983 2984 2985 2986 2987 2988 2989 2990 2991 2992 2993 2994 2995 2996 2997 2998 2999 3000 3001 3002 3003 3004 3005 3006 3007 3008 3009 3010 3011 3012 3013 3014 3015 3016 3017 3018 3019 3020 3021 3022 3023 3024 3025 3026 3027 3028 3029 3030 3031 3032 3033 3034 3035 3036 3037 3038 3039 3040 3041 3042 3043 3044 3045 3046 3047 3048 3049 3050 3051 3052 3053 3054 3055 3056 3057 3058 3059 3060 3061 3062 3063 3064 3065 3066 3067 3068 3069 3070 3071 3072 3073 3074 3075 3076 3077 3078 3079 3080 3081 3082 3083 3084 3085 3086 3087 3088 3089 3090 3091 3092 3093 3094 3095 3096 3097 3098 3099 3100 3101 3102 3103 3104 3105 3106 3107 3108 3109 3110 3111 3112 3113 3114 3115 3116 3117 3118 3119 3120 3121 3122 3123 3124 3125 3126 3127 3128 3129 3130 3131 3132 3133 3134 3135 3136 3137 3138 3139 3140 3141 3142 3143 3144 3145 3146 3147 3148 3149 3150 3151 3152 3153 3154 3155 3156 3157 3158 3159 3160 3161 3162 3163 3164 3165 3166 3167 3168 3169 3170 3171 3172 3173 3174 3175 3176 3177 3178 3179 3180 3181 3182 3183 3184 3185 3186 3187 3188 3189 3190 3191 3192 3193 3194 3195 3196 3197 3198 3199 3200 3201 3202 3203 3204 3205 3206 3207 3208 3209 3210 3211 3212 3213 3214 3215 3216 3217 3218 3219 3220 3221 3222 3223 3224 3225 3226 3227 3228 3229 3230 3231 3232 3233 3234 3235 3236 3237 3238 3239 3240 3241 3242 3243 3244 3245 3246 3247 3248 3249 3250 3251 3252 3253 3254 3255 3256 3257 3258 3259 3260 3261 3262 3263 3264 3265 3266 3267 3268 3269 3270 3271 3272 3273 3274 3275 3276 3277 3278 3279 3280 3281 3282 3283 3284 3285 3286 3287 3288 3289 3290 3291 3292 3293 3294 3295 3296 3297 3298 3299 3300 3301 3302 3303 3304 3305 3306 3307 3308 3309 3310 3311 3312 3313 3314 3315 3316 3317 3318 3319 3320 3321 3322 3323 3324 3325 3326 3327 3328 3329 3330 3331 3332 3333 3334 3335 3336 3337 3338 3339 3340 3341 3342 3343 3344 3345 3346 3347 3348 3349 3350 3351 3352 3353 3354 3355 3356 3357 3358 3359 3360 3361 3362 3363 3364 3365 3366 3367 3368 3369 3370 3371 3372 3373 3374 3375 3376 3377 3378 3379 3380 3381 3382 3383 3384 3385 3386 3387 3388 3389 3390 3391 3392 3393 3394 3395 3396 3397 3398 3399 3400 3401 3402 3403 3404 3405 3406 3407 3408 3409 3410 3411 3412 3413 3414 3415 3416 3417 3418 3419 3420 3421 3422 3423 3424 3425 3426 3427 3428 3429 3430 3431 3432 3433 3434 3435 3436 3437 3438 3439 3440 3441 3442 3443 3444 3445 3446 3447 3448 3449 3450 3451 3452 3453 3454 class ModelAQ6370 ( VisaInstrument , TypeOSA ): \"\"\" OSA \"\"\" model = \"AQ6370\" brand = \"Yokogawa\" details = { \"Wavelength Range\" : \"600 ~ 1700 nm\" , \"Max. Resolution\" : \"0.02 nm\" } def __init__ ( self , resource_name , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. kwargs: directly passed to `VisaInstrument.__init__`. \"\"\" super ( ModelAQ6370 , self ) . __init__ ( resource_name , ** kwargs ) self . __analysis_cat = [ \"SWTHRESH\" , \"DFBLD\" , \"SMSR\" , \"OSNR\" , \"WDM\" , ] self . command ( ':FORMat:DATA ASCii' ) # set data format to ascii @property def ANALYSIS_CATEGORIES ( self ): return self . __analysis_cat @property def MARKER_NUMBERS ( self ): return ( 1 , 2 , 3 , 4 ) @property def WL_UNITS ( self ): return ( \"NM\" , \"THZ\" ) @property def WL_SPAN_UNITS ( self ): return ( \"NM\" , \"GHZ\" ) def get_x_unit ( self ) -> str : \"\"\"Queries the units for the X axis. Returns: `\"WAV\"` = Wavelength, `\"FREQ\"` = Frequency \"\"\" cmd = \":UNIT:X?\" options = [ \"WAV\" , \"FREQ\" ] unit = options [ int ( self . query ( cmd ))] return unit def set_x_unit ( self , unit : str ): \"\"\"Sets the units for the X axis. Args: unit: `\"WAV\"` | `\"FREQ\"`. `\"WAV\"` = Wavelength, `\"FREQ\"` = Frequency \"\"\" cmd = \":UNIT:X {unit} \" . format ( unit ) self . command ( cmd ) def sweep ( self , mode : str = \"REPEAT\" ) -> None : \"\"\"Sets the sweep mode and makes a sweep. For information about the sweep modes, please refer to documentation of the instrument. Args: mode: Sweep mode. `\"AUTO\"` | `\"REPEAT\"` | `\"SINGLE\"` | `\"STOP\"`. \"\"\" options = [ \"AUTO\" , \"REPEAT\" , \"SINGLE\" , \"STOP\" ] if mode not in options : raise ValueError ( \"Invalid value for param mode: {value} \" . format ( value = mode )) if mode == \"STOP\" : self . command ( ':ABOR' ) else : self . command ( ':INIT:SMOD {mode} ;:INIT' . format ( mode = mode )) def run ( self ) -> None : \"\"\"Makes a REPEAT sweep. Refer to `sweep` for more information.\"\"\" self . command ( ':INIT:SMOD REPEAT;:INIT' ) def stop ( self ) -> None : \"\"\"Stops sweep.\"\"\" self . command ( ':ABOR' ) def single ( self ) -> None : \"\"\"Makes a SINGLE sweep. Refer to `sweep` for more information.\"\"\" self . command ( ':INIT:SMOD SINGLE;:INIT' ) def set_auto_zero ( self , status : bool ) -> None : \"\"\"Sets whether to enable the auto offset function of the level.\"\"\" if not isinstance ( status , bool ): raise TypeError ( 'param status should be bool' ) cmd = \":CALibration:ZERO {status:d} \" . format ( status = status ) self . command ( cmd ) def get_auto_zero ( self ) -> bool : \"\"\"Queries whether to enable the auto offset function of the level.\"\"\" cmd = \":CALibration:ZERO?\" status = bool ( int ( self . query ( cmd ))) return status def zero_once ( self ): \"\"\"Perform offset adjustment once and wait until adjustment complete. TODO: should stopped?\"\"\" self . command ( \":CALibration:ZERO ONCE\" ) while True : being_executed = int ( self . query ( \":CALibration:ZERO:STATus?\" )) if not being_executed : break def set_auto_analysis ( self , enable ): \"\"\"Sets the automatic analysis function.\"\"\" if not isinstance ( enable , bool ): raise TypeError ( \"param enable should be bool.\" ) cmd = \":CALCulate:AUTO {enable:d} \" . format ( enable = enable ) self . command ( cmd ) def get_auto_analysis ( self ): \"\"\"Queries the automatic analysis function.\"\"\" cmd = \":CALCulate:AUTO?\" enabled = bool ( int ( self . query ( cmd ))) return enabled def set_analysis_category ( self , category : str ): \"\"\"Sets the type of analysis. Args: category: The type of analysis. Options: - `SWTHRESH`: Spectrum width analysis (THRESH) - `DFBLD`: DFB-LD parameter analysis - `SMSR`: SMSR analysis - `OSNR`|`WDM`: OSNR(WDM), WDM analysis \"\"\" if category not in self . ANALYSIS_CATEGORIES : raise ValueError ( 'Invalid option of category: %r ' % category ) cmd = \":CALCulate:CATegory {cat} \" . format ( cat = category ) self . command ( cmd ) def get_analysis_category ( self ) -> str : \"\"\"Queries the type of analysis. Returns: The type of analysis. `SWTHRESH`|`DFBLD`|`SMSR`|`WDM`. Please refer to `set_analysis_category` for detail. \"\"\" cat_dict = { 0 : \"SWTHRESH\" , 5 : \"DFBLD\" , 8 : \"SMSR\" , 11 : \"WDM\" } cmd = \":CALCulate:CATegory?\" cat = cat_dict [ int ( self . query ( cmd ))] return cat def set_wdm_analysis_threshold ( self , threshold : int | float ) -> None : \"\"\" Set the threshold level of channel detection for the WDM analysis function. Args: threshold: The threshold level value in dB. \"\"\" cmd = \":CALCulate:PARameter:WDM:TH {th:.2f} DB\" . format ( th = threshold ) self . command ( cmd ) def get_wdm_analysis_threshold ( self ) -> float : \"\"\" Queries the threshold level of channel detection for the WDM analysis function. Returns: The threshold level value in dB. \"\"\" cmd = \":CALCulate:PARameter:WDM:TH?\" th = float ( self . query ( cmd )) return th def set_wdm_analysis_mdiff ( self , mdiff : int | float ) -> None : \"\"\" Sets the peak bottom difference of channel detection for the WDM analysis function. Args: mdiff: The peak-bottom difference in dB. \"\"\" cmd = \":CALCulate:PARameter:WDM:MDIFf {mdiff:.2f} DB\" . format ( mdiff = mdiff ) self . command ( cmd ) def get_wdm_analysis_mdiff ( self ) -> float : \"\"\" Queries the peak bottom difference of channel detection for the WDM analysis function. Returns: The peak-bottom difference in dB. \"\"\" cmd = \":CALCulate:PARameter:WDM:MDIFf?\" mdiff = float ( self . query ( cmd )) return mdiff def set_wdm_analysis_dmask ( self , dmask : int | float ) -> None : \"\"\" Sets the channel mask threshold level for the WDM analysis function. Args: dmask: The channel mask threshold level in dB. \"\"\" cmd = \":CALCulate:PARameter:WDM:DMASk {dmask:.2f} DB\" . format ( dmask = dmask ) self . command ( cmd ) def get_wdm_analysis_dmask ( self ) -> float : \"\"\" Queries the channel mask threshold level for the WDM analysis function. Returns: The channel mask threshold level in dB. \"\"\" cmd = \":CALCulate:PARameter:WDM:DMASk?\" dmask = float ( self . query ( cmd )) return dmask def set_wdm_analysis_nalgo ( self , algo : str ) -> None : \"\"\" Sets the measurement algorithm applied to noise level measurements made by the WDM analysis function. Options of algorithms: - `AFIX` = AUTO FIX - `MFIX` = MANUAL FIX - `ACEN` = AUTO CENTER - `MCEN` = MANUAL CENTER - `PIT` = PIT Args: algo: The name of algorithm. Refer to options above. \"\"\" algo_options = [ \"AFIX\" , \"MFIX\" , \"ACEN\" , \"MCEN\" , \"PIT\" ] if algo . upper () not in algo_options : raise ValueError ( \"Invalid value for algo: {value!r} \" . format ( value = algo )) cmd = \":CALCulate:PARameter:WDM:NALGo {algo} \" . format ( algo = algo ) self . command ( cmd ) def get_wdm_analysis_nalgo ( self ) -> str : \"\"\" Queries the measurement algorithm applied to noise level measurements made by the WDM analysis function. Options of algorithms: - `AFIX` = AUTO FIX - `MFIX` = MANUAL FIX - `ACEN` = AUTO CENTER - `MCEN` = MANUAL CENTER - `PIT` = PIT Returns: The name of algorithm. Refer to options above. \"\"\" algo_options = [ \"AFIX\" , \"MFIX\" , \"ACEN\" , \"MCEN\" , \"PIT\" ] cmd = \":CALCulate:PARameter:WDM:NALGo?\" algo = algo_options [ int ( self . query ( cmd ))] return algo def set_wdm_analysis_narea ( self , narea : int | float ) -> None : \"\"\"Sets the measuring range applied to noise level measurements made by the WDM analysis function. Args: narea: The range in nm. \"\"\" cmd = \":CALCulate:PARameter:WDM:NARea {narea:.2f} NM\" . format ( narea = narea ) self . command ( cmd ) def get_wdm_analysis_narea ( self ) -> float : \"\"\"Quereis the measuring range applied to noise level measurements made by the WDM analysis function. Returns: The range in nm. \"\"\" cmd = \":CALCulate:PARameter:WDM:NARea?\" narea = float ( self . query ( cmd )) * 10 ** 9 return narea def set_wdm_analysis_marea ( self , marea : int | float ) -> None : \"\"\"Sets the mask range during level measurement applied to noise level measurements made by the WDM analysis function. Args: marea: The mask range in nm. \"\"\" cmd = \":CALCulate:PARameter:WDM:MARea {marea:.2f} NM\" . format ( marea = marea ) self . command ( cmd ) def get_wdm_analysis_marea ( self ) -> float : \"\"\"Queries the mask range during level measurement applied to noise level measurements made by the WDM analysis function. Returns: The mask range in nm. \"\"\" cmd = \":CALCulate:PARameter:WDM:MARea?\" marea = float ( self . query ( cmd )) * 10 ** 9 return marea def set_wdm_analysis_falgo ( self , algo : str ) -> None : \"\"\"Sets the fitting function during level measurement applied to noise level measurements made by the WDM analysis function. Options of algorithms: - `LIN` = LINEAR - `GAUS` = GAUSS - `LOR` = LORENZ - `3RD` = 3RD POLY - `4TH` = 4YH POLY - `5TH` = 5TH POLY Args: algo: The name of the algorithm. Refer to options above. \"\"\" algo_options = [ \"LIN\" , \"GAUS\" , \"LOR\" , \"3RD\" , \"4TH\" , \"5TH\" ] if algo . upper () not in algo_options : raise ValueError ( \"Invalid value for algo: {value!r} \" . format ( value = algo )) cmd = \":CALCulate:PARameter:WDM:FALGo {algo} \" . format ( algo = algo ) self . command ( cmd ) def get_wdm_analysis_falgo ( self ) -> str : \"\"\"Queries the fitting function during level measurement applied to noise level measurements made by the WDM analysis function. Options of algorithms: - `LIN` = LINEAR - `GAUS` = GAUSS - `LOR` = LORENZ - `3RD` = 3RD POLY - `4TH` = 4YH POLY - `5TH` = 5TH POLY Returns: The name of the algorithm. Refer to options above. \"\"\" algo_options = [ \"LIN\" , \"GAUS\" , \"LOR\" , \"3RD\" , \"4TH\" , \"5TH\" ] cmd = \":CALCulate:PARameter:WDM:FALGo?\" algo = algo_options [ int ( self . query ( cmd ))] return algo def set_wdm_analysis_parameter_nbw ( self , nbw : int | float ) -> None : \"\"\"Sets the noise bandwidth for the WDM analysis function. Args: nbw: The noise bandwidth in nm. \"\"\" cmd = \":CALCulate:PARameter:WDM:NBW {nbw:.2f} NM\" . format ( nbw = nbw ) self . command ( cmd ) def get_wdm_analysis_parameter_nbw ( self ) -> float : \"\"\"Queries the noise bandwidth for the WDM analysis function. Returns: The noise bandwidth in nm. \"\"\" cmd = \":CALCulate:PARameter:WDM:NBW?\" nbw = float ( self . query ( cmd )) * 10 ** 9 return nbw def set_smsr_analysis_mask ( self , mask : int | float ) -> None : \"\"\"Set the mask value for the SMSR analysis function. Args: mask: The mask value in nm. \"\"\" cmd = \":CALCulate:PARameter:SMSR:MASK {mask:.2f} NM\" . format ( mask = mask ) self . command ( cmd ) def get_smsr_analysis_mask ( self , mask : int | float ) -> None : \"\"\"Quereis the mask value for the SMSR analysis function. Returns: The mask value in nm. \"\"\" cmd = \":CALCulate:PARameter:SMSR:MASK?\" mask = float ( self . query ( cmd )) * 10 ** 9 return mask def set_smsr_analysis_mode ( self , mode : str ) -> None : \"\"\"Sets the analysis mode for the SMSR analysis function. Args: mode: The analysis mode, `SMSR1`|`SMSR2`|`SMSR3`|`SMSR4`. \"\"\" options = [ \"SMSR1\" , \"SMSR2\" , \"SMSR3\" , \"SMSR4\" ] if mode not in options : raise ValueError ( \"Invalid option for mode: {mode!r} \" . format ( mode = mode )) cmd = \":CALCulate:PARameter:SMSR:MODE {mode} \" . format ( mode = mode ) self . command ( cmd ) def get_smsr_analysis_mode ( self ) -> str : \"\"\"Sets the analysis mode for the SMSR analysis function. Returns: The analysis mode, `SMSR1`|`SMSR2`|`SMSR3`|`SMSR4`. \"\"\" cmd = \":CALCulate:PARameter:SMSR:MODE?\" mode = self . query ( cmd ) . strip () return mode def set_dfbld_analysis_parameter ( self , item : str , parameter : str , data : str ) -> None : \"\"\"Sets parameters for the DFB-LD analysis function. For more information, please refer to the documents provided by instument vendor. Args: item: Analytical item that sets parameter(s). parameter: Parameter to be set. data: Setting data. |`<item>`|`<parameter>`|`<data>`| |--------|-------------|--------| |SWIDth |ALGO |`ENVelope|THResh|RMS|PKRMs`| | |TH |`<NRf>[DB]`| | |TH2 |`<NRf>[DB]`| | |K |`<NRf>`| | |MFIT |`OFF|ON|0|1`| | |MDIFf |`<NRf>[DB]`| |SMSR |SMODe |`SMSR1|SMSR2|SMSR3|SMSR4`| | |SMASk |`<NRf>[M]`| | |MDIFf |`<NRf>[DB]`| |RMS |ALGO |`RMS|PKRMs`| | |TH |`<NRf>[DB]`| | |K |`<NRf>`| | |MDIFf |`<NRf>[DB]`| |POWer |SPAN |`<NRf>[M]`| |OSNR |MDIFf |`<NRf>[DB]`| | |NALGo |`AFIX|MFIX|ACENter|MCENter|PIT|0|1|2|3|4`| | |NARea |`<NRf>[M]`| | |MARea |`<NRf>[M]`| | |FALGo |`LINear|GAUSs|LORenz|3RD|4TH|5TH|0|1|2|3|4|5`| | |NBW |`<NRf>[M]`| | |SPOWer |`PEAK|INTegral|0|1`| | |IRANge |`<NRf>`| \"\"\" cmd = \":CALCulate:PARameter:DFBLd {item} , {paramater} , {data} \" . format ( item = item , parameter = parameter , data = data ) self . command ( cmd ) def get_dfbld_analysis_parameter ( self , item : str , parameter : str ) -> str : \"\"\"Sets parameters for the DFB-LD analysis function. For more information, please refer to the documents provided by instument vendor. Args: item: Analytical item that sets parameter(s). parameter: Parameter to be set. Returns: A string of the value of parameter. Please refer to `set_dfbld_analysis_parameter` for detail. \"\"\" cmd = \":CALCulate:PARameter:DFBLd? {item} , {paramater} \" . format ( item = item , parameter = parameter ) return self . query ( cmd ) def set_swthresh_analysis_k ( self , k : int | float ) -> None : \"\"\"Sets the magnification of the THRESH method-based spectrum width analysis function. Args: k: The magnification. \"\"\" cmd = \":CALCulate:PARameter:SWTHResh:K {k:.2f} \" . format ( k = k ) self . command ( cmd ) def get_swthresh_analysis_k ( self ) -> float : \"\"\"Sets the magnification of the THRESH method-based spectrum width analysis function. Returns: The magnification. \"\"\" cmd = \":CALCulate:PARameter:SWTHResh:K?\" k = float ( self . query ( cmd )) return k def set_swthresh_analysis_mfit ( self , en : bool ) -> None : \"\"\"Sets whether to enable the mode fit of the THRESH method-based spectrum width analysis function. Args: en: Whether to enable the mode fit. \"\"\" if not isinstance ( en , bool ): raise TypeError ( \"Param en should be bool.\" ) cmd = \":CALCulate:PARameter:SWTHresh:MFIT {en:d} \" . format ( en = en ) self . command ( cmd ) def get_swthresh_analysis_mfit ( self ) -> bool : \"\"\"Queries whether to enable the mode fit of the THRESH method-based spectrum width analysis function. Returns: Whether to enable the mode fit. \"\"\" cmd = \":CALCulate:PARameter:SWTHresh:MFIT?\" en = bool ( int ( self . query ( cmd ))) return en def set_swthresh_analysis_th ( self , th : int | float ) -> None : \"\"\"Sets the threshold level of the THRESH method-based spectrum width analysis function. Args: th: The threshold level in dB. \"\"\" cmd = \":CALCulate:PARameter:SWTHresh:TH {th:.2f} DB\" . format ( th = th ) self . command ( cmd ) def get_swthresh_analysis_th ( self ) -> float : \"\"\"Queries the threshold level of the THRESH method-based spectrum width analysis function. Returns: The threshold level in dB. \"\"\" cmd = \":CALCulate:PARameter:SWTHresh:TH?\" th = float ( self . query ( cmd )) return th def get_analysis_data ( self ) -> str : \"\"\"Queries the analysis results from the last time analysis was executed. For the output formats of analysis results, please refer to documents from the instrument vendor. \"\"\" return self . query ( ':CALC:DATA?' ) def set_center ( self , value : int | float , unit : str ) -> None : \"\"\"Sets the measurement condition center wavelength/frequency. Args: value: The center frequency in THz or wavelength in nm. unit: `\"NM\"` or `\"THZ\"`. \"\"\" if unit . upper () not in self . WL_UNITS : raise ValueError ( 'Invalid option for unit: {unit!r} .' . format ( unit = unit )) cmd = \":SENSe:WAVelength:CENTer {value:.4f}{unit} \" . format ( value = value , unit = unit ) self . command ( cmd ) def set_wavelength ( self , wavelength : int | float ) -> None : self . set_center ( wavelength , 'NM' ) def set_frequency ( self , frequency : int | float ) -> None : return self . set_center ( frequency , 'THZ' ) def get_center ( self ) -> float : \"\"\" Queries the measurement condition center wavelength/frequency. Returns: The value of center frequency/wavelength value. If x unit is \"WAV\", returns the center wavelength in nm. If x unit is \"FREQ\", returns the center frequency in THz. Please refer to `get_x_unit` for more information. \"\"\" cmd = \":SENSe:WAVelength:CENTer?\" if \"WAV\" == self . get_x_unit (): center = float ( self . query ( cmd )) * 10 ** 9 else : center = float ( self . query ( cmd )) / 10 ** 12 return center def get_wavelength ( self ) -> float : if \"WAV\" == self . get_x_unit (): cmd = \":SENSe:WAVelength:CENTer?\" wl = float ( self . query ( cmd )) * 10 ** 9 else : wl = super () . get_wavelength () return wl def get_frequency ( self ) -> float : if \"FREQ\" == self . get_x_unit (): cmd = \":SENSe:WAVelength:CENTer?\" freq = float ( self . query ( cmd )) / 10 ** 12 else : freq = super () . get_frequency () return freq def set_span ( self , value : int | float , unit : str ) -> None : \"\"\"Sets the measurement condition measurement span. Args: value: The value of measurement span. unit: `\"NM\"` or `\"GHZ\"`. \"\"\" if unit not in self . WL_SPAN_UNITS : raise ValueError ( \"Invalid option for unit: {unit!r} \" . format ( unit = unit )) cmd = \":SENSe:WAVelengthSPAN {value:.2f}{unit} \" . format ( value = value , unit = unit ) return self . command ( cmd ) def get_span ( self ) -> float : \"\"\"Queries the measurement condition measurement span and unit. Returns: The value of measurement span value. If x unit is \"WAV\", returns the span in nm. If x unit is \"FREQ\", returns the span in GHz. Please refer to `get_x_unit` for more information. \"\"\" cmd = \":SENSe:WAVelengthSPAN?\" if \"WAV\" == self . get_x_unit (): span = float ( self . query ( cmd )) * 10 ** 9 else : span = float ( self . query ( cmd )) / 10 ** 9 return span def get_start_wavelength ( self ) -> float : \"\"\"Queries the measurement condition measurement start wavelength in nm. Returns: The start wavelength in nm. \"\"\" cmd = \":SENSe:WAVelength:STARt?\" if \"WAV\" == self . get_x_unit (): wl = float ( self . query ( cmd )) * 10 ** 9 else : wl = LIGHTSPEED / ( float ( self . query ( cmd )) / 10 ** 12 ) return wl def set_start_wavelength ( self , wavelength : int | float ) -> None : \"\"\"Sets the measurement condition measurement start wavelength in nm. Args: wavelength: The start wavelength in nm. \"\"\" if \"WAV\" == self . get_x_unit (): cmd = \":SENSe:WAVelength:STARt {wl:.6f} NM\" . format ( wl = wavelength ) self . command ( cmd ) else : self . set_stop_frequency ( LIGHTSPEED / wavelength ) def get_stop_wavelength ( self ) -> float : \"\"\"Queries the measurement condition measurement stop wavelength in nm. Returns: The stop wavelength in nm. \"\"\" cmd = \":SENSe:WAVelength:STOP?\" if \"WAV\" == self . get_x_unit (): wl = float ( self . query ( cmd )) * 10 ** 9 else : wl = LIGHTSPEED / ( float ( self . query ( cmd )) / 10 ** 12 ) return wl def set_stop_wavelength ( self , wavelength : int | float ) -> None : \"\"\"Sets the measurement condition measurement stop wavelength in nm. Args: wavelength: The stop wavelength in nm. \"\"\" if \"WAV\" == self . get_x_unit (): cmd = \":SENSe:WAVelength:STOP {wl:.6f} NM\" . format ( wl = wavelength ) self . command ( cmd ) else : self . set_start_frequency ( LIGHTSPEED / wavelength ) def get_start_frequency ( self ) -> float : \"\"\"Queries the measurement condition measurement start frequency in THz. Returns: The start frequency in THz. \"\"\" cmd = \":SENSe:WAVelength:STOP?\" if \"FREQ\" == self . get_x_unit (): f = float ( self . query ( cmd )) / 10 ** 12 else : f = LIGHTSPEED / ( float ( self . query ( cmd )) * 10 ** 9 ) return f def set_start_frequency ( self , frequency : int | float ) -> None : \"\"\"Queries the measurement condition measurement start frequency in THz. Args: frequency: The start frequency in THz. \"\"\" if \"FREQ\" == self . get_x_unit (): cmd = \":SENSe:WAVelength:STOP {freq:.6f} THZ\" . format ( freq = frequency ) self . command ( cmd ) else : self . set_stop_wavelength ( LIGHTSPEED / frequency ) def get_stop_frequency ( self ) -> float : \"\"\"Queries the measurement condition measurement stop frequency in THz. Returns: The stop frequency in THz. \"\"\" cmd = \":SENSe:WAVelength:STARt?\" if \"FREQ\" == self . get_x_unit (): f = float ( self . query ( cmd )) / 10 ** 12 else : f = LIGHTSPEED / ( float ( self . query ( cmd )) * 10 ** 9 ) return f def set_stop_frequency ( self , frequency : int | float ) -> None : \"\"\"Queries the measurement condition measurement stop frequency in THz. Args: frequency: The stop frequency in THz. \"\"\" if \"FREQ\" == self . get_x_unit (): cmd = \":SENSe:WAVelength:STARt {freq:.6f} THZ\" . format ( freq = frequency ) self . command ( cmd ) else : self . set_start_wavelength ( LIGHTSPEED / frequency ) def set_marker_active_state ( self , marker : int , state : bool ) -> None : \"\"\"Set the active state of a specified marker. A marker should be set into active state before further operations. Args: marker: Marker number. `1` | `2` | `3` | `4`. state: `True` = active, `False` = inactive. \"\"\" if marker not in self . MARKER_NUMBERS : raise ValueError ( \"Invalid marker: {marker!r} \" . format ( marker = marker )) if not isinstance ( state , bool ): raise TypeError ( 'Param state should be bool.' ) cmd = \":CALCULATE:MARKER:STATE {marker:d} , {state:d} \" self . command ( cmd ) def get_marker_active_state ( self , marker : int ) -> bool : \"\"\"Queries the active state of a specified marker. A marker should be set into active state before further operations. Args: marker: Marker number. `1` | `2` | `3` | `4`. Returns: `True` = active, `False` = inactive. \"\"\" cmd = \":CALCulate:MARKer:STATe? {marker:d} \" . format ( marker = marker ) state = bool ( int ( self . query ( cmd ))) return state def get_marker_x_unit ( self ) -> str : \"\"\"Queries the units of display for the marker values. Returns: The unit of marker X. `\"WAV\"` | `\"FREQ\"`. \"\"\" cmd = \":CALCulate:MARKer:UNIT?\" unit = [ \"WAV\" , \"FREQ\" ][ int ( self . query ( cmd ))] return unit def set_marker_x_unit ( self , unit : str ) -> None : \"\"\"Sets the units of display for the marker values. Args: unit: The unit of marker X. `\"WAV\"` | `\"FREQ\"`. \"\"\" cmd = \":CALCulate:MARKer:UNIT {unit} \" . format ( unit = unit ) self . command ( cmd ) def set_marker_x ( self , marker : int , x : int | float , unit : str ): \"\"\"Places a specified marker in a specified position. Args: marker: Marker number. `1` | `2` | `3` | `4`. x: The x value to put the marker. unit: The unit of x value. `\"THZ\"` or `\"NM\"`. \"\"\" if marker not in self . MARKER_NUMBERS : raise ValueError ( \"Invalid marker: {marker!r} \" . format ( marker = marker )) if unit not in [ 'NM' , 'THZ' ]: raise ValueError ( \"Invalid unit: {u!r} \" . format ( u = unit )) cmd = \":CALCulate:MARKer:X {marker:d} , {x:.6f}{unit} \" . format ( marker = marker , x = x , unit = unit ) self . command ( cmd ) def get_marker_x ( self , marker : int ) -> float : \"\"\"Queries the X value of the specified marker. Args: marker: Marker number. `1` | `2` | `3` | `4` Returns: The X value of the specified marker. If marker x unit is \"WAV\", returns the x value in nm. If x unit is \"FREQ\", returns the x value in THz. Please refer to `get_marker_x_unit` for information. \"\"\" if marker not in self . MARKER_NUMBERS : raise ValueError ( \"Invalid marker: {marker!r} \" . format ( marker = marker )) cmd = \":CALCulate:MARKer:X? {marker:d} \" . format ( marker = marker ) x_unit = self . get_marker_x_unit () if \"WAV\" == x_unit : x = float ( self . query ( cmd )) * 10 ** 9 else : x = float ( self . query ( cmd )) / 10 ** 12 return x def get_marker_y ( self , marker : int ) -> str : \"\"\"Queries the Y value of the specified marker. This unit of the marker level to be queried is dependent on the Y-axis unit of the active trace. \"\"\" if marker not in self . MARKER_NUMBERS : raise ValueError ( \"Invalid marker: {marker!r} \" . format ( marker = marker )) cmd = \":CALCulate:MARKer:Y? {marker:d} \" . format ( marker = marker ) y = float ( self . query ( cmd )) return y def set_y_scale_mode ( self , mode : str ) -> None : \"\"\"Sets the scale mode of the main scale of the level axis. Args: mode: The scale mode of level axis. `\"LOG\"` = Logarighmic, `\"LIN\"` = Linear. \"\"\" if mode not in ( \"LOG\" , \"LIN\" ): raise ValueError ( \"Invalid mode: {mode!r} \" . format ( mode = mode )) cmd = \":DISPlay:TRACe:Y1:SPACing {mode} \" . format ( mode = mode ) self . command ( cmd ) def get_y_scale_mode ( self ) -> str : \"\"\"Queries the scale mode of the main scale of the level axis. Returns: mode: The scale mode of level axis. `\"LOG\"` = Logarighmic, `\"LIN\"` = Linear. \"\"\" cmd = \":DISPlay:TRACe:Y1:SPACing?\" mode = [ \"LOG\" , \"LIN\" ][ int ( self . query ( cmd ))] return mode def set_peak_to_center ( self ) -> None : \"\"\"Detects the peak wavelength and sets it as the measurement center waveform. \"\"\" cmd = \":CALCulate:MARKer:MAXimum:SCENter\" self . command ( cmd ) def set_ref_level ( self , value : int | float , unit : str ) -> None : \"\"\"Sets the reference level of the main scale of the level axis. Args: value: The value of the ref level. unit: The unit of the ref level. `\"DBM\"` | `\"W\"` | `\"MW\"`. \"\"\" if unit not in [ 'DBM' , 'W' , 'MW' ]: raise ValueError ( 'Invalid unit: {unit!r} ' . format ( unit = unit )) cmd = \":DISPlay:TRACe:Y1:RLEVel {value:.6E}{unit} \" . format ( value = value , unit = unit ) self . command ( cmd ) def get_ref_level ( self ) -> Tuple [ float , str ]: \"\"\"Sets/queries the reference level of the main scale of the level axis. Returns: The value of the ref level in unit dBm or W depends on the Y scale mode. Please refer to `get_y_scale_mode` for information. \"\"\" cmd = \":DISPlay:TRACe:Y1:RLEVel?\" level = float ( self . query ( cmd )) return level def set_peak_to_ref ( self ) -> None : \"\"\"Detects the peak level and sets it for the reference level.\"\"\" cmd = \":CALCulate:MARKer:MAXimum:SRLevel\" self . command ( cmd ) def set_auto_ref_level ( self , enable : bool ) -> None : \"\"\"Sets ON/OFF of the function to automatically detect the peak level and sets it as the reference level. Args: enable: Whether to enable auto ref level. \"\"\" if not isinstance ( enable , bool ): raise TypeError ( \"Param enable must be bool type.\" ) cmd = \":CALCulate:MARKer:MAXimum:SRLevel:AUTO {enable:d} \" . format ( enable = enable ) self . command ( cmd ) def get_auto_ref_level ( self ) -> bool : \"\"\"Queries ON/OFF of the function to automatically detect the peak level and sets it as the reference level. Returns: If this function is enabled. \"\"\" cmd = \":CALCulate:MARKer:MAXimum:SRLevel:AUTO?\" enabled = bool ( int ( self . query ( cmd ))) return enabled def get_resolution_bandwidth ( self ) -> float : \"\"\"Queries the measurment resolution. Returns: The resolution bandwidth. If x unit is \"WAV\", returns the resolution in nm. If x unit is \"FREQ\", returns the resolution in GHz. Please refer to `get_x_unit` for more information. \"\"\" cmd = \":SENSe:BANDwidth?\" if \"WAV\" == self . get_x_unit (): res = float ( self . query ( cmd )) * 10 ** 9 else : res = float ( self . query ( cmd )) / 10 ** 9 return res def set_resolution_bandwidth ( self , bandwidth : int | float , unit : str ) -> None : # TODO: verify if only particular values can be set. \"\"\"Sets the measurment resolution. Args: bandwidth: The resolution bandwidth. unit: `\"NM\"` or `\"GHZ\"`. \"\"\" if unit not in [ \"NM\" , \"GHZ\" ]: raise TypeError ( \"Invalid unit: {unit!r} \" . format ( unit = unit )) cmd = \":SENSe:BANDwidth {bandwidth:.6f}{unit} \" . format ( bandwidth = bandwidth , unit = unit ) self . command ( cmd ) def clear_all_markers ( self ) -> None : \"\"\"Clears all markers.\"\"\" self . command ( ':CALCulate:MARKer:AOFF' ) def set_active_trace ( self , trace_name : str ) -> None : \"\"\"Sets the active trace. Args: trace_name: `TRA` | `TRB` | `TRC` | `TRD` | `TRE` | `TRF` | `TRG` \"\"\" if trace_name not in [ 'TRA' , 'TRB' , 'TRC' , 'TRD' , 'TRE' , 'TRF' , 'TRG' ]: raise ValueError ( 'Invalid trace_name: {name!r} ' . format ( name = trace_name )) cmd = ':TRACe:ACTive {trace_name} ' . format ( trace_name = trace_name ) self . command ( cmd ) def get_active_trace ( self ) -> str : \"\"\"Queries the active trace. Returns: The trace name, `TRA` | `TRB` | `TRC` | `TRD` | `TRE` | `TRF` | `TRG`. \"\"\" cmd = ':TRACe:ACTive?' trace_name = self . query ( cmd ) . strip () return trace_name def set_trace_attribute ( self , trace_name : str , attribute : str ) -> None : \"\"\"Sets the attributes of the specified trace. Args: trace_name: `TRA` | `TRB` | `TRC` | `TRD` | `TRE` | `TRF` | `TRG` attribute: `WRIT` | `FIX` | `MAX` | `MIN` | `RAVG` | `CALC` \"\"\" if trace_name not in [ 'TRA' , 'TRB' , 'TRC' , 'TRD' , 'TRE' , 'TRF' , 'TRG' ]: raise ValueError ( 'Invalid trace_name: {name!r} ' . format ( name = trace_name )) if attribute not in [ 'WRIT' , 'FIX' , 'MAX' , 'MIN' , 'RAVG' , 'CALC' ]: raise ValueError ( 'Invalid attribute: {attr!r} ' . format ( attr = attribute )) cmd = ':TRACe:ATTRibute: {trace} {attribute} ' . format ( trace = trace_name , attribute = attribute ) self . command ( cmd ) def get_trace_attribute ( self , trace_name : str ) -> str : \"\"\"Queries the attributes of the specified trace. Args: trace_name: `TRA` | `TRB` | `TRC` | `TRD` | `TRE` | `TRF` | `TRG` Returns: attribute: `WRIT` | `FIX` | `MAX` | `MIN` | `RAVG` | `CALC` \"\"\" cmd = ':TRACe:ATTRibute: {trace} ?' . format ( trace = trace_name ) ATTRS = [ 'WRIT' , 'FIX' , 'MAX' , 'MIN' , 'RAVG' , 'CALC' ] attr = ATTRS [ int ( self . query ( cmd ))] return attr def set_trace_display_status ( self , trace_name : str , display : bool ) -> None : \"\"\"Sets the display status of the specified trace. Args: trace_name: `TRA` | `TRB` | `TRC` | `TRD` | `TRE` | `TRF` | `TRG` display: Whether to display the trace. \"\"\" if trace_name not in [ 'TRA' , 'TRB' , 'TRC' , 'TRD' , 'TRE' , 'TRF' , 'TRG' ]: raise ValueError ( 'Invalid trace_name: {name!r} ' . format ( name = trace_name )) if not isinstance ( display , bool ): raise TypeError ( 'Parameter display must be bool type.' ) cmd = ':TRACe:STATe: {trace_name} {display:d} ' . format ( trace_name = trace_name , display = display ) self . command ( cmd ) def get_trace_display_status ( self , trace_name : str ) -> bool : \"\"\"Queries the display status of the specified trace. Args: trace_name: `TRA` | `TRB` | `TRC` | `TRD` | `TRE` | `TRF` | `TRG` Returns: Whether the trace is displayed. \"\"\" cmd = ':TRACe:STATe: {trace_name} ?' . format ( trace_name = trace_name ) displayed = bool ( int ( self . query ( cmd ))) return displayed def clear_trace ( self , trace_name : str ) -> None : \"\"\"Deletes the data of a specified trace. Args: trace_name: `TRA` | `TRB` | `TRC` | `TRD` | `TRE` | `TRF` | `TRG` \"\"\" if trace_name not in [ 'TRA' , 'TRB' , 'TRC' , 'TRD' , 'TRE' , 'TRF' , 'TRG' ]: raise ValueError ( 'Invalid trace_name: {name!r} ' . format ( name = trace_name )) cmd = ':TRACe:DELete {trace_name} ' . format ( trace_name = trace_name ) self . command ( cmd ) def clear_all_traces ( self ) -> None : \"\"\"Clears the data for all traces. \"\"\" self . command ( ':TRACe:DELete:ALL' ) def get_trace_data_x ( self , trace_name : str ) -> List [ float ]: \"\"\"Queries the wavelength axis data of the specified trace. Data is output in the unit of wavelength value (nm), regardless of whether this unit is in the wavelength mode or in the frequency mode. Args: trace_name: `TRA` | `TRB` | `TRC` | `TRD` | `TRE` | `TRF` | `TRG` Returns: A list of the wavelength axis data in nm. \"\"\" if trace_name not in [ 'TRA' , 'TRB' , 'TRC' , 'TRD' , 'TRE' , 'TRF' , 'TRG' ]: raise ValueError ( 'Invalid trace_name: {name!r} ' . format ( name = trace_name )) cmd = ':TRACe:DATA:X? {trace_name} ' . format ( trace_name ) result = [ float ( i ) * 10 ** 9 for i in self . query ( cmd ) . split ( ',' )] return result def get_trace_data_y ( self , trace_name : str ) -> List [ float ]: \"\"\"Queries the level axis data of specified trace. The data is output in order of its wavelength from the shortest level to the longest, irrespective of the wavelength/frequency mode. When the level scale is LOG, data is output in LOG values. When the level scale is Linear, data is output in linear values. \"\"\" if trace_name not in [ 'TRA' , 'TRB' , 'TRC' , 'TRD' , 'TRE' , 'TRF' , 'TRG' ]: raise ValueError ( 'Invalid trace_name: {name!r} ' . format ( name = trace_name )) cmd = ':TRACe:DATA:Y? {trace_name} ' . format ( trace_name ) result = [ float ( i ) for i in self . query ( cmd ) . split ( ',' )] return result def capture_screen ( self ) -> bytes : \"\"\"Capture the screen in BMP format and returns the iamge data as bytes. Returns: The image data of the screen capture. \"\"\" # create a unique name with nearly no chance to conflict temp_filename = 'tmp- {timestamp:X} ' . format ( timestamp = int ( time . time () * 10 ** 6 )) # save image to internal memory self . command ( ':MMEMORY:STORE:GRAPHICS COLOR,BMP,\" {filename} \",INTERNAL' . format ( filename = temp_filename )) self . opc # save data to PC bin_data = self . query ( ':MMEMORY:DATA? \" {filename} .BMP\",internal' . format ( filename = temp_filename ), bin = True ) bytes_data = bytes ( bin_data ) # delete temp file from internal memory self . command ( ':MMEMORY:DELETE \" {filename} .BMP\",internal' . format ( filename = temp_filename )) return bytes_data def save_screen ( self , file_path ): \"\"\"Capture the screen and save as a .bmp file. Args: file_path: The file path to save the screen capture. \"\"\" data = self . capture_screen () if os . path . exists ( file_path ): raise PermissionError ( 'The file path {path} already exists.' . format ( path = file_path )) with open ( file_path , 'wb' ) as f : f . write ( data )","title":"ModelAQ6370"},{"location":"api/models/#pyinst.models.ModelAQ6370.__init__","text":"Parameters: Name Type Description Default resource_name Resource name or alias of the VISA resource to open. required kwargs directly passed to VisaInstrument.__init__ . required Source code in pyinst\\models.py 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 2391 2392 2393 2394 def __init__ ( self , resource_name , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. kwargs: directly passed to `VisaInstrument.__init__`. \"\"\" super ( ModelAQ6370 , self ) . __init__ ( resource_name , ** kwargs ) self . __analysis_cat = [ \"SWTHRESH\" , \"DFBLD\" , \"SMSR\" , \"OSNR\" , \"WDM\" , ] self . command ( ':FORMat:DATA ASCii' ) # set data format to ascii","title":"__init__()"},{"location":"api/models/#pyinst.models.ModelAQ6370.capture_screen","text":"Capture the screen in BMP format and returns the iamge data as bytes. Returns: Type Description bytes The image data of the screen capture. Source code in pyinst\\models.py 3426 3427 3428 3429 3430 3431 3432 3433 3434 3435 3436 3437 3438 3439 3440 3441 3442 def capture_screen ( self ) -> bytes : \"\"\"Capture the screen in BMP format and returns the iamge data as bytes. Returns: The image data of the screen capture. \"\"\" # create a unique name with nearly no chance to conflict temp_filename = 'tmp- {timestamp:X} ' . format ( timestamp = int ( time . time () * 10 ** 6 )) # save image to internal memory self . command ( ':MMEMORY:STORE:GRAPHICS COLOR,BMP,\" {filename} \",INTERNAL' . format ( filename = temp_filename )) self . opc # save data to PC bin_data = self . query ( ':MMEMORY:DATA? \" {filename} .BMP\",internal' . format ( filename = temp_filename ), bin = True ) bytes_data = bytes ( bin_data ) # delete temp file from internal memory self . command ( ':MMEMORY:DELETE \" {filename} .BMP\",internal' . format ( filename = temp_filename )) return bytes_data","title":"capture_screen()"},{"location":"api/models/#pyinst.models.ModelAQ6370.clear_all_markers","text":"Clears all markers. Source code in pyinst\\models.py 3298 3299 3300 def clear_all_markers ( self ) -> None : \"\"\"Clears all markers.\"\"\" self . command ( ':CALCulate:MARKer:AOFF' )","title":"clear_all_markers()"},{"location":"api/models/#pyinst.models.ModelAQ6370.clear_all_traces","text":"Clears the data for all traces. Source code in pyinst\\models.py 3388 3389 3390 def clear_all_traces ( self ) -> None : \"\"\"Clears the data for all traces. \"\"\" self . command ( ':TRACe:DELete:ALL' )","title":"clear_all_traces()"},{"location":"api/models/#pyinst.models.ModelAQ6370.clear_trace","text":"Deletes the data of a specified trace. Parameters: Name Type Description Default trace_name str TRA | TRB | TRC | TRD | TRE | TRF | TRG required Source code in pyinst\\models.py 3377 3378 3379 3380 3381 3382 3383 3384 3385 3386 def clear_trace ( self , trace_name : str ) -> None : \"\"\"Deletes the data of a specified trace. Args: trace_name: `TRA` | `TRB` | `TRC` | `TRD` | `TRE` | `TRF` | `TRG` \"\"\" if trace_name not in [ 'TRA' , 'TRB' , 'TRC' , 'TRD' , 'TRE' , 'TRF' , 'TRG' ]: raise ValueError ( 'Invalid trace_name: {name!r} ' . format ( name = trace_name )) cmd = ':TRACe:DELete {trace_name} ' . format ( trace_name = trace_name ) self . command ( cmd )","title":"clear_trace()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_active_trace","text":"Queries the active trace. Returns: Type Description str The trace name, TRA | TRB | TRC | TRD | TRE | TRF | TRG . Source code in pyinst\\models.py 3313 3314 3315 3316 3317 3318 3319 3320 3321 def get_active_trace ( self ) -> str : \"\"\"Queries the active trace. Returns: The trace name, `TRA` | `TRB` | `TRC` | `TRD` | `TRE` | `TRF` | `TRG`. \"\"\" cmd = ':TRACe:ACTive?' trace_name = self . query ( cmd ) . strip () return trace_name","title":"get_active_trace()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_analysis_category","text":"Queries the type of analysis. Returns: Type Description str The type of analysis. SWTHRESH | DFBLD | SMSR | WDM . str Please refer to set_analysis_category for detail. Source code in pyinst\\models.py 2512 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 def get_analysis_category ( self ) -> str : \"\"\"Queries the type of analysis. Returns: The type of analysis. `SWTHRESH`|`DFBLD`|`SMSR`|`WDM`. Please refer to `set_analysis_category` for detail. \"\"\" cat_dict = { 0 : \"SWTHRESH\" , 5 : \"DFBLD\" , 8 : \"SMSR\" , 11 : \"WDM\" } cmd = \":CALCulate:CATegory?\" cat = cat_dict [ int ( self . query ( cmd ))] return cat","title":"get_analysis_category()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_analysis_data","text":"Queries the analysis results from the last time analysis was executed. For the output formats of analysis results, please refer to documents from the instrument vendor. Source code in pyinst\\models.py 2899 2900 2901 2902 2903 2904 2905 2906 def get_analysis_data ( self ) -> str : \"\"\"Queries the analysis results from the last time analysis was executed. For the output formats of analysis results, please refer to documents from the instrument vendor. \"\"\" return self . query ( ':CALC:DATA?' )","title":"get_analysis_data()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_auto_analysis","text":"Queries the automatic analysis function. Source code in pyinst\\models.py 2491 2492 2493 2494 2495 def get_auto_analysis ( self ): \"\"\"Queries the automatic analysis function.\"\"\" cmd = \":CALCulate:AUTO?\" enabled = bool ( int ( self . query ( cmd ))) return enabled","title":"get_auto_analysis()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_auto_ref_level","text":"Queries ON/OFF of the function to automatically detect the peak level and sets it as the reference level. Returns: Type Description bool If this function is enabled. Source code in pyinst\\models.py 3257 3258 3259 3260 3261 3262 3263 3264 3265 3266 def get_auto_ref_level ( self ) -> bool : \"\"\"Queries ON/OFF of the function to automatically detect the peak level and sets it as the reference level. Returns: If this function is enabled. \"\"\" cmd = \":CALCulate:MARKer:MAXimum:SRLevel:AUTO?\" enabled = bool ( int ( self . query ( cmd ))) return enabled","title":"get_auto_ref_level()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_auto_zero","text":"Queries whether to enable the auto offset function of the level. Source code in pyinst\\models.py 2470 2471 2472 2473 2474 def get_auto_zero ( self ) -> bool : \"\"\"Queries whether to enable the auto offset function of the level.\"\"\" cmd = \":CALibration:ZERO?\" status = bool ( int ( self . query ( cmd ))) return status","title":"get_auto_zero()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_center","text":"Queries the measurement condition center wavelength/frequency. Returns: Type Description float The value of center frequency/wavelength value. If x unit is float \"WAV\", returns the center wavelength in nm. If x unit is \"FREQ\", float returns the center frequency in THz. float Please refer to get_x_unit for more information. Source code in pyinst\\models.py 2926 2927 2928 2929 2930 2931 2932 2933 2934 2935 2936 2937 2938 2939 2940 2941 2942 def get_center ( self ) -> float : \"\"\" Queries the measurement condition center wavelength/frequency. Returns: The value of center frequency/wavelength value. If x unit is \"WAV\", returns the center wavelength in nm. If x unit is \"FREQ\", returns the center frequency in THz. Please refer to `get_x_unit` for more information. \"\"\" cmd = \":SENSe:WAVelength:CENTer?\" if \"WAV\" == self . get_x_unit (): center = float ( self . query ( cmd )) * 10 ** 9 else : center = float ( self . query ( cmd )) / 10 ** 12 return center","title":"get_center()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_dfbld_analysis_parameter","text":"Sets parameters for the DFB-LD analysis function. For more information, please refer to the documents provided by instument vendor. Parameters: Name Type Description Default item str Analytical item that sets parameter(s). required parameter str Parameter to be set. required Returns: Type Description str A string of the value of parameter. Please refer to str set_dfbld_analysis_parameter for detail. Source code in pyinst\\models.py 2818 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 2829 2830 2831 2832 def get_dfbld_analysis_parameter ( self , item : str , parameter : str ) -> str : \"\"\"Sets parameters for the DFB-LD analysis function. For more information, please refer to the documents provided by instument vendor. Args: item: Analytical item that sets parameter(s). parameter: Parameter to be set. Returns: A string of the value of parameter. Please refer to `set_dfbld_analysis_parameter` for detail. \"\"\" cmd = \":CALCulate:PARameter:DFBLd? {item} , {paramater} \" . format ( item = item , parameter = parameter ) return self . query ( cmd )","title":"get_dfbld_analysis_parameter()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_marker_active_state","text":"Queries the active state of a specified marker. A marker should be set into active state before further operations. Parameters: Name Type Description Default marker int Marker number. 1 | 2 | 3 | 4 . required Returns: Type Description bool True = active, False = inactive. Source code in pyinst\\models.py 3103 3104 3105 3106 3107 3108 3109 3110 3111 3112 3113 3114 3115 def get_marker_active_state ( self , marker : int ) -> bool : \"\"\"Queries the active state of a specified marker. A marker should be set into active state before further operations. Args: marker: Marker number. `1` | `2` | `3` | `4`. Returns: `True` = active, `False` = inactive. \"\"\" cmd = \":CALCulate:MARKer:STATe? {marker:d} \" . format ( marker = marker ) state = bool ( int ( self . query ( cmd ))) return state","title":"get_marker_active_state()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_marker_x","text":"Queries the X value of the specified marker. Parameters: Name Type Description Default marker int Marker number. 1 | 2 | 3 | 4 required Returns: Type Description float The X value of the specified marker. If marker x unit is float \"WAV\", returns the x value in nm. If x unit is \"FREQ\", float returns the x value in THz. float Please refer to get_marker_x_unit for information. Source code in pyinst\\models.py 3151 3152 3153 3154 3155 3156 3157 3158 3159 3160 3161 3162 3163 3164 3165 3166 3167 3168 3169 3170 3171 3172 def get_marker_x ( self , marker : int ) -> float : \"\"\"Queries the X value of the specified marker. Args: marker: Marker number. `1` | `2` | `3` | `4` Returns: The X value of the specified marker. If marker x unit is \"WAV\", returns the x value in nm. If x unit is \"FREQ\", returns the x value in THz. Please refer to `get_marker_x_unit` for information. \"\"\" if marker not in self . MARKER_NUMBERS : raise ValueError ( \"Invalid marker: {marker!r} \" . format ( marker = marker )) cmd = \":CALCulate:MARKer:X? {marker:d} \" . format ( marker = marker ) x_unit = self . get_marker_x_unit () if \"WAV\" == x_unit : x = float ( self . query ( cmd )) * 10 ** 9 else : x = float ( self . query ( cmd )) / 10 ** 12 return x","title":"get_marker_x()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_marker_x_unit","text":"Queries the units of display for the marker values. Returns: Type Description str The unit of marker X. \"WAV\" | \"FREQ\" . Source code in pyinst\\models.py 3117 3118 3119 3120 3121 3122 3123 3124 3125 def get_marker_x_unit ( self ) -> str : \"\"\"Queries the units of display for the marker values. Returns: The unit of marker X. `\"WAV\"` | `\"FREQ\"`. \"\"\" cmd = \":CALCulate:MARKer:UNIT?\" unit = [ \"WAV\" , \"FREQ\" ][ int ( self . query ( cmd ))] return unit","title":"get_marker_x_unit()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_marker_y","text":"Queries the Y value of the specified marker. This unit of the marker level to be queried is dependent on the Y-axis unit of the active trace. Source code in pyinst\\models.py 3174 3175 3176 3177 3178 3179 3180 3181 3182 3183 3184 def get_marker_y ( self , marker : int ) -> str : \"\"\"Queries the Y value of the specified marker. This unit of the marker level to be queried is dependent on the Y-axis unit of the active trace. \"\"\" if marker not in self . MARKER_NUMBERS : raise ValueError ( \"Invalid marker: {marker!r} \" . format ( marker = marker )) cmd = \":CALCulate:MARKer:Y? {marker:d} \" . format ( marker = marker ) y = float ( self . query ( cmd )) return y","title":"get_marker_y()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_ref_level","text":"Sets/queries the reference level of the main scale of the level axis. Returns: Type Description float The value of the ref level in unit dBm or W depends on the Y scale str mode. Please refer to get_y_scale_mode for information. Source code in pyinst\\models.py 3228 3229 3230 3231 3232 3233 3234 3235 3236 3237 3238 def get_ref_level ( self ) -> Tuple [ float , str ]: \"\"\"Sets/queries the reference level of the main scale of the level axis. Returns: The value of the ref level in unit dBm or W depends on the Y scale mode. Please refer to `get_y_scale_mode` for information. \"\"\" cmd = \":DISPlay:TRACe:Y1:RLEVel?\" level = float ( self . query ( cmd )) return level","title":"get_ref_level()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_resolution_bandwidth","text":"Queries the measurment resolution. Returns: Type Description float The resolution bandwidth. If x unit is \"WAV\", returns the float resolution in nm. If x unit is \"FREQ\", returns the resolution float in GHz. float Please refer to get_x_unit for more information. Source code in pyinst\\models.py 3268 3269 3270 3271 3272 3273 3274 3275 3276 3277 3278 3279 3280 3281 3282 3283 def get_resolution_bandwidth ( self ) -> float : \"\"\"Queries the measurment resolution. Returns: The resolution bandwidth. If x unit is \"WAV\", returns the resolution in nm. If x unit is \"FREQ\", returns the resolution in GHz. Please refer to `get_x_unit` for more information. \"\"\" cmd = \":SENSe:BANDwidth?\" if \"WAV\" == self . get_x_unit (): res = float ( self . query ( cmd )) * 10 ** 9 else : res = float ( self . query ( cmd )) / 10 ** 9 return res","title":"get_resolution_bandwidth()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_smsr_analysis_mask","text":"Quereis the mask value for the SMSR analysis function. Returns: Type Description None The mask value in nm. Source code in pyinst\\models.py 2747 2748 2749 2750 2751 2752 2753 2754 2755 def get_smsr_analysis_mask ( self , mask : int | float ) -> None : \"\"\"Quereis the mask value for the SMSR analysis function. Returns: The mask value in nm. \"\"\" cmd = \":CALCulate:PARameter:SMSR:MASK?\" mask = float ( self . query ( cmd )) * 10 ** 9 return mask","title":"get_smsr_analysis_mask()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_smsr_analysis_mode","text":"Sets the analysis mode for the SMSR analysis function. Returns: Type Description str The analysis mode, SMSR1 | SMSR2 | SMSR3 | SMSR4 . Source code in pyinst\\models.py 2769 2770 2771 2772 2773 2774 2775 2776 2777 def get_smsr_analysis_mode ( self ) -> str : \"\"\"Sets the analysis mode for the SMSR analysis function. Returns: The analysis mode, `SMSR1`|`SMSR2`|`SMSR3`|`SMSR4`. \"\"\" cmd = \":CALCulate:PARameter:SMSR:MODE?\" mode = self . query ( cmd ) . strip () return mode","title":"get_smsr_analysis_mode()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_span","text":"Queries the measurement condition measurement span and unit. Returns: Type Description float The value of measurement span value. If x unit is \"WAV\", returns float the span in nm. If x unit is \"FREQ\", returns the span in GHz. float Please refer to get_x_unit for more information. Source code in pyinst\\models.py 2972 2973 2974 2975 2976 2977 2978 2979 2980 2981 2982 2983 2984 2985 2986 def get_span ( self ) -> float : \"\"\"Queries the measurement condition measurement span and unit. Returns: The value of measurement span value. If x unit is \"WAV\", returns the span in nm. If x unit is \"FREQ\", returns the span in GHz. Please refer to `get_x_unit` for more information. \"\"\" cmd = \":SENSe:WAVelengthSPAN?\" if \"WAV\" == self . get_x_unit (): span = float ( self . query ( cmd )) * 10 ** 9 else : span = float ( self . query ( cmd )) / 10 ** 9 return span","title":"get_span()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_start_frequency","text":"Queries the measurement condition measurement start frequency in THz. Returns: Type Description float The start frequency in THz. Source code in pyinst\\models.py 3038 3039 3040 3041 3042 3043 3044 3045 3046 3047 3048 3049 def get_start_frequency ( self ) -> float : \"\"\"Queries the measurement condition measurement start frequency in THz. Returns: The start frequency in THz. \"\"\" cmd = \":SENSe:WAVelength:STOP?\" if \"FREQ\" == self . get_x_unit (): f = float ( self . query ( cmd )) / 10 ** 12 else : f = LIGHTSPEED / ( float ( self . query ( cmd )) * 10 ** 9 ) return f","title":"get_start_frequency()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_start_wavelength","text":"Queries the measurement condition measurement start wavelength in nm. Returns: Type Description float The start wavelength in nm. Source code in pyinst\\models.py 2988 2989 2990 2991 2992 2993 2994 2995 2996 2997 2998 2999 def get_start_wavelength ( self ) -> float : \"\"\"Queries the measurement condition measurement start wavelength in nm. Returns: The start wavelength in nm. \"\"\" cmd = \":SENSe:WAVelength:STARt?\" if \"WAV\" == self . get_x_unit (): wl = float ( self . query ( cmd )) * 10 ** 9 else : wl = LIGHTSPEED / ( float ( self . query ( cmd )) / 10 ** 12 ) return wl","title":"get_start_wavelength()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_stop_frequency","text":"Queries the measurement condition measurement stop frequency in THz. Returns: Type Description float The stop frequency in THz. Source code in pyinst\\models.py 3063 3064 3065 3066 3067 3068 3069 3070 3071 3072 3073 3074 def get_stop_frequency ( self ) -> float : \"\"\"Queries the measurement condition measurement stop frequency in THz. Returns: The stop frequency in THz. \"\"\" cmd = \":SENSe:WAVelength:STARt?\" if \"FREQ\" == self . get_x_unit (): f = float ( self . query ( cmd )) / 10 ** 12 else : f = LIGHTSPEED / ( float ( self . query ( cmd )) * 10 ** 9 ) return f","title":"get_stop_frequency()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_stop_wavelength","text":"Queries the measurement condition measurement stop wavelength in nm. Returns: Type Description float The stop wavelength in nm. Source code in pyinst\\models.py 3013 3014 3015 3016 3017 3018 3019 3020 3021 3022 3023 3024 def get_stop_wavelength ( self ) -> float : \"\"\"Queries the measurement condition measurement stop wavelength in nm. Returns: The stop wavelength in nm. \"\"\" cmd = \":SENSe:WAVelength:STOP?\" if \"WAV\" == self . get_x_unit (): wl = float ( self . query ( cmd )) * 10 ** 9 else : wl = LIGHTSPEED / ( float ( self . query ( cmd )) / 10 ** 12 ) return wl","title":"get_stop_wavelength()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_swthresh_analysis_k","text":"Sets the magnification of the THRESH method-based spectrum width analysis function. Returns: Type Description float The magnification. Source code in pyinst\\models.py 2844 2845 2846 2847 2848 2849 2850 2851 2852 2853 def get_swthresh_analysis_k ( self ) -> float : \"\"\"Sets the magnification of the THRESH method-based spectrum width analysis function. Returns: The magnification. \"\"\" cmd = \":CALCulate:PARameter:SWTHResh:K?\" k = float ( self . query ( cmd )) return k","title":"get_swthresh_analysis_k()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_swthresh_analysis_mfit","text":"Queries whether to enable the mode fit of the THRESH method-based spectrum width analysis function. Returns: Type Description bool Whether to enable the mode fit. Source code in pyinst\\models.py 2867 2868 2869 2870 2871 2872 2873 2874 2875 2876 def get_swthresh_analysis_mfit ( self ) -> bool : \"\"\"Queries whether to enable the mode fit of the THRESH method-based spectrum width analysis function. Returns: Whether to enable the mode fit. \"\"\" cmd = \":CALCulate:PARameter:SWTHresh:MFIT?\" en = bool ( int ( self . query ( cmd ))) return en","title":"get_swthresh_analysis_mfit()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_swthresh_analysis_th","text":"Queries the threshold level of the THRESH method-based spectrum width analysis function. Returns: Type Description float The threshold level in dB. Source code in pyinst\\models.py 2888 2889 2890 2891 2892 2893 2894 2895 2896 2897 def get_swthresh_analysis_th ( self ) -> float : \"\"\"Queries the threshold level of the THRESH method-based spectrum width analysis function. Returns: The threshold level in dB. \"\"\" cmd = \":CALCulate:PARameter:SWTHresh:TH?\" th = float ( self . query ( cmd )) return th","title":"get_swthresh_analysis_th()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_trace_attribute","text":"Queries the attributes of the specified trace. Parameters: Name Type Description Default trace_name str TRA | TRB | TRC | TRD | TRE | TRF | TRG required Returns: Name Type Description attribute str WRIT | FIX | MAX | MIN | RAVG | CALC Source code in pyinst\\models.py 3337 3338 3339 3340 3341 3342 3343 3344 3345 3346 3347 3348 def get_trace_attribute ( self , trace_name : str ) -> str : \"\"\"Queries the attributes of the specified trace. Args: trace_name: `TRA` | `TRB` | `TRC` | `TRD` | `TRE` | `TRF` | `TRG` Returns: attribute: `WRIT` | `FIX` | `MAX` | `MIN` | `RAVG` | `CALC` \"\"\" cmd = ':TRACe:ATTRibute: {trace} ?' . format ( trace = trace_name ) ATTRS = [ 'WRIT' , 'FIX' , 'MAX' , 'MIN' , 'RAVG' , 'CALC' ] attr = ATTRS [ int ( self . query ( cmd ))] return attr","title":"get_trace_attribute()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_trace_data_x","text":"Queries the wavelength axis data of the specified trace. Data is output in the unit of wavelength value (nm), regardless of whether this unit is in the wavelength mode or in the frequency mode. Parameters: Name Type Description Default trace_name str TRA | TRB | TRC | TRD | TRE | TRF | TRG required Returns: Type Description List [ float ] A list of the wavelength axis data in nm. Source code in pyinst\\models.py 3392 3393 3394 3395 3396 3397 3398 3399 3400 3401 3402 3403 3404 3405 3406 3407 3408 def get_trace_data_x ( self , trace_name : str ) -> List [ float ]: \"\"\"Queries the wavelength axis data of the specified trace. Data is output in the unit of wavelength value (nm), regardless of whether this unit is in the wavelength mode or in the frequency mode. Args: trace_name: `TRA` | `TRB` | `TRC` | `TRD` | `TRE` | `TRF` | `TRG` Returns: A list of the wavelength axis data in nm. \"\"\" if trace_name not in [ 'TRA' , 'TRB' , 'TRC' , 'TRD' , 'TRE' , 'TRF' , 'TRG' ]: raise ValueError ( 'Invalid trace_name: {name!r} ' . format ( name = trace_name )) cmd = ':TRACe:DATA:X? {trace_name} ' . format ( trace_name ) result = [ float ( i ) * 10 ** 9 for i in self . query ( cmd ) . split ( ',' )] return result","title":"get_trace_data_x()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_trace_data_y","text":"Queries the level axis data of specified trace. The data is output in order of its wavelength from the shortest level to the longest, irrespective of the wavelength/frequency mode. When the level scale is LOG, data is output in LOG values. When the level scale is Linear, data is output in linear values. Source code in pyinst\\models.py 3410 3411 3412 3413 3414 3415 3416 3417 3418 3419 3420 3421 3422 3423 3424 def get_trace_data_y ( self , trace_name : str ) -> List [ float ]: \"\"\"Queries the level axis data of specified trace. The data is output in order of its wavelength from the shortest level to the longest, irrespective of the wavelength/frequency mode. When the level scale is LOG, data is output in LOG values. When the level scale is Linear, data is output in linear values. \"\"\" if trace_name not in [ 'TRA' , 'TRB' , 'TRC' , 'TRD' , 'TRE' , 'TRF' , 'TRG' ]: raise ValueError ( 'Invalid trace_name: {name!r} ' . format ( name = trace_name )) cmd = ':TRACe:DATA:Y? {trace_name} ' . format ( trace_name ) result = [ float ( i ) for i in self . query ( cmd ) . split ( ',' )] return result","title":"get_trace_data_y()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_trace_display_status","text":"Queries the display status of the specified trace. Parameters: Name Type Description Default trace_name str TRA | TRB | TRC | TRD | TRE | TRF | TRG required Returns: Type Description bool Whether the trace is displayed. Source code in pyinst\\models.py 3364 3365 3366 3367 3368 3369 3370 3371 3372 3373 3374 3375 def get_trace_display_status ( self , trace_name : str ) -> bool : \"\"\"Queries the display status of the specified trace. Args: trace_name: `TRA` | `TRB` | `TRC` | `TRD` | `TRE` | `TRF` | `TRG` Returns: Whether the trace is displayed. \"\"\" cmd = ':TRACe:STATe: {trace_name} ?' . format ( trace_name = trace_name ) displayed = bool ( int ( self . query ( cmd ))) return displayed","title":"get_trace_display_status()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_wdm_analysis_dmask","text":"Queries the channel mask threshold level for the WDM analysis function. Returns: Type Description float The channel mask threshold level in dB. Source code in pyinst\\models.py 2580 2581 2582 2583 2584 2585 2586 2587 2588 2589 def get_wdm_analysis_dmask ( self ) -> float : \"\"\" Queries the channel mask threshold level for the WDM analysis function. Returns: The channel mask threshold level in dB. \"\"\" cmd = \":CALCulate:PARameter:WDM:DMASk?\" dmask = float ( self . query ( cmd )) return dmask","title":"get_wdm_analysis_dmask()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_wdm_analysis_falgo","text":"Queries the fitting function during level measurement applied to noise level measurements made by the WDM analysis function. Options of algorithms: LIN = LINEAR GAUS = GAUSS LOR = LORENZ 3RD = 3RD POLY 4TH = 4YH POLY 5TH = 5TH POLY Returns: Type Description str The name of the algorithm. Refer to options above. Source code in pyinst\\models.py 2698 2699 2700 2701 2702 2703 2704 2705 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 def get_wdm_analysis_falgo ( self ) -> str : \"\"\"Queries the fitting function during level measurement applied to noise level measurements made by the WDM analysis function. Options of algorithms: - `LIN` = LINEAR - `GAUS` = GAUSS - `LOR` = LORENZ - `3RD` = 3RD POLY - `4TH` = 4YH POLY - `5TH` = 5TH POLY Returns: The name of the algorithm. Refer to options above. \"\"\" algo_options = [ \"LIN\" , \"GAUS\" , \"LOR\" , \"3RD\" , \"4TH\" , \"5TH\" ] cmd = \":CALCulate:PARameter:WDM:FALGo?\" algo = algo_options [ int ( self . query ( cmd ))] return algo","title":"get_wdm_analysis_falgo()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_wdm_analysis_marea","text":"Queries the mask range during level measurement applied to noise level measurements made by the WDM analysis function. Returns: Type Description float The mask range in nm. Source code in pyinst\\models.py 2665 2666 2667 2668 2669 2670 2671 2672 2673 2674 def get_wdm_analysis_marea ( self ) -> float : \"\"\"Queries the mask range during level measurement applied to noise level measurements made by the WDM analysis function. Returns: The mask range in nm. \"\"\" cmd = \":CALCulate:PARameter:WDM:MARea?\" marea = float ( self . query ( cmd )) * 10 ** 9 return marea","title":"get_wdm_analysis_marea()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_wdm_analysis_mdiff","text":"Queries the peak bottom difference of channel detection for the WDM analysis function. Returns: Type Description float The peak-bottom difference in dB. Source code in pyinst\\models.py 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 def get_wdm_analysis_mdiff ( self ) -> float : \"\"\" Queries the peak bottom difference of channel detection for the WDM analysis function. Returns: The peak-bottom difference in dB. \"\"\" cmd = \":CALCulate:PARameter:WDM:MDIFf?\" mdiff = float ( self . query ( cmd )) return mdiff","title":"get_wdm_analysis_mdiff()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_wdm_analysis_nalgo","text":"Queries the measurement algorithm applied to noise level measurements made by the WDM analysis function. Options of algorithms: AFIX = AUTO FIX MFIX = MANUAL FIX ACEN = AUTO CENTER MCEN = MANUAL CENTER PIT = PIT Returns: Type Description str The name of algorithm. Refer to options above. Source code in pyinst\\models.py 2613 2614 2615 2616 2617 2618 2619 2620 2621 2622 2623 2624 2625 2626 2627 2628 2629 2630 2631 2632 def get_wdm_analysis_nalgo ( self ) -> str : \"\"\" Queries the measurement algorithm applied to noise level measurements made by the WDM analysis function. Options of algorithms: - `AFIX` = AUTO FIX - `MFIX` = MANUAL FIX - `ACEN` = AUTO CENTER - `MCEN` = MANUAL CENTER - `PIT` = PIT Returns: The name of algorithm. Refer to options above. \"\"\" algo_options = [ \"AFIX\" , \"MFIX\" , \"ACEN\" , \"MCEN\" , \"PIT\" ] cmd = \":CALCulate:PARameter:WDM:NALGo?\" algo = algo_options [ int ( self . query ( cmd ))] return algo","title":"get_wdm_analysis_nalgo()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_wdm_analysis_narea","text":"Quereis the measuring range applied to noise level measurements made by the WDM analysis function. Returns: Type Description float The range in nm. Source code in pyinst\\models.py 2644 2645 2646 2647 2648 2649 2650 2651 2652 2653 def get_wdm_analysis_narea ( self ) -> float : \"\"\"Quereis the measuring range applied to noise level measurements made by the WDM analysis function. Returns: The range in nm. \"\"\" cmd = \":CALCulate:PARameter:WDM:NARea?\" narea = float ( self . query ( cmd )) * 10 ** 9 return narea","title":"get_wdm_analysis_narea()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_wdm_analysis_parameter_nbw","text":"Queries the noise bandwidth for the WDM analysis function. Returns: Type Description float The noise bandwidth in nm. Source code in pyinst\\models.py 2728 2729 2730 2731 2732 2733 2734 2735 2736 def get_wdm_analysis_parameter_nbw ( self ) -> float : \"\"\"Queries the noise bandwidth for the WDM analysis function. Returns: The noise bandwidth in nm. \"\"\" cmd = \":CALCulate:PARameter:WDM:NBW?\" nbw = float ( self . query ( cmd )) * 10 ** 9 return nbw","title":"get_wdm_analysis_parameter_nbw()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_wdm_analysis_threshold","text":"Queries the threshold level of channel detection for the WDM analysis function. Returns: Type Description float The threshold level value in dB. Source code in pyinst\\models.py 2535 2536 2537 2538 2539 2540 2541 2542 2543 2544 2545 def get_wdm_analysis_threshold ( self ) -> float : \"\"\" Queries the threshold level of channel detection for the WDM analysis function. Returns: The threshold level value in dB. \"\"\" cmd = \":CALCulate:PARameter:WDM:TH?\" th = float ( self . query ( cmd )) return th","title":"get_wdm_analysis_threshold()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_x_unit","text":"Queries the units for the X axis. Returns: Type Description str \"WAV\" = Wavelength, str \"FREQ\" = Frequency Source code in pyinst\\models.py 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 def get_x_unit ( self ) -> str : \"\"\"Queries the units for the X axis. Returns: `\"WAV\"` = Wavelength, `\"FREQ\"` = Frequency \"\"\" cmd = \":UNIT:X?\" options = [ \"WAV\" , \"FREQ\" ] unit = options [ int ( self . query ( cmd ))] return unit","title":"get_x_unit()"},{"location":"api/models/#pyinst.models.ModelAQ6370.get_y_scale_mode","text":"Queries the scale mode of the main scale of the level axis. Returns: Name Type Description mode str The scale mode of level axis. \"LOG\" = Logarighmic, \"LIN\" = Linear. Source code in pyinst\\models.py 3198 3199 3200 3201 3202 3203 3204 3205 3206 3207 def get_y_scale_mode ( self ) -> str : \"\"\"Queries the scale mode of the main scale of the level axis. Returns: mode: The scale mode of level axis. `\"LOG\"` = Logarighmic, `\"LIN\"` = Linear. \"\"\" cmd = \":DISPlay:TRACe:Y1:SPACing?\" mode = [ \"LOG\" , \"LIN\" ][ int ( self . query ( cmd ))] return mode","title":"get_y_scale_mode()"},{"location":"api/models/#pyinst.models.ModelAQ6370.run","text":"Makes a REPEAT sweep. Refer to sweep for more information. Source code in pyinst\\models.py 2451 2452 2453 def run ( self ) -> None : \"\"\"Makes a REPEAT sweep. Refer to `sweep` for more information.\"\"\" self . command ( ':INIT:SMOD REPEAT;:INIT' )","title":"run()"},{"location":"api/models/#pyinst.models.ModelAQ6370.save_screen","text":"Capture the screen and save as a .bmp file. Parameters: Name Type Description Default file_path The file path to save the screen capture. required Source code in pyinst\\models.py 3444 3445 3446 3447 3448 3449 3450 3451 3452 3453 3454 def save_screen ( self , file_path ): \"\"\"Capture the screen and save as a .bmp file. Args: file_path: The file path to save the screen capture. \"\"\" data = self . capture_screen () if os . path . exists ( file_path ): raise PermissionError ( 'The file path {path} already exists.' . format ( path = file_path )) with open ( file_path , 'wb' ) as f : f . write ( data )","title":"save_screen()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_active_trace","text":"Sets the active trace. Parameters: Name Type Description Default trace_name str TRA | TRB | TRC | TRD | TRE | TRF | TRG required Source code in pyinst\\models.py 3302 3303 3304 3305 3306 3307 3308 3309 3310 3311 def set_active_trace ( self , trace_name : str ) -> None : \"\"\"Sets the active trace. Args: trace_name: `TRA` | `TRB` | `TRC` | `TRD` | `TRE` | `TRF` | `TRG` \"\"\" if trace_name not in [ 'TRA' , 'TRB' , 'TRC' , 'TRD' , 'TRE' , 'TRF' , 'TRG' ]: raise ValueError ( 'Invalid trace_name: {name!r} ' . format ( name = trace_name )) cmd = ':TRACe:ACTive {trace_name} ' . format ( trace_name = trace_name ) self . command ( cmd )","title":"set_active_trace()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_analysis_category","text":"Sets the type of analysis. Parameters: Name Type Description Default category str The type of analysis. Options: required - `SWTHRESH` Spectrum width analysis (THRESH) required - `DFBLD` DFB-LD parameter analysis required - `SMSR` SMSR analysis required - `OSNR`|`WDM` OSNR(WDM), WDM analysis required Source code in pyinst\\models.py 2497 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 def set_analysis_category ( self , category : str ): \"\"\"Sets the type of analysis. Args: category: The type of analysis. Options: - `SWTHRESH`: Spectrum width analysis (THRESH) - `DFBLD`: DFB-LD parameter analysis - `SMSR`: SMSR analysis - `OSNR`|`WDM`: OSNR(WDM), WDM analysis \"\"\" if category not in self . ANALYSIS_CATEGORIES : raise ValueError ( 'Invalid option of category: %r ' % category ) cmd = \":CALCulate:CATegory {cat} \" . format ( cat = category ) self . command ( cmd )","title":"set_analysis_category()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_auto_analysis","text":"Sets the automatic analysis function. Source code in pyinst\\models.py 2484 2485 2486 2487 2488 2489 def set_auto_analysis ( self , enable ): \"\"\"Sets the automatic analysis function.\"\"\" if not isinstance ( enable , bool ): raise TypeError ( \"param enable should be bool.\" ) cmd = \":CALCulate:AUTO {enable:d} \" . format ( enable = enable ) self . command ( cmd )","title":"set_auto_analysis()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_auto_ref_level","text":"Sets ON/OFF of the function to automatically detect the peak level and sets it as the reference level. Parameters: Name Type Description Default enable bool Whether to enable auto ref level. required Source code in pyinst\\models.py 3245 3246 3247 3248 3249 3250 3251 3252 3253 3254 3255 def set_auto_ref_level ( self , enable : bool ) -> None : \"\"\"Sets ON/OFF of the function to automatically detect the peak level and sets it as the reference level. Args: enable: Whether to enable auto ref level. \"\"\" if not isinstance ( enable , bool ): raise TypeError ( \"Param enable must be bool type.\" ) cmd = \":CALCulate:MARKer:MAXimum:SRLevel:AUTO {enable:d} \" . format ( enable = enable ) self . command ( cmd )","title":"set_auto_ref_level()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_auto_zero","text":"Sets whether to enable the auto offset function of the level. Source code in pyinst\\models.py 2463 2464 2465 2466 2467 2468 def set_auto_zero ( self , status : bool ) -> None : \"\"\"Sets whether to enable the auto offset function of the level.\"\"\" if not isinstance ( status , bool ): raise TypeError ( 'param status should be bool' ) cmd = \":CALibration:ZERO {status:d} \" . format ( status = status ) self . command ( cmd )","title":"set_auto_zero()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_center","text":"Sets the measurement condition center wavelength/frequency. Parameters: Name Type Description Default value int | float The center frequency in THz or wavelength in nm. required unit str \"NM\" or \"THZ\" . required Source code in pyinst\\models.py 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 def set_center ( self , value : int | float , unit : str ) -> None : \"\"\"Sets the measurement condition center wavelength/frequency. Args: value: The center frequency in THz or wavelength in nm. unit: `\"NM\"` or `\"THZ\"`. \"\"\" if unit . upper () not in self . WL_UNITS : raise ValueError ( 'Invalid option for unit: {unit!r} .' . format ( unit = unit )) cmd = \":SENSe:WAVelength:CENTer {value:.4f}{unit} \" . format ( value = value , unit = unit ) self . command ( cmd )","title":"set_center()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_dfbld_analysis_parameter","text":"Sets parameters for the DFB-LD analysis function. For more information, please refer to the documents provided by instument vendor. Parameters: Name Type Description Default item str Analytical item that sets parameter(s). required parameter str Parameter to be set. required data str Setting data. required <item> <parameter> <data> SWIDth ALGO ENVelope|THResh|RMS|PKRMs TH <NRf>[DB] TH2 <NRf>[DB] K <NRf> MFIT OFF|ON|0|1 MDIFf <NRf>[DB] SMSR SMODe SMSR1|SMSR2|SMSR3|SMSR4 SMASk <NRf>[M] MDIFf <NRf>[DB] RMS ALGO RMS|PKRMs TH <NRf>[DB] K <NRf> MDIFf <NRf>[DB] POWer SPAN <NRf>[M] OSNR MDIFf <NRf>[DB] NALGo AFIX|MFIX|ACENter|MCENter|PIT|0|1|2|3|4 NARea <NRf>[M] MARea <NRf>[M] FALGo LINear|GAUSs|LORenz|3RD|4TH|5TH|0|1|2|3|4|5 NBW <NRf>[M] SPOWer PEAK|INTegral|0|1 IRANge <NRf> Source code in pyinst\\models.py 2779 2780 2781 2782 2783 2784 2785 2786 2787 2788 2789 2790 2791 2792 2793 2794 2795 2796 2797 2798 2799 2800 2801 2802 2803 2804 2805 2806 2807 2808 2809 2810 2811 2812 2813 2814 2815 2816 def set_dfbld_analysis_parameter ( self , item : str , parameter : str , data : str ) -> None : \"\"\"Sets parameters for the DFB-LD analysis function. For more information, please refer to the documents provided by instument vendor. Args: item: Analytical item that sets parameter(s). parameter: Parameter to be set. data: Setting data. |`<item>`|`<parameter>`|`<data>`| |--------|-------------|--------| |SWIDth |ALGO |`ENVelope|THResh|RMS|PKRMs`| | |TH |`<NRf>[DB]`| | |TH2 |`<NRf>[DB]`| | |K |`<NRf>`| | |MFIT |`OFF|ON|0|1`| | |MDIFf |`<NRf>[DB]`| |SMSR |SMODe |`SMSR1|SMSR2|SMSR3|SMSR4`| | |SMASk |`<NRf>[M]`| | |MDIFf |`<NRf>[DB]`| |RMS |ALGO |`RMS|PKRMs`| | |TH |`<NRf>[DB]`| | |K |`<NRf>`| | |MDIFf |`<NRf>[DB]`| |POWer |SPAN |`<NRf>[M]`| |OSNR |MDIFf |`<NRf>[DB]`| | |NALGo |`AFIX|MFIX|ACENter|MCENter|PIT|0|1|2|3|4`| | |NARea |`<NRf>[M]`| | |MARea |`<NRf>[M]`| | |FALGo |`LINear|GAUSs|LORenz|3RD|4TH|5TH|0|1|2|3|4|5`| | |NBW |`<NRf>[M]`| | |SPOWer |`PEAK|INTegral|0|1`| | |IRANge |`<NRf>`| \"\"\" cmd = \":CALCulate:PARameter:DFBLd {item} , {paramater} , {data} \" . format ( item = item , parameter = parameter , data = data ) self . command ( cmd )","title":"set_dfbld_analysis_parameter()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_marker_active_state","text":"Set the active state of a specified marker. A marker should be set into active state before further operations. Parameters: Name Type Description Default marker int Marker number. 1 | 2 | 3 | 4 . required state bool True = active, False = inactive. required Source code in pyinst\\models.py 3088 3089 3090 3091 3092 3093 3094 3095 3096 3097 3098 3099 3100 3101 def set_marker_active_state ( self , marker : int , state : bool ) -> None : \"\"\"Set the active state of a specified marker. A marker should be set into active state before further operations. Args: marker: Marker number. `1` | `2` | `3` | `4`. state: `True` = active, `False` = inactive. \"\"\" if marker not in self . MARKER_NUMBERS : raise ValueError ( \"Invalid marker: {marker!r} \" . format ( marker = marker )) if not isinstance ( state , bool ): raise TypeError ( 'Param state should be bool.' ) cmd = \":CALCULATE:MARKER:STATE {marker:d} , {state:d} \" self . command ( cmd )","title":"set_marker_active_state()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_marker_x","text":"Places a specified marker in a specified position. Parameters: Name Type Description Default marker int Marker number. 1 | 2 | 3 | 4 . required x int | float The x value to put the marker. required unit str The unit of x value. \"THZ\" or \"NM\" . required Source code in pyinst\\models.py 3136 3137 3138 3139 3140 3141 3142 3143 3144 3145 3146 3147 3148 3149 def set_marker_x ( self , marker : int , x : int | float , unit : str ): \"\"\"Places a specified marker in a specified position. Args: marker: Marker number. `1` | `2` | `3` | `4`. x: The x value to put the marker. unit: The unit of x value. `\"THZ\"` or `\"NM\"`. \"\"\" if marker not in self . MARKER_NUMBERS : raise ValueError ( \"Invalid marker: {marker!r} \" . format ( marker = marker )) if unit not in [ 'NM' , 'THZ' ]: raise ValueError ( \"Invalid unit: {u!r} \" . format ( u = unit )) cmd = \":CALCulate:MARKer:X {marker:d} , {x:.6f}{unit} \" . format ( marker = marker , x = x , unit = unit ) self . command ( cmd )","title":"set_marker_x()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_marker_x_unit","text":"Sets the units of display for the marker values. Parameters: Name Type Description Default unit str The unit of marker X. \"WAV\" | \"FREQ\" . required Source code in pyinst\\models.py 3127 3128 3129 3130 3131 3132 3133 3134 def set_marker_x_unit ( self , unit : str ) -> None : \"\"\"Sets the units of display for the marker values. Args: unit: The unit of marker X. `\"WAV\"` | `\"FREQ\"`. \"\"\" cmd = \":CALCulate:MARKer:UNIT {unit} \" . format ( unit = unit ) self . command ( cmd )","title":"set_marker_x_unit()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_peak_to_center","text":"Detects the peak wavelength and sets it as the measurement center waveform. Source code in pyinst\\models.py 3209 3210 3211 3212 3213 3214 def set_peak_to_center ( self ) -> None : \"\"\"Detects the peak wavelength and sets it as the measurement center waveform. \"\"\" cmd = \":CALCulate:MARKer:MAXimum:SCENter\" self . command ( cmd )","title":"set_peak_to_center()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_peak_to_ref","text":"Detects the peak level and sets it for the reference level. Source code in pyinst\\models.py 3240 3241 3242 3243 def set_peak_to_ref ( self ) -> None : \"\"\"Detects the peak level and sets it for the reference level.\"\"\" cmd = \":CALCulate:MARKer:MAXimum:SRLevel\" self . command ( cmd )","title":"set_peak_to_ref()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_ref_level","text":"Sets the reference level of the main scale of the level axis. Parameters: Name Type Description Default value int | float The value of the ref level. required unit str The unit of the ref level. \"DBM\" | \"W\" | \"MW\" . required Source code in pyinst\\models.py 3216 3217 3218 3219 3220 3221 3222 3223 3224 3225 3226 def set_ref_level ( self , value : int | float , unit : str ) -> None : \"\"\"Sets the reference level of the main scale of the level axis. Args: value: The value of the ref level. unit: The unit of the ref level. `\"DBM\"` | `\"W\"` | `\"MW\"`. \"\"\" if unit not in [ 'DBM' , 'W' , 'MW' ]: raise ValueError ( 'Invalid unit: {unit!r} ' . format ( unit = unit )) cmd = \":DISPlay:TRACe:Y1:RLEVel {value:.6E}{unit} \" . format ( value = value , unit = unit ) self . command ( cmd )","title":"set_ref_level()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_resolution_bandwidth","text":"Sets the measurment resolution. Parameters: Name Type Description Default bandwidth int | float The resolution bandwidth. required unit str \"NM\" or \"GHZ\" . required Source code in pyinst\\models.py 3285 3286 3287 3288 3289 3290 3291 3292 3293 3294 3295 3296 def set_resolution_bandwidth ( self , bandwidth : int | float , unit : str ) -> None : # TODO: verify if only particular values can be set. \"\"\"Sets the measurment resolution. Args: bandwidth: The resolution bandwidth. unit: `\"NM\"` or `\"GHZ\"`. \"\"\" if unit not in [ \"NM\" , \"GHZ\" ]: raise TypeError ( \"Invalid unit: {unit!r} \" . format ( unit = unit )) cmd = \":SENSe:BANDwidth {bandwidth:.6f}{unit} \" . format ( bandwidth = bandwidth , unit = unit ) self . command ( cmd )","title":"set_resolution_bandwidth()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_smsr_analysis_mask","text":"Set the mask value for the SMSR analysis function. Parameters: Name Type Description Default mask int | float The mask value in nm. required Source code in pyinst\\models.py 2738 2739 2740 2741 2742 2743 2744 2745 def set_smsr_analysis_mask ( self , mask : int | float ) -> None : \"\"\"Set the mask value for the SMSR analysis function. Args: mask: The mask value in nm. \"\"\" cmd = \":CALCulate:PARameter:SMSR:MASK {mask:.2f} NM\" . format ( mask = mask ) self . command ( cmd )","title":"set_smsr_analysis_mask()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_smsr_analysis_mode","text":"Sets the analysis mode for the SMSR analysis function. Parameters: Name Type Description Default mode str The analysis mode, SMSR1 | SMSR2 | SMSR3 | SMSR4 . required Source code in pyinst\\models.py 2757 2758 2759 2760 2761 2762 2763 2764 2765 2766 2767 def set_smsr_analysis_mode ( self , mode : str ) -> None : \"\"\"Sets the analysis mode for the SMSR analysis function. Args: mode: The analysis mode, `SMSR1`|`SMSR2`|`SMSR3`|`SMSR4`. \"\"\" options = [ \"SMSR1\" , \"SMSR2\" , \"SMSR3\" , \"SMSR4\" ] if mode not in options : raise ValueError ( \"Invalid option for mode: {mode!r} \" . format ( mode = mode )) cmd = \":CALCulate:PARameter:SMSR:MODE {mode} \" . format ( mode = mode ) self . command ( cmd )","title":"set_smsr_analysis_mode()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_span","text":"Sets the measurement condition measurement span. Parameters: Name Type Description Default value int | float The value of measurement span. required unit str \"NM\" or \"GHZ\" . required Source code in pyinst\\models.py 2960 2961 2962 2963 2964 2965 2966 2967 2968 2969 2970 def set_span ( self , value : int | float , unit : str ) -> None : \"\"\"Sets the measurement condition measurement span. Args: value: The value of measurement span. unit: `\"NM\"` or `\"GHZ\"`. \"\"\" if unit not in self . WL_SPAN_UNITS : raise ValueError ( \"Invalid option for unit: {unit!r} \" . format ( unit = unit )) cmd = \":SENSe:WAVelengthSPAN {value:.2f}{unit} \" . format ( value = value , unit = unit ) return self . command ( cmd )","title":"set_span()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_start_frequency","text":"Queries the measurement condition measurement start frequency in THz. Parameters: Name Type Description Default frequency int | float The start frequency in THz. required Source code in pyinst\\models.py 3051 3052 3053 3054 3055 3056 3057 3058 3059 3060 3061 def set_start_frequency ( self , frequency : int | float ) -> None : \"\"\"Queries the measurement condition measurement start frequency in THz. Args: frequency: The start frequency in THz. \"\"\" if \"FREQ\" == self . get_x_unit (): cmd = \":SENSe:WAVelength:STOP {freq:.6f} THZ\" . format ( freq = frequency ) self . command ( cmd ) else : self . set_stop_wavelength ( LIGHTSPEED / frequency )","title":"set_start_frequency()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_start_wavelength","text":"Sets the measurement condition measurement start wavelength in nm. Parameters: Name Type Description Default wavelength int | float The start wavelength in nm. required Source code in pyinst\\models.py 3001 3002 3003 3004 3005 3006 3007 3008 3009 3010 3011 def set_start_wavelength ( self , wavelength : int | float ) -> None : \"\"\"Sets the measurement condition measurement start wavelength in nm. Args: wavelength: The start wavelength in nm. \"\"\" if \"WAV\" == self . get_x_unit (): cmd = \":SENSe:WAVelength:STARt {wl:.6f} NM\" . format ( wl = wavelength ) self . command ( cmd ) else : self . set_stop_frequency ( LIGHTSPEED / wavelength )","title":"set_start_wavelength()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_stop_frequency","text":"Queries the measurement condition measurement stop frequency in THz. Parameters: Name Type Description Default frequency int | float The stop frequency in THz. required Source code in pyinst\\models.py 3076 3077 3078 3079 3080 3081 3082 3083 3084 3085 3086 def set_stop_frequency ( self , frequency : int | float ) -> None : \"\"\"Queries the measurement condition measurement stop frequency in THz. Args: frequency: The stop frequency in THz. \"\"\" if \"FREQ\" == self . get_x_unit (): cmd = \":SENSe:WAVelength:STARt {freq:.6f} THZ\" . format ( freq = frequency ) self . command ( cmd ) else : self . set_start_wavelength ( LIGHTSPEED / frequency )","title":"set_stop_frequency()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_stop_wavelength","text":"Sets the measurement condition measurement stop wavelength in nm. Parameters: Name Type Description Default wavelength int | float The stop wavelength in nm. required Source code in pyinst\\models.py 3026 3027 3028 3029 3030 3031 3032 3033 3034 3035 3036 def set_stop_wavelength ( self , wavelength : int | float ) -> None : \"\"\"Sets the measurement condition measurement stop wavelength in nm. Args: wavelength: The stop wavelength in nm. \"\"\" if \"WAV\" == self . get_x_unit (): cmd = \":SENSe:WAVelength:STOP {wl:.6f} NM\" . format ( wl = wavelength ) self . command ( cmd ) else : self . set_start_frequency ( LIGHTSPEED / wavelength )","title":"set_stop_wavelength()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_swthresh_analysis_k","text":"Sets the magnification of the THRESH method-based spectrum width analysis function. Parameters: Name Type Description Default k int | float The magnification. required Source code in pyinst\\models.py 2834 2835 2836 2837 2838 2839 2840 2841 2842 def set_swthresh_analysis_k ( self , k : int | float ) -> None : \"\"\"Sets the magnification of the THRESH method-based spectrum width analysis function. Args: k: The magnification. \"\"\" cmd = \":CALCulate:PARameter:SWTHResh:K {k:.2f} \" . format ( k = k ) self . command ( cmd )","title":"set_swthresh_analysis_k()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_swthresh_analysis_mfit","text":"Sets whether to enable the mode fit of the THRESH method-based spectrum width analysis function. Parameters: Name Type Description Default en bool Whether to enable the mode fit. required Source code in pyinst\\models.py 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 def set_swthresh_analysis_mfit ( self , en : bool ) -> None : \"\"\"Sets whether to enable the mode fit of the THRESH method-based spectrum width analysis function. Args: en: Whether to enable the mode fit. \"\"\" if not isinstance ( en , bool ): raise TypeError ( \"Param en should be bool.\" ) cmd = \":CALCulate:PARameter:SWTHresh:MFIT {en:d} \" . format ( en = en ) self . command ( cmd )","title":"set_swthresh_analysis_mfit()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_swthresh_analysis_th","text":"Sets the threshold level of the THRESH method-based spectrum width analysis function. Parameters: Name Type Description Default th int | float The threshold level in dB. required Source code in pyinst\\models.py 2878 2879 2880 2881 2882 2883 2884 2885 2886 def set_swthresh_analysis_th ( self , th : int | float ) -> None : \"\"\"Sets the threshold level of the THRESH method-based spectrum width analysis function. Args: th: The threshold level in dB. \"\"\" cmd = \":CALCulate:PARameter:SWTHresh:TH {th:.2f} DB\" . format ( th = th ) self . command ( cmd )","title":"set_swthresh_analysis_th()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_trace_attribute","text":"Sets the attributes of the specified trace. Parameters: Name Type Description Default trace_name str TRA | TRB | TRC | TRD | TRE | TRF | TRG required attribute str WRIT | FIX | MAX | MIN | RAVG | CALC required Source code in pyinst\\models.py 3323 3324 3325 3326 3327 3328 3329 3330 3331 3332 3333 3334 3335 def set_trace_attribute ( self , trace_name : str , attribute : str ) -> None : \"\"\"Sets the attributes of the specified trace. Args: trace_name: `TRA` | `TRB` | `TRC` | `TRD` | `TRE` | `TRF` | `TRG` attribute: `WRIT` | `FIX` | `MAX` | `MIN` | `RAVG` | `CALC` \"\"\" if trace_name not in [ 'TRA' , 'TRB' , 'TRC' , 'TRD' , 'TRE' , 'TRF' , 'TRG' ]: raise ValueError ( 'Invalid trace_name: {name!r} ' . format ( name = trace_name )) if attribute not in [ 'WRIT' , 'FIX' , 'MAX' , 'MIN' , 'RAVG' , 'CALC' ]: raise ValueError ( 'Invalid attribute: {attr!r} ' . format ( attr = attribute )) cmd = ':TRACe:ATTRibute: {trace} {attribute} ' . format ( trace = trace_name , attribute = attribute ) self . command ( cmd )","title":"set_trace_attribute()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_trace_display_status","text":"Sets the display status of the specified trace. Parameters: Name Type Description Default trace_name str TRA | TRB | TRC | TRD | TRE | TRF | TRG required display bool Whether to display the trace. required Source code in pyinst\\models.py 3350 3351 3352 3353 3354 3355 3356 3357 3358 3359 3360 3361 3362 def set_trace_display_status ( self , trace_name : str , display : bool ) -> None : \"\"\"Sets the display status of the specified trace. Args: trace_name: `TRA` | `TRB` | `TRC` | `TRD` | `TRE` | `TRF` | `TRG` display: Whether to display the trace. \"\"\" if trace_name not in [ 'TRA' , 'TRB' , 'TRC' , 'TRD' , 'TRE' , 'TRF' , 'TRG' ]: raise ValueError ( 'Invalid trace_name: {name!r} ' . format ( name = trace_name )) if not isinstance ( display , bool ): raise TypeError ( 'Parameter display must be bool type.' ) cmd = ':TRACe:STATe: {trace_name} {display:d} ' . format ( trace_name = trace_name , display = display ) self . command ( cmd )","title":"set_trace_display_status()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_wdm_analysis_dmask","text":"Sets the channel mask threshold level for the WDM analysis function. Parameters: Name Type Description Default dmask int | float The channel mask threshold level in dB. required Source code in pyinst\\models.py 2570 2571 2572 2573 2574 2575 2576 2577 2578 def set_wdm_analysis_dmask ( self , dmask : int | float ) -> None : \"\"\" Sets the channel mask threshold level for the WDM analysis function. Args: dmask: The channel mask threshold level in dB. \"\"\" cmd = \":CALCulate:PARameter:WDM:DMASk {dmask:.2f} DB\" . format ( dmask = dmask ) self . command ( cmd )","title":"set_wdm_analysis_dmask()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_wdm_analysis_falgo","text":"Sets the fitting function during level measurement applied to noise level measurements made by the WDM analysis function. Options of algorithms: LIN = LINEAR GAUS = GAUSS LOR = LORENZ 3RD = 3RD POLY 4TH = 4YH POLY 5TH = 5TH POLY Parameters: Name Type Description Default algo str The name of the algorithm. Refer to options above. required Source code in pyinst\\models.py 2676 2677 2678 2679 2680 2681 2682 2683 2684 2685 2686 2687 2688 2689 2690 2691 2692 2693 2694 2695 2696 def set_wdm_analysis_falgo ( self , algo : str ) -> None : \"\"\"Sets the fitting function during level measurement applied to noise level measurements made by the WDM analysis function. Options of algorithms: - `LIN` = LINEAR - `GAUS` = GAUSS - `LOR` = LORENZ - `3RD` = 3RD POLY - `4TH` = 4YH POLY - `5TH` = 5TH POLY Args: algo: The name of the algorithm. Refer to options above. \"\"\" algo_options = [ \"LIN\" , \"GAUS\" , \"LOR\" , \"3RD\" , \"4TH\" , \"5TH\" ] if algo . upper () not in algo_options : raise ValueError ( \"Invalid value for algo: {value!r} \" . format ( value = algo )) cmd = \":CALCulate:PARameter:WDM:FALGo {algo} \" . format ( algo = algo ) self . command ( cmd )","title":"set_wdm_analysis_falgo()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_wdm_analysis_marea","text":"Sets the mask range during level measurement applied to noise level measurements made by the WDM analysis function. Parameters: Name Type Description Default marea int | float The mask range in nm. required Source code in pyinst\\models.py 2655 2656 2657 2658 2659 2660 2661 2662 2663 def set_wdm_analysis_marea ( self , marea : int | float ) -> None : \"\"\"Sets the mask range during level measurement applied to noise level measurements made by the WDM analysis function. Args: marea: The mask range in nm. \"\"\" cmd = \":CALCulate:PARameter:WDM:MARea {marea:.2f} NM\" . format ( marea = marea ) self . command ( cmd )","title":"set_wdm_analysis_marea()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_wdm_analysis_mdiff","text":"Sets the peak bottom difference of channel detection for the WDM analysis function. Parameters: Name Type Description Default mdiff int | float The peak-bottom difference in dB. required Source code in pyinst\\models.py 2547 2548 2549 2550 2551 2552 2553 2554 2555 2556 def set_wdm_analysis_mdiff ( self , mdiff : int | float ) -> None : \"\"\" Sets the peak bottom difference of channel detection for the WDM analysis function. Args: mdiff: The peak-bottom difference in dB. \"\"\" cmd = \":CALCulate:PARameter:WDM:MDIFf {mdiff:.2f} DB\" . format ( mdiff = mdiff ) self . command ( cmd )","title":"set_wdm_analysis_mdiff()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_wdm_analysis_nalgo","text":"Sets the measurement algorithm applied to noise level measurements made by the WDM analysis function. Options of algorithms: AFIX = AUTO FIX MFIX = MANUAL FIX ACEN = AUTO CENTER MCEN = MANUAL CENTER PIT = PIT Parameters: Name Type Description Default algo str The name of algorithm. Refer to options above. required Source code in pyinst\\models.py 2591 2592 2593 2594 2595 2596 2597 2598 2599 2600 2601 2602 2603 2604 2605 2606 2607 2608 2609 2610 2611 def set_wdm_analysis_nalgo ( self , algo : str ) -> None : \"\"\" Sets the measurement algorithm applied to noise level measurements made by the WDM analysis function. Options of algorithms: - `AFIX` = AUTO FIX - `MFIX` = MANUAL FIX - `ACEN` = AUTO CENTER - `MCEN` = MANUAL CENTER - `PIT` = PIT Args: algo: The name of algorithm. Refer to options above. \"\"\" algo_options = [ \"AFIX\" , \"MFIX\" , \"ACEN\" , \"MCEN\" , \"PIT\" ] if algo . upper () not in algo_options : raise ValueError ( \"Invalid value for algo: {value!r} \" . format ( value = algo )) cmd = \":CALCulate:PARameter:WDM:NALGo {algo} \" . format ( algo = algo ) self . command ( cmd )","title":"set_wdm_analysis_nalgo()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_wdm_analysis_narea","text":"Sets the measuring range applied to noise level measurements made by the WDM analysis function. Parameters: Name Type Description Default narea int | float The range in nm. required Source code in pyinst\\models.py 2634 2635 2636 2637 2638 2639 2640 2641 2642 def set_wdm_analysis_narea ( self , narea : int | float ) -> None : \"\"\"Sets the measuring range applied to noise level measurements made by the WDM analysis function. Args: narea: The range in nm. \"\"\" cmd = \":CALCulate:PARameter:WDM:NARea {narea:.2f} NM\" . format ( narea = narea ) self . command ( cmd )","title":"set_wdm_analysis_narea()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_wdm_analysis_parameter_nbw","text":"Sets the noise bandwidth for the WDM analysis function. Parameters: Name Type Description Default nbw int | float The noise bandwidth in nm. required Source code in pyinst\\models.py 2719 2720 2721 2722 2723 2724 2725 2726 def set_wdm_analysis_parameter_nbw ( self , nbw : int | float ) -> None : \"\"\"Sets the noise bandwidth for the WDM analysis function. Args: nbw: The noise bandwidth in nm. \"\"\" cmd = \":CALCulate:PARameter:WDM:NBW {nbw:.2f} NM\" . format ( nbw = nbw ) self . command ( cmd )","title":"set_wdm_analysis_parameter_nbw()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_wdm_analysis_threshold","text":"Set the threshold level of channel detection for the WDM analysis function. Parameters: Name Type Description Default threshold int | float The threshold level value in dB. required Source code in pyinst\\models.py 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 def set_wdm_analysis_threshold ( self , threshold : int | float ) -> None : \"\"\" Set the threshold level of channel detection for the WDM analysis function. Args: threshold: The threshold level value in dB. \"\"\" cmd = \":CALCulate:PARameter:WDM:TH {th:.2f} DB\" . format ( th = threshold ) self . command ( cmd )","title":"set_wdm_analysis_threshold()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_x_unit","text":"Sets the units for the X axis. Parameters: Name Type Description Default unit str \"WAV\" | \"FREQ\" . \"WAV\" = Wavelength, \"FREQ\" = Frequency required Source code in pyinst\\models.py 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 def set_x_unit ( self , unit : str ): \"\"\"Sets the units for the X axis. Args: unit: `\"WAV\"` | `\"FREQ\"`. `\"WAV\"` = Wavelength, `\"FREQ\"` = Frequency \"\"\" cmd = \":UNIT:X {unit} \" . format ( unit ) self . command ( cmd )","title":"set_x_unit()"},{"location":"api/models/#pyinst.models.ModelAQ6370.set_y_scale_mode","text":"Sets the scale mode of the main scale of the level axis. Parameters: Name Type Description Default mode str The scale mode of level axis. \"LOG\" = Logarighmic, \"LIN\" = Linear. required Source code in pyinst\\models.py 3186 3187 3188 3189 3190 3191 3192 3193 3194 3195 3196 def set_y_scale_mode ( self , mode : str ) -> None : \"\"\"Sets the scale mode of the main scale of the level axis. Args: mode: The scale mode of level axis. `\"LOG\"` = Logarighmic, `\"LIN\"` = Linear. \"\"\" if mode not in ( \"LOG\" , \"LIN\" ): raise ValueError ( \"Invalid mode: {mode!r} \" . format ( mode = mode )) cmd = \":DISPlay:TRACe:Y1:SPACing {mode} \" . format ( mode = mode ) self . command ( cmd )","title":"set_y_scale_mode()"},{"location":"api/models/#pyinst.models.ModelAQ6370.single","text":"Makes a SINGLE sweep. Refer to sweep for more information. Source code in pyinst\\models.py 2459 2460 2461 def single ( self ) -> None : \"\"\"Makes a SINGLE sweep. Refer to `sweep` for more information.\"\"\" self . command ( ':INIT:SMOD SINGLE;:INIT' )","title":"single()"},{"location":"api/models/#pyinst.models.ModelAQ6370.stop","text":"Stops sweep. Source code in pyinst\\models.py 2455 2456 2457 def stop ( self ) -> None : \"\"\"Stops sweep.\"\"\" self . command ( ':ABOR' )","title":"stop()"},{"location":"api/models/#pyinst.models.ModelAQ6370.sweep","text":"Sets the sweep mode and makes a sweep. For information about the sweep modes, please refer to documentation of the instrument. Parameters: Name Type Description Default mode str Sweep mode. \"AUTO\" | \"REPEAT\" | \"SINGLE\" | \"STOP\" . 'REPEAT' Source code in pyinst\\models.py 2436 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 2447 2448 2449 def sweep ( self , mode : str = \"REPEAT\" ) -> None : \"\"\"Sets the sweep mode and makes a sweep. For information about the sweep modes, please refer to documentation of the instrument. Args: mode: Sweep mode. `\"AUTO\"` | `\"REPEAT\"` | `\"SINGLE\"` | `\"STOP\"`. \"\"\" options = [ \"AUTO\" , \"REPEAT\" , \"SINGLE\" , \"STOP\" ] if mode not in options : raise ValueError ( \"Invalid value for param mode: {value} \" . format ( value = mode )) if mode == \"STOP\" : self . command ( ':ABOR' ) else : self . command ( ':INIT:SMOD {mode} ;:INIT' . format ( mode = mode ))","title":"sweep()"},{"location":"api/models/#pyinst.models.ModelAQ6370.zero_once","text":"Perform offset adjustment once and wait until adjustment complete. TODO: should stopped? Source code in pyinst\\models.py 2476 2477 2478 2479 2480 2481 2482 def zero_once ( self ): \"\"\"Perform offset adjustment once and wait until adjustment complete. TODO: should stopped?\"\"\" self . command ( \":CALibration:ZERO ONCE\" ) while True : being_executed = int ( self . query ( \":CALibration:ZERO:STATus?\" )) if not being_executed : break","title":"zero_once()"},{"location":"api/models/#pyinst.models.ModelATS535","text":"Bases: VisaInstrument , TypeTS ATS-535 is a thermo-stream model by Temptronic. Note that before operating with temperature directly (means not in Cycle mode), you should set the thermo-stream to the Operator screen, and make sure the test head is lower down, and the air flow is on. Examples: ts = ModelATS535 ( '<resource-name>' ) ts . reset_operator () # check the test head is down if not ts . is_head_down (): raise OperationalError ( 'The thermo-stream test head is up.' ) # turn on the air flow ts . flow () # operate with the temperature directly ts . set_target_temp ( 35 ) t = ts . get_current_temp () Source code in pyinst\\models.py 3753 3754 3755 3756 3757 3758 3759 3760 3761 3762 3763 3764 3765 3766 3767 3768 3769 3770 3771 3772 3773 3774 3775 3776 3777 3778 3779 3780 3781 3782 3783 3784 3785 3786 3787 3788 3789 3790 3791 3792 3793 3794 3795 3796 3797 3798 3799 3800 3801 3802 3803 3804 3805 3806 3807 3808 3809 3810 3811 3812 3813 3814 3815 3816 3817 3818 3819 3820 3821 3822 3823 3824 3825 3826 3827 3828 3829 3830 3831 3832 3833 3834 3835 3836 3837 3838 3839 3840 3841 3842 3843 3844 3845 3846 3847 3848 3849 3850 3851 3852 3853 3854 3855 3856 3857 3858 3859 3860 3861 3862 3863 3864 3865 3866 3867 3868 3869 3870 3871 3872 3873 3874 3875 3876 3877 3878 3879 3880 3881 3882 3883 3884 3885 3886 3887 3888 3889 3890 3891 3892 3893 3894 3895 3896 3897 3898 3899 3900 3901 3902 3903 3904 3905 3906 3907 3908 3909 3910 3911 3912 3913 3914 3915 3916 class ModelATS535 ( VisaInstrument , TypeTS ): \"\"\"ATS-535 is a thermo-stream model by Temptronic. Note that before operating with temperature directly (means not in Cycle mode), you should set the thermo-stream to the Operator screen, and make sure the test head is lower down, and the air flow is on. Examples: ```python ts = ModelATS535('<resource-name>') ts.reset_operator() # check the test head is down if not ts.is_head_down(): raise OperationalError('The thermo-stream test head is up.') # turn on the air flow ts.flow() # operate with the temperature directly ts.set_target_temp(35) t = ts.get_current_temp() ``` \"\"\" model = \"ATS-535\" brand = \"Temptronic\" def __init__ ( self , resource_name , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. **kwargs: directly passed to `VisaInstrument.__init__` \"\"\" super ( ModelATS535 , self ) . __init__ ( resource_name , ** kwargs ) @property def ts_type ( self ) -> TemperatureSourceType : return TemperatureSourceType . THERMO_STREAM def head_up ( self ) -> None : \"\"\"Raise up the test head.\"\"\" self . command ( 'HEAD 0' ) def head_down ( self ) -> None : \"\"\"Lower down the test head.\"\"\" self . command ( 'HEAD 1' ) def is_head_down ( self ) -> bool : \"\"\"Queries if the test head is lowered down. Returns: If the test head is lowered down. \"\"\" is_down = bool ( int ( self . query ( 'HEAD?' ))) return is_down def flow ( self , on : bool = True ) -> None : \"\"\"Turn the main nozzle air flow on or off. Args: on: `True` = turn on, `False` = turn off. \"\"\" cmd = 'FLOW {:d} ' . format ( on ) self . command ( cmd ) def enable_dut_mode ( self , en : bool = True ) -> None : \"\"\"Enable (disable) DUT mode. Args: en: True = DUT mode on (DUT control); False = DUT mode off (air control). \"\"\" if not isinstance ( en , bool ): raise TypeError ( 'Parameter en must be bool type.' ) cmd = 'DUTM {en:d} ' . format ( en = en ) self . command ( cmd ) def is_dut_mode ( self ) -> bool : \"\"\"Queries if DUT mode is on. Returns: True = DUT mode on (DUT control); False = DUT mode off (air control). \"\"\" state = bool ( int ( self . query ( 'DUTM?' ))) return state def disable_dut_mode ( self ) -> None : \"\"\"Disable DUT mode.\"\"\" self . enable_dut_mode ( False ) def reset_operator ( self ) -> None : \"\"\"Reset (force) the System to the Operator screen.\"\"\" self . command ( 'RSTO' ) time . sleep ( 0.3 ) def set_ramp ( self ) -> None : \"\"\"Enter Ramp/Cycle.\"\"\" self . command ( 'RMPC 1' ) def set_n ( self , n : int ) -> None : \"\"\"Select a setpoint to be the current setpoint. Args: n: - n is 0 - 17 when on the Cycle screen. - n is 0 to 2 when on the Operator screen (0=hot, 1=ambient, 2=cold). \"\"\" return self . command ( 'SETN %d ' % n ) def set_p ( self , p : int | float ) -> None : \"\"\"Set the currently selected setpoint's temperature.\"\"\" return self . command ( 'SETP %.1f ' % p ) def get_p_setting ( self ) -> float : \"\"\"Read the current temperature setpoint.\"\"\" p = float ( self . query ( 'SETP?' )) return p def set_ramp ( self , ramp : int | float ) -> None : \"\"\"Set the ramp rate for the currently selected setpoint, in \u00b0C per minute. Args: ramp: The ramp rate in \u00b0C per minute. \"\"\" if 0 <= ramp <= 99.9 : t = ' {:.1f} ' . format ( ramp ) elif 99.9 < ramp <= 9999 : t = ' {:d} ' . format ( ramp ) else : raise ValueError ( 'Parameter ramp out of range.' ) return self . command ( 'RAMP {} ' . format ( t )) def get_ramp ( self ) -> float : \"\"\"Read the setting of RAMP. Returns: The ramp rate in \u00b0C per minute. \"\"\" cmd = 'RAMP?' ramp = float ( self . query ( cmd )) return ramp def set_target_temp ( self , value : int | float ) -> None : if value < 20 : n = 2 elif 20 <= value <= 30 : n = 1 else : n = 0 self . set_n ( n ) self . set_p ( value ) def get_target_temp ( self ) -> float : return self . get_p_setting () def get_current_temp ( self ) -> float : temp = float ( self . query ( 'TEMP?' )) if temp > 400 : raise ValueError ( 'Invalid current temperature.' ) return temp def set_temp_unit ( self , unit : TemperatureUnit ) -> None : if unit != TemperatureUnit . C : raise ValueError ( 'The temperature unit of this thermo-stream is fixed to C.' ) def get_temp_unit ( self ) -> TemperatureUnit : return TemperatureUnit . C","title":"ModelATS535"},{"location":"api/models/#pyinst.models.ModelATS535.__init__","text":"Parameters: Name Type Description Default resource_name Resource name or alias of the VISA resource to open. required **kwargs directly passed to VisaInstrument.__init__ {} Source code in pyinst\\models.py 3777 3778 3779 3780 3781 3782 3783 def __init__ ( self , resource_name , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. **kwargs: directly passed to `VisaInstrument.__init__` \"\"\" super ( ModelATS535 , self ) . __init__ ( resource_name , ** kwargs )","title":"__init__()"},{"location":"api/models/#pyinst.models.ModelATS535.disable_dut_mode","text":"Disable DUT mode. Source code in pyinst\\models.py 3835 3836 3837 def disable_dut_mode ( self ) -> None : \"\"\"Disable DUT mode.\"\"\" self . enable_dut_mode ( False )","title":"disable_dut_mode()"},{"location":"api/models/#pyinst.models.ModelATS535.enable_dut_mode","text":"Enable (disable) DUT mode. Parameters: Name Type Description Default en bool True = DUT mode on (DUT control); False = DUT mode off (air control). True Source code in pyinst\\models.py 3815 3816 3817 3818 3819 3820 3821 3822 3823 3824 def enable_dut_mode ( self , en : bool = True ) -> None : \"\"\"Enable (disable) DUT mode. Args: en: True = DUT mode on (DUT control); False = DUT mode off (air control). \"\"\" if not isinstance ( en , bool ): raise TypeError ( 'Parameter en must be bool type.' ) cmd = 'DUTM {en:d} ' . format ( en = en ) self . command ( cmd )","title":"enable_dut_mode()"},{"location":"api/models/#pyinst.models.ModelATS535.flow","text":"Turn the main nozzle air flow on or off. Parameters: Name Type Description Default on bool True = turn on, False = turn off. True Source code in pyinst\\models.py 3806 3807 3808 3809 3810 3811 3812 3813 def flow ( self , on : bool = True ) -> None : \"\"\"Turn the main nozzle air flow on or off. Args: on: `True` = turn on, `False` = turn off. \"\"\" cmd = 'FLOW {:d} ' . format ( on ) self . command ( cmd )","title":"flow()"},{"location":"api/models/#pyinst.models.ModelATS535.get_p_setting","text":"Read the current temperature setpoint. Source code in pyinst\\models.py 3862 3863 3864 3865 def get_p_setting ( self ) -> float : \"\"\"Read the current temperature setpoint.\"\"\" p = float ( self . query ( 'SETP?' )) return p","title":"get_p_setting()"},{"location":"api/models/#pyinst.models.ModelATS535.get_ramp","text":"Read the setting of RAMP. Returns: Type Description float The ramp rate in \u00b0C per minute. Source code in pyinst\\models.py 3882 3883 3884 3885 3886 3887 3888 3889 3890 def get_ramp ( self ) -> float : \"\"\"Read the setting of RAMP. Returns: The ramp rate in \u00b0C per minute. \"\"\" cmd = 'RAMP?' ramp = float ( self . query ( cmd )) return ramp","title":"get_ramp()"},{"location":"api/models/#pyinst.models.ModelATS535.head_down","text":"Lower down the test head. Source code in pyinst\\models.py 3793 3794 3795 def head_down ( self ) -> None : \"\"\"Lower down the test head.\"\"\" self . command ( 'HEAD 1' )","title":"head_down()"},{"location":"api/models/#pyinst.models.ModelATS535.head_up","text":"Raise up the test head. Source code in pyinst\\models.py 3789 3790 3791 def head_up ( self ) -> None : \"\"\"Raise up the test head.\"\"\" self . command ( 'HEAD 0' )","title":"head_up()"},{"location":"api/models/#pyinst.models.ModelATS535.is_dut_mode","text":"Queries if DUT mode is on. Returns: Type Description bool True = DUT mode on (DUT control); False = DUT mode off (air control). Source code in pyinst\\models.py 3826 3827 3828 3829 3830 3831 3832 3833 def is_dut_mode ( self ) -> bool : \"\"\"Queries if DUT mode is on. Returns: True = DUT mode on (DUT control); False = DUT mode off (air control). \"\"\" state = bool ( int ( self . query ( 'DUTM?' ))) return state","title":"is_dut_mode()"},{"location":"api/models/#pyinst.models.ModelATS535.is_head_down","text":"Queries if the test head is lowered down. Returns: Type Description bool If the test head is lowered down. Source code in pyinst\\models.py 3797 3798 3799 3800 3801 3802 3803 3804 def is_head_down ( self ) -> bool : \"\"\"Queries if the test head is lowered down. Returns: If the test head is lowered down. \"\"\" is_down = bool ( int ( self . query ( 'HEAD?' ))) return is_down","title":"is_head_down()"},{"location":"api/models/#pyinst.models.ModelATS535.reset_operator","text":"Reset (force) the System to the Operator screen. Source code in pyinst\\models.py 3839 3840 3841 3842 def reset_operator ( self ) -> None : \"\"\"Reset (force) the System to the Operator screen.\"\"\" self . command ( 'RSTO' ) time . sleep ( 0.3 )","title":"reset_operator()"},{"location":"api/models/#pyinst.models.ModelATS535.set_n","text":"Select a setpoint to be the current setpoint. Parameters: Name Type Description Default n int n is 0 - 17 when on the Cycle screen. n is 0 to 2 when on the Operator screen (0=hot, 1=ambient, 2=cold). required Source code in pyinst\\models.py 3848 3849 3850 3851 3852 3853 3854 3855 3856 def set_n ( self , n : int ) -> None : \"\"\"Select a setpoint to be the current setpoint. Args: n: - n is 0 - 17 when on the Cycle screen. - n is 0 to 2 when on the Operator screen (0=hot, 1=ambient, 2=cold). \"\"\" return self . command ( 'SETN %d ' % n )","title":"set_n()"},{"location":"api/models/#pyinst.models.ModelATS535.set_p","text":"Set the currently selected setpoint's temperature. Source code in pyinst\\models.py 3858 3859 3860 def set_p ( self , p : int | float ) -> None : \"\"\"Set the currently selected setpoint's temperature.\"\"\" return self . command ( 'SETP %.1f ' % p )","title":"set_p()"},{"location":"api/models/#pyinst.models.ModelATS535.set_ramp","text":"Set the ramp rate for the currently selected setpoint, in \u00b0C per minute. Parameters: Name Type Description Default ramp int | float The ramp rate in \u00b0C per minute. required Source code in pyinst\\models.py 3867 3868 3869 3870 3871 3872 3873 3874 3875 3876 3877 3878 3879 3880 def set_ramp ( self , ramp : int | float ) -> None : \"\"\"Set the ramp rate for the currently selected setpoint, in \u00b0C per minute. Args: ramp: The ramp rate in \u00b0C per minute. \"\"\" if 0 <= ramp <= 99.9 : t = ' {:.1f} ' . format ( ramp ) elif 99.9 < ramp <= 9999 : t = ' {:d} ' . format ( ramp ) else : raise ValueError ( 'Parameter ramp out of range.' ) return self . command ( 'RAMP {} ' . format ( t ))","title":"set_ramp()"},{"location":"api/models/#pyinst.models.ModelE3631A","text":"Bases: VisaInstrument , TypePS Source code in pyinst\\models.py 4566 4567 4568 4569 4570 4571 4572 4573 4574 4575 4576 4577 4578 4579 4580 4581 4582 4583 4584 4585 4586 4587 4588 4589 4590 4591 4592 4593 4594 4595 4596 4597 4598 4599 4600 4601 4602 4603 4604 4605 4606 4607 4608 4609 4610 4611 4612 4613 4614 4615 4616 4617 4618 4619 4620 4621 4622 4623 4624 4625 4626 4627 4628 4629 4630 4631 4632 4633 4634 4635 4636 4637 4638 4639 4640 4641 4642 4643 4644 4645 4646 4647 4648 4649 4650 4651 4652 4653 4654 4655 4656 4657 4658 4659 4660 4661 4662 4663 4664 4665 4666 4667 4668 4669 4670 4671 4672 4673 4674 4675 4676 4677 4678 4679 4680 4681 4682 4683 4684 4685 4686 4687 4688 4689 4690 4691 4692 class ModelE3631A ( VisaInstrument , TypePS ): model = \"E3631A\" brand = \"Keysight\" details = { \"Power Supply Range\" : \"Port 1: 6V, 5A; Port 2: 25V, 1A; Port 3: -25V, 1A\" } params = [ { \"name\" : \"port\" , \"type\" : \"int\" , \"options\" : [ 1 , 2 , 3 ] } ] def __init__ ( self , resource_name : str , port : int , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. port: The port number among three output ports. - `1`: +6V - `2`: +25V - `3`: -25V kwargs: directly passed to `VisaInstrument.__init__`. \"\"\" super () . __init__ ( resource_name , ** kwargs ) if port not in { 1 , 2 , 3 }: raise ValueError ( f \"Invalid parameter port: { port !r} \" ) self . __port = port def __select_port ( func : Callable ) -> Callable : @wraps ( func ) def wrapper ( self , * args , ** kwargs ): cmd = f \":INSTrument:NSELect { self . port : d } \" self . command ( cmd ) return func ( self , * args , ** kwargs ) return wrapper @property def port ( self ): \"\"\"The selected port number among three output ports.\"\"\" return self . __port @property @__select_port def min_voltage ( self ): cmd = \":VOLTage? MIN\" v = float ( self . query ( cmd )) return v @property @__select_port def max_voltage ( self ): cmd = \":VOLTage? MAX\" v = float ( self . query ( cmd )) return v @property @__select_port def min_current ( self ): cmd = \":CURRent? MIN\" i = float ( self . query ( cmd )) return i @property @__select_port def max_current ( self ): cmd = \":CURRent? MAX\" i = float ( self . query ( cmd )) return i @__select_port def enable ( self , en : bool = True ) -> None : if not isinstance ( en , bool ): raise TypeError ( 'Parameter en must be bool type.' ) cmd = f ':OUTPut { [ \"OFF\" , \"ON\" ][ int ( en )] } ' self . command ( cmd ) def disable ( self ) -> None : self . enable ( False ) @__select_port def is_enabled ( self ) -> bool : cmd = \":OUTPut?\" status = bool ( int ( self . query ( cmd ))) return status @__select_port def set_voltage_limit ( self , value : int | float ) -> None : if not 0 <= value <= self . max_voltage : raise ValueError ( f \"The voltage limit value out of range: { value !r} \" ) cmd = f \":VOLTage { value : .4f } \" self . command ( cmd ) @__select_port def get_voltage_limit ( self ) -> float : cmd = \":VOLTage?\" v = float ( self . query ( cmd )) return v @__select_port def measure_voltage ( self ) -> float : cmd = \":MEASure:VOLTage?\" v = float ( self . query ( cmd )) return v @__select_port def set_current_limit ( self , value : int | float ) -> None : if not 0 <= value <= self . max_current : raise ValueError ( f \"The current limit value out of range: { value !r} \" ) cmd = f \":CURRent { value : .4f } \" self . command ( cmd ) @__select_port def get_current_limit ( self ) -> float : cmd = \":CURRent?\" i = float ( self . command ( cmd )) return i @__select_port def measure_current ( self ) -> float : cmd = \":MEASure:CURRent?\" i = float ( self . command ( cmd )) return i","title":"ModelE3631A"},{"location":"api/models/#pyinst.models.ModelE3631A.__init__","text":"Parameters: Name Type Description Default resource_name str Resource name or alias of the VISA resource to open. required port int The port number among three output ports. - 1 : +6V - 2 : +25V - 3 : -25V required kwargs directly passed to VisaInstrument.__init__ . required Source code in pyinst\\models.py 4584 4585 4586 4587 4588 4589 4590 4591 4592 4593 4594 4595 4596 4597 def __init__ ( self , resource_name : str , port : int , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. port: The port number among three output ports. - `1`: +6V - `2`: +25V - `3`: -25V kwargs: directly passed to `VisaInstrument.__init__`. \"\"\" super () . __init__ ( resource_name , ** kwargs ) if port not in { 1 , 2 , 3 }: raise ValueError ( f \"Invalid parameter port: { port !r} \" ) self . __port = port","title":"__init__()"},{"location":"api/models/#pyinst.models.ModelE3631A.port","text":"The selected port number among three output ports. Source code in pyinst\\models.py 4607 4608 4609 4610 @property def port ( self ): \"\"\"The selected port number among three output ports.\"\"\" return self . __port","title":"port()"},{"location":"api/models/#pyinst.models.ModelE3633A","text":"Bases: VisaInstrument , TypePSwithOvpOcpFunctions Source code in pyinst\\models.py 4695 4696 4697 4698 4699 4700 4701 4702 4703 4704 4705 4706 4707 4708 4709 4710 4711 4712 4713 4714 4715 4716 4717 4718 4719 4720 4721 4722 4723 4724 4725 4726 4727 4728 4729 4730 4731 4732 4733 4734 4735 4736 4737 4738 4739 4740 4741 4742 4743 4744 4745 4746 4747 4748 4749 4750 4751 4752 4753 4754 4755 4756 4757 4758 4759 4760 4761 4762 4763 4764 4765 4766 4767 4768 4769 4770 4771 4772 4773 4774 4775 4776 4777 4778 4779 4780 4781 4782 4783 4784 4785 4786 4787 4788 4789 4790 4791 4792 4793 4794 4795 4796 4797 4798 4799 4800 4801 4802 4803 4804 4805 4806 4807 4808 4809 4810 4811 4812 4813 4814 4815 4816 4817 4818 4819 4820 4821 4822 4823 4824 4825 4826 4827 4828 4829 4830 4831 4832 4833 4834 4835 4836 4837 4838 4839 4840 4841 4842 4843 4844 4845 4846 4847 4848 4849 4850 4851 4852 4853 4854 4855 4856 4857 4858 4859 4860 4861 4862 4863 4864 4865 4866 4867 4868 4869 class ModelE3633A ( VisaInstrument , TypePSwithOvpOcpFunctions ): model = \"E3633A\" brand = \"Keysight\" details = { \"Power Supply Range\" : \"20 V, 10 A | 8 V, 20 A\" } def __init__ ( self , resource_name : str , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. kwargs: directly passed to `VisaInstrument.__init__`. \"\"\" super () . __init__ ( resource_name , ** kwargs ) def set_output_range ( self , option : str ) -> None : \"\"\"Selects an output range to be programmed. Note: For model E3633A, the programming ranges are: - LOW: 0 V to 8.24 V, 0 A to 20.60 A - HIGH: 0 V to 20.60 V, 0 A to 10.30 A Args: option: `\"LOW\"` | `\"HIGH\"` \"\"\" cmd = f \":VOLTage:RANGe { option } \" self . command ( cmd ) def get_output_range ( self ) -> str : \"\"\"Queries current selected output range. Please refer to `set_output_range()` for more information. Returns: `\"LOW\"` | `\"HIGH\"` \"\"\" @property def min_voltage ( self ): cmd = \":VOLTage? MIN\" v = float ( self . query ( cmd )) return v @property def max_voltage ( self ): cmd = \":VOLTage? MAX\" v = float ( self . query ( cmd )) return v @property def min_current ( self ): cmd = \":CURRent? MIN\" i = float ( self . query ( cmd )) return i @property def max_current ( self ): cmd = \":CURRent? MAX\" i = float ( self . query ( cmd )) return i def enable ( self , en : bool = True ) -> None : if not isinstance ( en , bool ): raise TypeError ( 'Parameter en must be bool type.' ) cmd = f ':OUTPut { [ \"OFF\" , \"ON\" ][ int ( en )] } ' self . command ( cmd ) def disable ( self ) -> None : self . enable ( False ) def is_enabled ( self ) -> bool : cmd = \":OUTPut?\" status = bool ( int ( self . query ( cmd ))) return status def set_voltage_limit ( self , value : int | float ) -> None : if not 0 <= value <= self . max_voltage : raise ValueError ( f \"The voltage limit value out of range: { value !r} \" ) cmd = f \":VOLTage { value : .4f } \" self . command ( cmd ) def get_voltage_limit ( self ) -> float : cmd = \":VOLTage?\" v = float ( self . query ( cmd )) return v def measure_voltage ( self ) -> float : cmd = \":MEASure:VOLTage?\" v = float ( self . query ( cmd )) return v def set_current_limit ( self , value : int | float ) -> None : if not 0 <= value <= self . max_current : raise ValueError ( f \"The current limit value out of range: { value !r} \" ) cmd = f \":CURRent { value : .4f } \" self . command ( cmd ) def get_current_limit ( self ) -> float : cmd = \":CURRent?\" i = float ( self . command ( cmd )) return i def measure_current ( self ) -> float : cmd = \":MEASure:CURRent?\" i = float ( self . command ( cmd )) return i def set_ocp_level ( self , level : int | float ) -> None : cmd = f \":CURRent:PROTection { level : .4f } \" self . command ( cmd ) def get_ocp_level ( self ) -> float : cmd = f \":CURRent:PROTection?\" ocp = float ( self . query ( cmd )) return ocp def enable_ocp ( self , enable : bool = True ) -> None : if not isinstance ( enable , bool ): raise TypeError ( \"Parameter enable must be bool type.\" ) cmd = f \":CURRent:PROTection:STATe { enable : d } \" self . command ( cmd ) def disable_ocp ( self ) -> None : self . enable_ocp ( False ) def is_ocp_enabled ( self ) -> bool : cmd = \":CURRent:PROTection:STATe?\" enabled = bool ( int ( self . query ( cmd ))) return enabled def is_ocp_tripped ( self ) -> bool : cmd = \":CURRent:PROTection:TRIPped?\" tripped = bool ( int ( self . query ( cmd ))) return tripped def clear_ocp ( self ) -> None : cmd = \":CURRent:PROTection:CLEar\" self . command ( cmd ) def set_ovp_level ( self , level : int | float ) -> None : cmd = f \":VOLTage:PROTection { level : .4f } \" self . command ( cmd ) def get_ovp_level ( self ) -> float : cmd = \":VOLTage:PROTection?\" ovp = float ( self . query ( cmd )) return ovp def enable_ovp ( self , enable : bool = True ) -> None : if not isinstance ( enable , bool ): raise TypeError ( \"Parameter enable must be bool type.\" ) cmd = f \":VOLTage:PROTection:STATe { enable : d } \" self . command ( cmd ) def disable_ovp ( self ) -> None : self . enable_ovp ( False ) def is_ovp_enabled ( self ) -> bool : cmd = \":VOLTage:PROTection:STATe?\" enabled = bool ( int ( self . query ( cmd ))) return enabled def is_ovp_tripped ( self ) -> bool : cmd = \":VOLTage:PROTection:TRIPped?\" tripped = bool ( int ( self . query ( cmd ))) return tripped def clear_ovp ( self ) -> None : cmd = \":VOLTage:PROTection:CLEar\" self . command ( cmd )","title":"ModelE3633A"},{"location":"api/models/#pyinst.models.ModelE3633A.__init__","text":"Parameters: Name Type Description Default resource_name str Resource name or alias of the VISA resource to open. required kwargs directly passed to VisaInstrument.__init__ . required Source code in pyinst\\models.py 4705 4706 4707 4708 4709 4710 4711 def __init__ ( self , resource_name : str , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. kwargs: directly passed to `VisaInstrument.__init__`. \"\"\" super () . __init__ ( resource_name , ** kwargs )","title":"__init__()"},{"location":"api/models/#pyinst.models.ModelE3633A.get_output_range","text":"Queries current selected output range. Please refer to set_output_range() for more information. Returns: Type Description str \"LOW\" | \"HIGH\" Source code in pyinst\\models.py 4728 4729 4730 4731 4732 4733 4734 4735 def get_output_range ( self ) -> str : \"\"\"Queries current selected output range. Please refer to `set_output_range()` for more information. Returns: `\"LOW\"` | `\"HIGH\"` \"\"\"","title":"get_output_range()"},{"location":"api/models/#pyinst.models.ModelE3633A.set_output_range","text":"Selects an output range to be programmed. Note For model E3633A, the programming ranges are: LOW: 0 V to 8.24 V, 0 A to 20.60 A HIGH: 0 V to 20.60 V, 0 A to 10.30 A Parameters: Name Type Description Default option str \"LOW\" | \"HIGH\" required Source code in pyinst\\models.py 4713 4714 4715 4716 4717 4718 4719 4720 4721 4722 4723 4724 4725 4726 def set_output_range ( self , option : str ) -> None : \"\"\"Selects an output range to be programmed. Note: For model E3633A, the programming ranges are: - LOW: 0 V to 8.24 V, 0 A to 20.60 A - HIGH: 0 V to 20.60 V, 0 A to 10.30 A Args: option: `\"LOW\"` | `\"HIGH\"` \"\"\" cmd = f \":VOLTage:RANGe { option } \" self . command ( cmd )","title":"set_output_range()"},{"location":"api/models/#pyinst.models.ModelEPS1000","text":"Bases: BaseInstrument , TypePOLC Source code in pyinst\\models.py 5426 5427 5428 5429 5430 5431 5432 5433 5434 5435 5436 5437 5438 5439 5440 5441 5442 5443 5444 5445 5446 5447 5448 5449 5450 5451 5452 5453 5454 5455 5456 5457 5458 5459 5460 5461 5462 5463 5464 5465 5466 5467 5468 5469 5470 5471 5472 5473 5474 5475 5476 5477 5478 5479 5480 5481 5482 5483 5484 5485 5486 5487 5488 5489 5490 5491 5492 5493 5494 5495 5496 5497 5498 5499 5500 5501 5502 5503 5504 5505 5506 5507 5508 5509 5510 5511 5512 5513 5514 5515 5516 5517 5518 5519 5520 5521 5522 5523 5524 5525 5526 5527 5528 5529 5530 5531 5532 5533 5534 5535 5536 5537 5538 5539 5540 5541 5542 5543 5544 5545 5546 5547 5548 5549 5550 5551 5552 5553 5554 5555 5556 5557 5558 5559 5560 5561 5562 5563 5564 5565 5566 5567 5568 5569 5570 5571 5572 5573 5574 5575 5576 5577 5578 5579 5580 5581 5582 5583 5584 5585 5586 5587 5588 5589 5590 5591 5592 5593 5594 5595 5596 5597 5598 5599 5600 5601 5602 5603 5604 5605 5606 5607 5608 5609 5610 5611 5612 5613 5614 5615 5616 5617 5618 5619 5620 5621 5622 5623 5624 5625 5626 5627 5628 5629 5630 5631 5632 5633 5634 5635 5636 5637 5638 class ModelEPS1000 ( BaseInstrument , TypePOLC ): model = \"EPS1000\" brand = \"Novoptel\" details = { \"Wavelength Range\" : \"1510.3-1639.1 nm\" , \"Frequency Range\" : \"182.9-198.5 THz\" , \"Insertion loss\" : \"1.5-3 dB\" , \"Peaked Rate\" : \"0-20,000,000 rad/s\" , \"Rayleigh Rate\" : \"0-10,000,000 rad/s\" } def __init__ ( self , resource_name : str , timeout = 3 , ** kwargs ): super () . __init__ ( resource_name , ** kwargs ) baudrate = 230400 device_list = ftd . listDevices () for i in range ( len ( device_list )): desc = ftd . getDeviceInfoDetail ( i )[ \"description\" ] . decode () if desc . startswith ( 'EPS1000' ): sn = desc . split ()[ - 1 ] else : continue if resource_name . endswith ( sn ): self . __device_num = i break else : raise ValueError ( 'Device not found: {model} | S/N: {sn} ' . format ( model = self . model , sn = resource_name )) self . __device = ftd . open ( self . __device_num ) self . __device . setBaudRate ( baudrate ) self . __device . setDataCharacteristics ( 8 , 0 , 0 ) self . __device . setTimeouts ( round ( timeout * 1000 ), round ( timeout * 1000 )) self . __connected = True @property def min_frequency ( self ) -> float : return super () . min_frequency @property def max_frequency ( self ) -> float : return super () . max_frequency @property def min_wavelength ( self ) -> float : return 1510.3 @property def max_wavelength ( self ) -> float : return 1639.1 def close ( self ) -> None : self . __device . close () self . __connected = False # def check_connection(self): # return self.__connected def __write_register ( self , addr , data ): if not self . __connected : raise ValueError ( 'Device is closed. Please connect first.' ) time . sleep ( 0.01 ) write_str = 'W' + ' {:03X} ' . format ( addr ) + ' {:04X} ' . format ( data ) + chr ( 13 ) write_str_c = ctypes . create_string_buffer ( write_str . encode ( 'utf-8' ), 9 ) self . __device . write ( write_str_c ) def __read_register ( self , addr ): if not self . __connected : raise ValueError ( 'Device is closed. Please connect first.' ) self . __device . purge () # clear buffer time . sleep ( 0.01 ) # send request read_request = 'R' + ' {:03X} ' . format ( addr ) + '0000' + chr ( 13 ) read_request_c = ctypes . create_string_buffer ( read_request . encode ( 'utf-8' ), 9 ) self . __device . write ( read_request_c ) # wait response bytesavailable = 0 tries = 0 while bytesavailable < 5 and tries < 1000 : bytesavailable = self . __device . getQueueStatus () tries += 1 time . sleep ( 0.001 ) # get responce res = self . __device . read ( bytesavailable ) # return responce as integer if bytesavailable > 4 : value = int ( res . decode ( \"utf-8\" ), 16 ) else : raise ValueError ( 'Invalid response from ' ) return value def set_qwp ( self , qwp_n , direction , speed ): \"\"\" qwp_n = 0, 1, 2, 3, 4, 5 direction = 0(Disabled), 1(Forward), -1(Backward) speed = (rad/s) \"\"\" control_reg_addr = qwp_n + 1 speed_reg_addr0 = qwp_n * 2 + 11 speed_reg_addr1 = qwp_n * 2 + 12 if direction == 0 : self . __write_register ( control_reg_addr , 0 ) elif direction == 1 : self . __write_register ( control_reg_addr , 1 ) elif direction == - 1 : self . __write_register ( control_reg_addr , 3 ) else : raise ValueError ( 'Invalid value for direction: {} . Options: 0(Disabled), 1(Forward), -1(Backward)' . format ( direction )) speed_msb = int (( speed * 100 ) / ( 2 ** 16 )) & 0xffff speed_lsb = int (( speed * 100 )) & 0xffff self . __write_register ( speed_reg_addr0 , speed_lsb ) self . __write_register ( speed_reg_addr1 , speed_msb ) def set_hwp ( self , direction , speed ): \"\"\" direction = 0(Disabled), 1(Forward), -1(Backward) speed = (krad/s) \"\"\" control_reg_addr = 0 speed_reg_addr0 = 9 speed_reg_addr1 = 10 if direction == 0 : self . __write_register ( control_reg_addr , 0 ) elif direction == 1 : self . __write_register ( control_reg_addr , 1 ) elif direction == - 1 : self . __write_register ( control_reg_addr , 3 ) else : raise ValueError ( 'Invalid value for direction: {} . Options: 0(Disabled), 1(Forward), -1(Backward)' . format ( direction )) speed_msb = int (( speed * 100 ) / ( 2 ** 16 )) & 0xffff speed_lsb = int (( speed * 100 )) & 0xffff self . __write_register ( speed_reg_addr0 , speed_lsb ) self . __write_register ( speed_reg_addr1 , speed_msb ) def get_frequency ( self ) -> float : value = int ( self . read_register ( addr = 25 )) freq = ( value + 1828 ) / 10 return freq def set_frequency ( self , frequency : int | float ) -> None : value = round ( frequency * 10 - 1828 ) self . write_register ( addr = 25 , data = value ) time . sleep ( 0.1 ) def get_wavelength ( self ) -> float : return super () . get_wavelength () def set_wavelength ( self , wavelength : int | float ) -> None : return super () . set_wavelength ( wavelength ) def start_scrambling ( self , mode : str , rate : int | float , ** params ) -> None : ''' speed unit: rad/s when mode is 'Peaked', the max rate is 2000000rad/s when mode is 'Rayleigh', the max rate is 1000000rad/s when mode is 'Marvell', the unit is rad/s ''' speed = rate if mode == 'Peaked' : if 0 <= speed <= 20000000 : speed_10 = round ( speed / 10 ) lsb = speed_10 & 0xFFFF msb = ( 2 << 14 ) | ( speed_10 >> 16 ) self . write_register ( addr = 23 , data = lsb ) self . write_register ( addr = 24 , data = msb ) else : raise ValueError ( \"Speed is out of range, the max speed of 'Peaked' mode is 2000000rad/s\" ) elif mode == 'Rayleigh' : if 0 <= speed <= 10000000 : speed_10 = round ( speed / 10 ) lsb = speed_10 & 0xFFFF msb = ( 3 << 14 ) | ( speed_10 >> 16 ) self . write_register ( addr = 23 , data = lsb ) self . write_register ( addr = 24 , data = msb ) else : raise ValueError ( \"Speed is out of range, the max speed of 'Rayleigh' mode is 1000000rad/s\" ) elif mode == 'Marvell' : self . stop_scrambling () self . write_register ( addr = 23 , data = 0 ) self . write_register ( addr = 24 , data = 0 ) time . sleep ( 0.1 ) qwp_speed = speed / 6 offset = 0.02 self . set_qwp ( qwp_n = 0 , direction = 1 , speed = qwp_speed * ( 1.0 + offset )) self . set_qwp ( qwp_n = 1 , direction =- 1 , speed = qwp_speed * ( 1.0 - offset )) self . set_qwp ( qwp_n = 2 , direction = 1 , speed = qwp_speed * ( 1.0 + offset )) self . set_hwp ( direction =- 1 , speed = 0.01 ) # -1 is backward. 0.01 could be just rad/s self . set_qwp ( qwp_n = 3 , direction =- 1 , speed = qwp_speed * ( 1.0 - offset )) self . set_qwp ( qwp_n = 4 , direction = 1 , speed = qwp_speed * ( 1.0 + offset )) self . set_qwp ( qwp_n = 5 , direction =- 1 , speed = qwp_speed * ( 1.0 - offset )) if qwp_speed < 10 : self . set_hwp ( direction = 0 , speed = 0 ) def stop_scrambling ( self ) -> None : self . start_scrambling ( 'Peaked' , 0 )","title":"ModelEPS1000"},{"location":"api/models/#pyinst.models.ModelEPS1000.set_hwp","text":"direction = 0(Disabled), 1(Forward), -1(Backward) speed = (krad/s) Source code in pyinst\\models.py 5549 5550 5551 5552 5553 5554 5555 5556 5557 5558 5559 5560 5561 5562 5563 5564 5565 5566 5567 5568 5569 5570 5571 5572 5573 def set_hwp ( self , direction , speed ): \"\"\" direction = 0(Disabled), 1(Forward), -1(Backward) speed = (krad/s) \"\"\" control_reg_addr = 0 speed_reg_addr0 = 9 speed_reg_addr1 = 10 if direction == 0 : self . __write_register ( control_reg_addr , 0 ) elif direction == 1 : self . __write_register ( control_reg_addr , 1 ) elif direction == - 1 : self . __write_register ( control_reg_addr , 3 ) else : raise ValueError ( 'Invalid value for direction: {} . Options: 0(Disabled), 1(Forward), -1(Backward)' . format ( direction )) speed_msb = int (( speed * 100 ) / ( 2 ** 16 )) & 0xffff speed_lsb = int (( speed * 100 )) & 0xffff self . __write_register ( speed_reg_addr0 , speed_lsb ) self . __write_register ( speed_reg_addr1 , speed_msb )","title":"set_hwp()"},{"location":"api/models/#pyinst.models.ModelEPS1000.set_qwp","text":"qwp_n = 0, 1, 2, 3, 4, 5 direction = 0(Disabled), 1(Forward), -1(Backward) speed = (rad/s) Source code in pyinst\\models.py 5524 5525 5526 5527 5528 5529 5530 5531 5532 5533 5534 5535 5536 5537 5538 5539 5540 5541 5542 5543 5544 5545 5546 5547 def set_qwp ( self , qwp_n , direction , speed ): \"\"\" qwp_n = 0, 1, 2, 3, 4, 5 direction = 0(Disabled), 1(Forward), -1(Backward) speed = (rad/s) \"\"\" control_reg_addr = qwp_n + 1 speed_reg_addr0 = qwp_n * 2 + 11 speed_reg_addr1 = qwp_n * 2 + 12 if direction == 0 : self . __write_register ( control_reg_addr , 0 ) elif direction == 1 : self . __write_register ( control_reg_addr , 1 ) elif direction == - 1 : self . __write_register ( control_reg_addr , 3 ) else : raise ValueError ( 'Invalid value for direction: {} . Options: 0(Disabled), 1(Forward), -1(Backward)' . format ( direction )) speed_msb = int (( speed * 100 ) / ( 2 ** 16 )) & 0xffff speed_lsb = int (( speed * 100 )) & 0xffff self . __write_register ( speed_reg_addr0 , speed_lsb ) self . __write_register ( speed_reg_addr1 , speed_msb )","title":"set_qwp()"},{"location":"api/models/#pyinst.models.ModelEPS1000.start_scrambling","text":"speed unit: rad/s when mode is 'Peaked', the max rate is 2000000rad/s when mode is 'Rayleigh', the max rate is 1000000rad/s when mode is 'Marvell', the unit is rad/s Source code in pyinst\\models.py 5591 5592 5593 5594 5595 5596 5597 5598 5599 5600 5601 5602 5603 5604 5605 5606 5607 5608 5609 5610 5611 5612 5613 5614 5615 5616 5617 5618 5619 5620 5621 5622 5623 5624 5625 5626 5627 5628 5629 5630 5631 5632 5633 5634 5635 def start_scrambling ( self , mode : str , rate : int | float , ** params ) -> None : ''' speed unit: rad/s when mode is 'Peaked', the max rate is 2000000rad/s when mode is 'Rayleigh', the max rate is 1000000rad/s when mode is 'Marvell', the unit is rad/s ''' speed = rate if mode == 'Peaked' : if 0 <= speed <= 20000000 : speed_10 = round ( speed / 10 ) lsb = speed_10 & 0xFFFF msb = ( 2 << 14 ) | ( speed_10 >> 16 ) self . write_register ( addr = 23 , data = lsb ) self . write_register ( addr = 24 , data = msb ) else : raise ValueError ( \"Speed is out of range, the max speed of 'Peaked' mode is 2000000rad/s\" ) elif mode == 'Rayleigh' : if 0 <= speed <= 10000000 : speed_10 = round ( speed / 10 ) lsb = speed_10 & 0xFFFF msb = ( 3 << 14 ) | ( speed_10 >> 16 ) self . write_register ( addr = 23 , data = lsb ) self . write_register ( addr = 24 , data = msb ) else : raise ValueError ( \"Speed is out of range, the max speed of 'Rayleigh' mode is 1000000rad/s\" ) elif mode == 'Marvell' : self . stop_scrambling () self . write_register ( addr = 23 , data = 0 ) self . write_register ( addr = 24 , data = 0 ) time . sleep ( 0.1 ) qwp_speed = speed / 6 offset = 0.02 self . set_qwp ( qwp_n = 0 , direction = 1 , speed = qwp_speed * ( 1.0 + offset )) self . set_qwp ( qwp_n = 1 , direction =- 1 , speed = qwp_speed * ( 1.0 - offset )) self . set_qwp ( qwp_n = 2 , direction = 1 , speed = qwp_speed * ( 1.0 + offset )) self . set_hwp ( direction =- 1 , speed = 0.01 ) # -1 is backward. 0.01 could be just rad/s self . set_qwp ( qwp_n = 3 , direction =- 1 , speed = qwp_speed * ( 1.0 - offset )) self . set_qwp ( qwp_n = 4 , direction = 1 , speed = qwp_speed * ( 1.0 + offset )) self . set_qwp ( qwp_n = 5 , direction =- 1 , speed = qwp_speed * ( 1.0 - offset )) if qwp_speed < 10 : self . set_hwp ( direction = 0 , speed = 0 )","title":"start_scrambling()"},{"location":"api/models/#pyinst.models.ModelM8292A","text":"Bases: BaseModelVSA89600_OMA M8290A Optical Modulation Analyzer Source code in pyinst\\models.py 2332 2333 2334 2335 2336 2337 2338 2339 2340 2341 2342 2343 2344 2345 2346 2347 2348 2349 2350 2351 2352 2353 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 2366 class ModelM8292A ( BaseModelVSA89600_OMA ): \"\"\"M8290A Optical Modulation Analyzer\"\"\" model = \"M8292A\" brand = \"Keysight\" details = { \"Maximum detectable symbol rate\" : \"74 GBd\" , \"Optical frequency range\" : \"196.25 ~ 190.95 THz\" , \"Max signal input power\" : \"+14.5 dBm\" , \"External LO input power\" : \"+17 dBm\" , } def __init__ ( self , resource_name , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. kwargs: directly passed to `VisaInstrument.__init__`. \"\"\" super ( ModelM8292A , self ) . __init__ ( resource_name , ** kwargs ) @property def min_frequency ( self ) -> float : return 190.95 @property def max_frequency ( self ) -> float : return 196.25 @property def min_wavelength ( self ) -> float : return super () . min_wavelength @property def max_wavelength ( self ) -> float : return super () . max_wavelength","title":"ModelM8292A"},{"location":"api/models/#pyinst.models.ModelM8292A.__init__","text":"Parameters: Name Type Description Default resource_name Resource name or alias of the VISA resource to open. required kwargs directly passed to VisaInstrument.__init__ . required Source code in pyinst\\models.py 2344 2345 2346 2347 2348 2349 2350 def __init__ ( self , resource_name , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. kwargs: directly passed to `VisaInstrument.__init__`. \"\"\" super ( ModelM8292A , self ) . __init__ ( resource_name , ** kwargs )","title":"__init__()"},{"location":"api/models/#pyinst.models.ModelMAP_mOSX_C1","text":"Bases: VisaInstrument , TypeMSW mOSX-C1 is a optical matrix switch by VIAVI. Source code in pyinst\\models.py 4431 4432 4433 4434 4435 4436 4437 4438 4439 4440 4441 4442 4443 4444 4445 4446 4447 4448 4449 4450 4451 4452 4453 4454 4455 4456 4457 4458 4459 4460 4461 4462 4463 4464 4465 4466 4467 4468 4469 4470 4471 4472 4473 4474 4475 4476 4477 4478 4479 4480 4481 4482 4483 4484 4485 4486 4487 4488 4489 4490 4491 4492 4493 4494 4495 4496 4497 4498 4499 4500 4501 4502 4503 4504 4505 4506 4507 4508 4509 4510 4511 4512 4513 4514 4515 4516 4517 4518 4519 4520 4521 4522 4523 4524 4525 4526 4527 4528 4529 4530 4531 4532 4533 4534 4535 4536 4537 4538 4539 4540 4541 4542 4543 4544 4545 4546 4547 4548 4549 4550 4551 4552 4553 4554 4555 4556 4557 4558 4559 4560 4561 4562 4563 class ModelMAP_mOSX_C1 ( VisaInstrument , TypeMSW ): \"\"\"mOSX-C1 is a optical matrix switch by VIAVI.\"\"\" model = \"mOSX-C1\" brand = \"VIAVI\" details = { \"Wavelength Range\" : \"1260 ~ 1675 nm\" , \"Return Loss\" : \"> 50 dB\" , \"Switching Time\" : \"<= 25 ms\" , \"Insertion Loss\" : \"<= 1.5 dB\" , \"PDL\" : \"< 0.1 dB\" , } params = [ { \"name\" : \"slot\" , \"type\" : \"int\" , \"min\" : 1 , \"max\" : 8 , } ] def __init__ ( self , resource_name : str , slot : int , ** kwargs ) -> None : \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: The slot number in the frame. :kwargs: directly passed to `VisaInstrument.__init__`. \"\"\" super ( ModelMAP_mOSX_C1 , self ) . __init__ ( resource_name , ** kwargs ) self . __device = ' {slot:d} , {device} ' . format ( slot = slot , device = 1 ) def get_switch_topology ( self ) -> Tuple [ int , int ]: \"\"\" Returns the configured switch topology Returns: M: number of input ports N: number of output ports Notes: For common connection mode, M = total number of ports, N = 0. \"\"\" cmd = ':MODUle:TYPE? {device} ' . format ( device = self . __device ) rpl = self . query ( cmd ) config = tuple ( int ( i ) for i in rpl . split ( ',' )) return config def set_switch_topology ( self , n_in : int , n_out : int ) -> None : \"\"\" Sets the switch topology to emulate an MxN switch or common connection. All the channels will be cleared after topology changed. Args: n_in: Number of input ports (0 for common connection mode). n_out: Number of output ports (0 for common connection mode). \"\"\" cmd = ':MODUle:TYPe {device} , {n_in} , {n_out} ' . format ( device = self . __device , n_in = n_in , n_out = n_out ) self . command ( cmd ) def list_channels ( self ) -> List [ Tuple [ int , int , bool ]]: \"\"\" Returns a list of all configured connections and their status. Returns: All configured connections and their status. [(port1, port2, state), ...]. For state, False = Disabled, True = Enabled. \"\"\" cmd = ':ROUTe:LIST? {device} ' . format ( device = self . __device ) rpl = self . query ( cmd ) channels = [] for s in rpl . split ( ',' ): spl = s . split () port1 , port2 = ( int ( i ) for i in spl [ 0 ] . split ( '-' )) state = bool ( int ( spl [ 1 ])) channels . append (( port1 , port2 , state )) return channels def set_channel ( self , port1 : int , port2 : int , enable : bool = True ) -> None : m , n = self . get_switch_topology () if m == n : raise ValueError ( 'Invalid port value: please select 2 different ports. port1= {port1} , port2= {port2} ' . format ( port1 = port1 , port2 = port2 )) if n == 0 : if port1 > m or port2 > m : raise ValueError ( 'Invalid port value: exceed max port number {m} . port1= {port1} , port2= {port2} ' . format ( m = m , port1 = port1 , port2 = port2 )) else : if not ( port1 <= m ) ^ ( port2 <= m ): raise ValueError ( 'Invalid port value for {m} x {n} switch: port1= {port1} , port2= {port2} ' . format ( m = m , n = n , port1 = port1 , port2 = port2 )) cmd = ':ROUTe:CLOSe {device} , {port1:d} , {port2:d} , {state:d} ' . format ( device = self . __device , port1 = port1 , port2 = port2 , state = enable ) self . command ( cmd ) def get_connected_port ( self , port : int ) -> Optional [ int ]: cmd = ':ROUTe:CLOSe? {device} , {port:d} ' . format ( device = self . __device , port = port ) rpl = self . query ( cmd ) return int ( rpl ) or None def clear_channel ( self , port : int ) -> None : cmd = ':ROUTe:CLEAR {device} , {port:d} ' . format ( device = self . __device , port = port ) self . command ( cmd ) def clear_all_channels ( self ) -> None : cmd = ':ROUTe:CLEAR:ALL {device} ' . format ( device = self . __device ) self . command ( cmd ) def check_channel ( self , port1 : int , port2 : int ) -> bool : cmd = ':ROUTe:CHECK? {device} , {port1:d} , {port2:d} ' . format ( device = self . __device , port1 = port1 , port2 = port2 ) rpl = self . query ( cmd ) return bool ( int ( rpl )) def enable_channel ( self , port : int , enable : bool = True ) -> None : cmd = ':ROUTe:ENABle {device} , {port:d} , {state:d} ' . format ( device = self . __device , port = port , state = enable ) self . command ( cmd ) def disable_channel ( self , port : int ) -> None : return self . enable_channel ( port , enable = False ) def is_channel_enabled ( self , port : int ) -> bool : cmd = ':ROUTe:ENABle? {device} , {port:d} ' . format ( device = self . __device , port = port ) rpl = self . query ( cmd ) return bool ( int ( rpl ))","title":"ModelMAP_mOSX_C1"},{"location":"api/models/#pyinst.models.ModelMAP_mOSX_C1.__init__","text":"Parameters: Name Type Description Default resource_name str Resource name or alias of the VISA resource to open. required slot int The slot number in the frame. required kwargs: directly passed to VisaInstrument.__init__ . required Source code in pyinst\\models.py 4455 4456 4457 4458 4459 4460 4461 4462 4463 def __init__ ( self , resource_name : str , slot : int , ** kwargs ) -> None : \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: The slot number in the frame. :kwargs: directly passed to `VisaInstrument.__init__`. \"\"\" super ( ModelMAP_mOSX_C1 , self ) . __init__ ( resource_name , ** kwargs ) self . __device = ' {slot:d} , {device} ' . format ( slot = slot , device = 1 )","title":"__init__()"},{"location":"api/models/#pyinst.models.ModelMAP_mOSX_C1.get_switch_topology","text":"Returns the configured switch topology Returns: Name Type Description M int number of input ports N int number of output ports Notes For common connection mode, M = total number of ports, N = 0. Source code in pyinst\\models.py 4465 4466 4467 4468 4469 4470 4471 4472 4473 4474 4475 4476 4477 4478 4479 def get_switch_topology ( self ) -> Tuple [ int , int ]: \"\"\" Returns the configured switch topology Returns: M: number of input ports N: number of output ports Notes: For common connection mode, M = total number of ports, N = 0. \"\"\" cmd = ':MODUle:TYPE? {device} ' . format ( device = self . __device ) rpl = self . query ( cmd ) config = tuple ( int ( i ) for i in rpl . split ( ',' )) return config","title":"get_switch_topology()"},{"location":"api/models/#pyinst.models.ModelMAP_mOSX_C1.list_channels","text":"Returns a list of all configured connections and their status. Returns: Type Description List [ Tuple [ int , int , bool ]] All configured connections and their status. [(port1, port2, state), ...]. List [ Tuple [ int , int , bool ]] For state, False = Disabled, True = Enabled. Source code in pyinst\\models.py 4497 4498 4499 4500 4501 4502 4503 4504 4505 4506 4507 4508 4509 4510 4511 4512 4513 4514 def list_channels ( self ) -> List [ Tuple [ int , int , bool ]]: \"\"\" Returns a list of all configured connections and their status. Returns: All configured connections and their status. [(port1, port2, state), ...]. For state, False = Disabled, True = Enabled. \"\"\" cmd = ':ROUTe:LIST? {device} ' . format ( device = self . __device ) rpl = self . query ( cmd ) channels = [] for s in rpl . split ( ',' ): spl = s . split () port1 , port2 = ( int ( i ) for i in spl [ 0 ] . split ( '-' )) state = bool ( int ( spl [ 1 ])) channels . append (( port1 , port2 , state )) return channels","title":"list_channels()"},{"location":"api/models/#pyinst.models.ModelMAP_mOSX_C1.set_switch_topology","text":"Sets the switch topology to emulate an MxN switch or common connection. All the channels will be cleared after topology changed. Parameters: Name Type Description Default n_in int Number of input ports (0 for common connection mode). required n_out int Number of output ports (0 for common connection mode). required Source code in pyinst\\models.py 4481 4482 4483 4484 4485 4486 4487 4488 4489 4490 4491 4492 4493 4494 4495 def set_switch_topology ( self , n_in : int , n_out : int ) -> None : \"\"\" Sets the switch topology to emulate an MxN switch or common connection. All the channels will be cleared after topology changed. Args: n_in: Number of input ports (0 for common connection mode). n_out: Number of output ports (0 for common connection mode). \"\"\" cmd = ':MODUle:TYPe {device} , {n_in} , {n_out} ' . format ( device = self . __device , n_in = n_in , n_out = n_out ) self . command ( cmd )","title":"set_switch_topology()"},{"location":"api/models/#pyinst.models.ModelMC711","text":"Bases: BaseModelEspecOld See base class: [ BaseModelEspecOld ][pyinst.instrument_models.BaseModelEspecOld Source code in pyinst\\models.py 3648 3649 3650 3651 class ModelMC711 ( BaseModelEspecOld ): \"\"\"See base class: [`BaseModelEspecOld`][pyinst.instrument_models.BaseModelEspecOld\"\"\" model = \"MC-711\"","title":"ModelMC711"},{"location":"api/models/#pyinst.models.ModelMC811","text":"Bases: RawSerialInstrument , TypeTS MC-811 is a chamber model by GWS. Note Before communication, some configuration should be performed on the chamber. Communication: Serial Protocol: STEN Baudrate/Parity/Bytesize/Stopbits/Termination: Correspond with the settings in the __init__ method. Default values: baudrate = 19200 parity = NONE Bytesize = 8 bits Stopbits: 1 bit Termination: <CR><LF> Device ID: None Source code in pyinst\\models.py 3660 3661 3662 3663 3664 3665 3666 3667 3668 3669 3670 3671 3672 3673 3674 3675 3676 3677 3678 3679 3680 3681 3682 3683 3684 3685 3686 3687 3688 3689 3690 3691 3692 3693 3694 3695 3696 3697 3698 3699 3700 3701 3702 3703 3704 3705 3706 3707 3708 3709 3710 3711 3712 3713 3714 3715 3716 3717 3718 3719 3720 3721 3722 3723 3724 3725 3726 3727 3728 3729 3730 3731 3732 3733 3734 3735 3736 3737 3738 3739 3740 3741 3742 3743 3744 3745 3746 3747 3748 3749 3750 class ModelMC811 ( RawSerialInstrument , TypeTS ): \"\"\"MC-811 is a chamber model by GWS. Note: Before communication, some configuration should be performed on the chamber. - Communication: Serial - Protocol: STEN - Baudrate/Parity/Bytesize/Stopbits/Termination: Correspond with the settings in the `__init__` method. Default values: - baudrate = 19200 - parity = NONE - Bytesize = 8 bits - Stopbits: 1 bit - Termination: `<CR><LF>` - Device ID: None \"\"\" model = \"MC-811\" brand = \"GWS\" def __init__ ( self , resource_name , baudrate = 19200 , bytesize = SerialByteSize . EIGHTBITS , parity = SerialParity . NONE , stopbits = SerialStopBits . ONE , termination = ' \\r\\n ' , ** kwargs ): \"\"\" Args: resource_name: Serial port name. baudrate: Baud rate such as 9600 or 115200 etc.. bytesize: SerialByteSize = SerialByteSize.EIGHTBITS, parity: SerialParity = SerialParity.NONE, stopbits: SerialStopBits = SerialStopBits.ONE, termination: The write and read termination character. **kwargs: Directly passed to `RawSerialInstrument.__init__`. \"\"\" super () . __init__ ( resource_name , baudrate = baudrate , bytesize = bytesize , parity = parity , stopbits = stopbits , write_termination = termination , read_termination = termination , ** kwargs ) @property def ts_type ( self ) -> TemperatureSourceType : return TemperatureSourceType . CHAMBER # def check_connection(self) -> ConnectionStatus: # try: # self.get_target_temp() # return ConnectionStatus(True) # except Exception as e: # return ConnectionStatus(False, e.args[0] if e.args else None) def run ( self , en : bool = True ) -> None : \"\"\"TODO\"\"\" def stop ( self ) -> None : self . run ( False ) def is_running ( self ) -> bool : \"\"\"TODO\"\"\" def set_target_temp ( self , value : int | float ) -> None : value = round ( value , 1 ) cmd = 'TEMP, S {value:.1f} ' . format ( value = value ) self . write ( cmd ) def get_target_temp ( self ) -> float : cmd = 'TEMP?' temp = float ( self . query ( cmd ) . split ( ',' )[ 1 ]) return temp def get_current_temp ( self ) -> float : cmd = 'TEMP?' temp = float ( self . query ( cmd ) . split ( ',' )[ 0 ]) return temp def set_temp_unit ( self , unit : TemperatureUnit ) -> None : if unit != TemperatureUnit . C : raise ValueError ( 'The temperature unit of this Chamber is fixed to C.' ) def get_temp_unit ( self ) -> TemperatureUnit : return TemperatureUnit . C","title":"ModelMC811"},{"location":"api/models/#pyinst.models.ModelMC811.__init__","text":"Parameters: Name Type Description Default resource_name Serial port name. required baudrate Baud rate such as 9600 or 115200 etc.. 19200 bytesize SerialByteSize = SerialByteSize.EIGHTBITS, SerialByteSize.EIGHTBITS parity SerialParity = SerialParity.NONE, SerialParity.NONE stopbits SerialStopBits = SerialStopBits.ONE, SerialStopBits.ONE termination The write and read termination character. '\\r\\n' **kwargs Directly passed to RawSerialInstrument.__init__ . {} Source code in pyinst\\models.py 3681 3682 3683 3684 3685 3686 3687 3688 3689 3690 3691 3692 3693 3694 3695 3696 3697 3698 3699 3700 3701 3702 3703 3704 3705 3706 3707 3708 def __init__ ( self , resource_name , baudrate = 19200 , bytesize = SerialByteSize . EIGHTBITS , parity = SerialParity . NONE , stopbits = SerialStopBits . ONE , termination = ' \\r\\n ' , ** kwargs ): \"\"\" Args: resource_name: Serial port name. baudrate: Baud rate such as 9600 or 115200 etc.. bytesize: SerialByteSize = SerialByteSize.EIGHTBITS, parity: SerialParity = SerialParity.NONE, stopbits: SerialStopBits = SerialStopBits.ONE, termination: The write and read termination character. **kwargs: Directly passed to `RawSerialInstrument.__init__`. \"\"\" super () . __init__ ( resource_name , baudrate = baudrate , bytesize = bytesize , parity = parity , stopbits = stopbits , write_termination = termination , read_termination = termination , ** kwargs )","title":"__init__()"},{"location":"api/models/#pyinst.models.ModelMC811.is_running","text":"TODO Source code in pyinst\\models.py 3727 3728 def is_running ( self ) -> bool : \"\"\"TODO\"\"\"","title":"is_running()"},{"location":"api/models/#pyinst.models.ModelMC811.run","text":"TODO Source code in pyinst\\models.py 3721 3722 def run ( self , en : bool = True ) -> None : \"\"\"TODO\"\"\"","title":"run()"},{"location":"api/models/#pyinst.models.ModelMPC202","text":"Bases: VisaInstrument , TypePOLC Source code in pyinst\\models.py 5267 5268 5269 5270 5271 5272 5273 5274 5275 5276 5277 5278 5279 5280 5281 5282 5283 5284 5285 5286 5287 5288 5289 5290 5291 5292 5293 5294 5295 5296 5297 5298 5299 5300 5301 5302 5303 5304 5305 5306 5307 5308 5309 5310 5311 5312 5313 5314 5315 5316 5317 5318 5319 5320 5321 5322 5323 5324 5325 5326 5327 5328 5329 5330 5331 5332 5333 5334 5335 5336 5337 5338 5339 5340 5341 5342 5343 5344 5345 5346 5347 5348 5349 5350 5351 5352 5353 5354 5355 5356 5357 5358 5359 5360 5361 5362 5363 5364 5365 5366 5367 5368 5369 5370 5371 5372 5373 5374 5375 5376 5377 5378 5379 5380 5381 5382 5383 5384 5385 5386 5387 5388 5389 5390 5391 5392 5393 5394 5395 5396 5397 5398 5399 5400 5401 5402 5403 5404 5405 5406 5407 5408 5409 5410 5411 5412 5413 5414 5415 5416 5417 5418 5419 5420 5421 5422 5423 class ModelMPC202 ( VisaInstrument , TypePOLC ): model = \"MPC-202\" brand = \"General Photonics\" details = { 'Wavelength Range' : '1260 ~ 1650 nm' , 'Scrambling Modes' : 'Discrete, Tornado, Rayleigh, Triangle' , 'Tornado Rate' : '0 to 60,000 Rev/s' , 'Rayleigh Rate' : '0 to 2000 rad/s' , 'Triangle Rate' : '0 to 2000 x 2\u03c0 rad/s' , 'Discrete Rate' : '0 to 20,000 points/s' } def __init__ ( self , resource_name : str , read_termination : str = ' \\r\\n ' , write_termination : str = ' \\r\\n ' , ** kwargs ): super () . __init__ ( resource_name , read_termination , write_termination , ** kwargs ) @property def min_frequency ( self ) -> float : return super () . min_frequency @property def max_frequency ( self ) -> float : return super () . max_frequency @property def min_wavelength ( self ) -> float : return 1260.0 @property def max_wavelength ( self ) -> float : return 1650.0 def get_frequency ( self ) -> float : return super () . get_frequency () def set_frequency ( self , frequency : int | float ) -> None : return super () . set_frequency ( frequency ) def get_wavelength ( self ) -> float : cmd = \":CONFigure:WLENgth?\" wl = float ( self . query ( cmd )) return wl def set_wavelength ( self , wavelength : int | float ) -> None : if not self . min_wavelength <= wavelength <= self . max_wavelength : raise ValueError ( f \"Parameter wavelength is out of range: { wavelength !r} \" ) cmd = f \":CONFigure:WLENgth { wavelength : d } \" self . command ( cmd ) def _discrete_scramble ( self , state : bool , rate : Optional [ int | float ] = None ) -> None : \"\"\"Set discrete scrambling rate and state. Args: state: `True` = Enable scrambling, `False` = Disable scrambling. rate: The scrambling rate in points/s. \"\"\" if rate is not None : if not 0.01 <= rate <= 20000 : raise ValueError ( f 'Parameter rate is out of range: { rate !r} ' ) cmd1 = f \":SCRamble:DISCrete:RATE { rate : .2f } \" self . command ( cmd1 ) cmd2 = f \":SCRamble:DISCrete:STATe { [ 'OFF' , 'ON' ][ state ] } \" self . command ( cmd2 ) def _triangle_scramble ( self , state : bool , rate : Optional [ int | float ] = None ) -> None : \"\"\"Set triangle scrambling rate and state. Args: state: `True` = Enable scrambling, `False` = Disable scrambling. rate: The scrambling rate in 2\u03c0 rad/s. \"\"\" if rate is not None : if not 0.01 <= rate <= 2000 : raise ValueError ( f 'Parameter rate is out of range: { rate !r} ' ) cmd1 = f \":SCRamble:TRIangle:RATE { rate : .2f } \" self . command ( cmd1 ) cmd2 = f \":SCRamble:TRIangle:STATe { [ 'OFF' , 'ON' ][ state ] } \" self . command ( cmd2 ) def _rayleigh_scramble ( self , state : bool , rate : Optional [ int | float ] = None ) -> None : \"\"\"Set Rayleigh scrambling rate and state. Args: state: `True` = Enable scrambling, `False` = Disable scrambling. rate: The scrambling rate in rad/s. \"\"\" if rate is not None : if not 0.01 <= rate <= 2000 : raise ValueError ( f 'Parameter rate is out of range: { rate !r} ' ) cmd1 = f \":SCRamble:RAYLeigh:RATE { rate : .2f } \" self . command ( cmd1 ) cmd2 = f \":SCRamble:RAYLeigh:STATe { [ 'OFF' , 'ON' ][ state ] } \" self . command ( cmd2 ) def _tornado_scramble ( self , state : bool , _type : Optional [ int ], rate : Optional [ int | float ]) -> None : \"\"\"Set tornado scrambling rate, type and state. Args: state: `True` = Enable scrambling, `False` = Disable scrambling. _type: The scrambling type of tornado. `0` = Fixed rotation axis, `1` = Moving rotation axis. rate: The scrambling rate in rev/s. \"\"\" if _type is not None : cmd1 = f \":SCRamble:TORNado:TYPE { _type : d } \" self . command ( cmd1 ) if rate is not None : if not 0.01 <= rate <= 60000 : raise ValueError ( f 'Parameter rate is out of range: { rate !r} ' ) cmd2 = f \":SCRamble:TORNado:RATE { rate : .2f } \" self . command ( cmd2 ) cmd3 = f \":SCRamble:TORNado:STATe { [ 'OFF' , 'ON' ][ state ] } \" self . command ( cmd3 ) def start_scrambling ( self , mode : str , rate : int | float , ** params ) -> None : \"\"\"Start scrambling with specified mode and speed. Args: mode: Scrambling mode. - `DISCrete`: Discrete scrambling. - `TRIangle`: Triangle scrambling. - `RAYLeigh`: Rayleigh scrambling. - `TORNado`: Tornado scrambling. Additional scrambling parameter `_type` is required. rate: Scrambling rate. Different mode may have different units. params: Additional scrambling params if any. * `_type (int)`: For `TORNado` mode only. `0` = Fixed axis, `1` = Rotating axis. Note: Different mode has different unit for scrambling rate: - Discrete: points/s - Triangle: 2\u03c0 rad/s - Rayleigh: rad/s - Tornado: rev/s \"\"\" if mode . upper () . startswith ( 'DISC' ): self . _discrete_scramble ( True , rate = rate ) elif mode . upper () . startswith ( 'TRI' ): self . _triangle_scramble ( True , rate = rate ) elif mode . upper () . startswith ( 'RAYL' ): self . _rayleigh_scramble ( True , rate = rate ) elif mode . upper () . startswith ( 'TORN' ): self . _tornado_scramble ( True , _type = params [ '_type' ], rate = rate ) else : raise ValueError ( f \"Invalid mode: { mode !r} \" ) def stop_scrambling ( self ) -> None : self . _tornado_scramble ( False )","title":"ModelMPC202"},{"location":"api/models/#pyinst.models.ModelMPC202.start_scrambling","text":"Start scrambling with specified mode and speed. Parameters: Name Type Description Default mode str Scrambling mode. DISCrete : Discrete scrambling. TRIangle : Triangle scrambling. RAYLeigh : Rayleigh scrambling. TORNado : Tornado scrambling. Additional scrambling parameter _type is required. required rate int | float Scrambling rate. Different mode may have different units. required params Additional scrambling params if any. _type (int) : For TORNado mode only. 0 = Fixed axis, 1 = Rotating axis. required Note Different mode has different unit for scrambling rate: Discrete: points/s Triangle: 2\u03c0 rad/s Rayleigh: rad/s Tornado: rev/s Source code in pyinst\\models.py 5388 5389 5390 5391 5392 5393 5394 5395 5396 5397 5398 5399 5400 5401 5402 5403 5404 5405 5406 5407 5408 5409 5410 5411 5412 5413 5414 5415 5416 5417 5418 5419 5420 def start_scrambling ( self , mode : str , rate : int | float , ** params ) -> None : \"\"\"Start scrambling with specified mode and speed. Args: mode: Scrambling mode. - `DISCrete`: Discrete scrambling. - `TRIangle`: Triangle scrambling. - `RAYLeigh`: Rayleigh scrambling. - `TORNado`: Tornado scrambling. Additional scrambling parameter `_type` is required. rate: Scrambling rate. Different mode may have different units. params: Additional scrambling params if any. * `_type (int)`: For `TORNado` mode only. `0` = Fixed axis, `1` = Rotating axis. Note: Different mode has different unit for scrambling rate: - Discrete: points/s - Triangle: 2\u03c0 rad/s - Rayleigh: rad/s - Tornado: rev/s \"\"\" if mode . upper () . startswith ( 'DISC' ): self . _discrete_scramble ( True , rate = rate ) elif mode . upper () . startswith ( 'TRI' ): self . _triangle_scramble ( True , rate = rate ) elif mode . upper () . startswith ( 'RAYL' ): self . _rayleigh_scramble ( True , rate = rate ) elif mode . upper () . startswith ( 'TORN' ): self . _tornado_scramble ( True , _type = params [ '_type' ], rate = rate ) else : raise ValueError ( f \"Invalid mode: { mode !r} \" )","title":"start_scrambling()"},{"location":"api/models/#pyinst.models.ModelMT3065","text":"Bases: BaseModelEspecOld See base class: BaseModelEspecOld Source code in pyinst\\models.py 3654 3655 3656 3657 class ModelMT3065 ( BaseModelEspecOld ): \"\"\"See base class: `BaseModelEspecOld`\"\"\" model = \"MT3065\"","title":"ModelMT3065"},{"location":"api/models/#pyinst.models.ModelN4392A","text":"Bases: BaseModelVSA89600_OMA N4392A Optical Modulation Analyzer. Source code in pyinst\\models.py 2296 2297 2298 2299 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 2311 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 2323 2324 2325 2326 2327 2328 2329 class ModelN4392A ( BaseModelVSA89600_OMA ): \"\"\"N4392A Optical Modulation Analyzer.\"\"\" model = \"N4392A\" brand = \"Keysight\" details = { \"Maximum detectable baud rate\" : \"46 Gbaud\" , \"Optical frequency range\" : \"196.25 ~ 190.95 THz\" , \"External LO input power range\" : \"-3 ~ +16 dBm\" , } def __init__ ( self , resource_name , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. kwargs: directly passed to `VisaInstrument.__init__`. \"\"\" super ( ModelN4392A , self ) . __init__ ( resource_name , ** kwargs ) @property def min_frequency ( self ) -> float : return 190.95 @property def max_frequency ( self ) -> float : return 196.25 @property def min_wavelength ( self ) -> float : return super () . min_wavelength @property def max_wavelength ( self ) -> float : return super () . max_wavelength","title":"ModelN4392A"},{"location":"api/models/#pyinst.models.ModelN4392A.__init__","text":"Parameters: Name Type Description Default resource_name Resource name or alias of the VISA resource to open. required kwargs directly passed to VisaInstrument.__init__ . required Source code in pyinst\\models.py 2307 2308 2309 2310 2311 2312 2313 def __init__ ( self , resource_name , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. kwargs: directly passed to `VisaInstrument.__init__`. \"\"\" super ( ModelN4392A , self ) . __init__ ( resource_name , ** kwargs )","title":"__init__()"},{"location":"api/models/#pyinst.models.ModelN7744A","text":"Bases: BaseModelN77xx_OPM Keysight N7744A multi-channel optical power meter. Source code in pyinst\\models.py 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 class ModelN7744A ( BaseModelN77xx_OPM ): \"\"\"Keysight N7744A multi-channel optical power meter.\"\"\" brand = \"Keysight\" model = \"N7744A\" details = { \"Wavelength Range\" : \"1250 ~ 1625 nm\" , \"Input Power Range\" : \"-80 ~ +10 dBm\" , \"Safe Power\" : \"+16 dBm\" , \"Averaging Time\" : \"1 us ~ 10 s\" , } params = [ { \"name\" : \"slot\" , \"type\" : \"int\" , \"options\" : [ 1 , 2 , 3 , 4 ], } ] @property def _max_slot ( self ): return 4","title":"ModelN7744A"},{"location":"api/models/#pyinst.models.ModelN7752A","text":"Bases: BaseModelN77xx_VOA_with_OPM , BaseModelN77xx_OPM Keysight N7752A 2-channel optical attenuator and 2-channel power meter. Source code in pyinst\\models.py 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 class ModelN7752A ( BaseModelN77xx_VOA_with_OPM , BaseModelN77xx_OPM ): \"\"\"Keysight N7752A 2-channel optical attenuator and 2-channel power meter. \"\"\" brand = \"Keysight\" model = \"N7752A\" details = { \"Wavelength Range\" : \"1260~1640 nm\" , \"(slot 1~4) Att Range\" : \"0 ~ 45 dB\" , \"(slot 1~4) Safe Power\" : \"+23 dBm\" , \"(slot 5~6) Input Power Range\" : \"-80 ~ +10 dBm\" , \"(slot 5~6) Safe Power\" : \"+16 dBm\" , \"Averaging Time\" : \"2 ms ~ 10 s\" , } params = [ { \"name\" : \"slot\" , \"type\" : \"int\" , \"options\" : [ 1 , 3 , 5 , 6 ] } ] def __init__ ( self , resource_name : str , slot : int , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: The slot number in the frame. **kwargs: Directly passed to `VisaInstrument.__init__`. \"\"\" super ( ModelN7752A , self ) . __init__ ( resource_name , slot , ** kwargs ) __topology = { 1 : 'voa_with_opm' , 2 : 'voa_with_opm' , 3 : 'voa_with_opm' , 4 : 'voa_with_opm' , 5 : 'opm' , 6 : 'opm' , } self . __slot_type = __slot_type = __topology [ slot ] self . __Base = BaseModelN77xx_OPM if __slot_type == 'opm' else BaseModelN77xx_VOA_with_OPM def __raise_NotImplementedError ( self ): raise NotImplementedError ( f \"This function is not implemented for slot { self . _slot } .\" ) @property def _max_slot ( self ): return 6 @property def min_frequency ( self ) -> float : \"\"\"The minimum settable optical frequency value in THz.\"\"\" return super () . min_frequency @property def max_frequency ( self ) -> float : \"\"\"The maximum settable optical frequency value in THz.\"\"\" return super () . max_frequency @property def min_wavelength ( self ) -> float : \"\"\"The minimum settable optical wavelength value in nm.\"\"\" return self . __Base . min_wavelength . __get__ ( self ) @property def max_wavelength ( self ) -> float : \"\"\"The maximum settable optical wavelength value in nm.\"\"\" return self . __Base . max_wavelength . __get__ ( self ) @property def min_avg_time ( self ) -> float : \"\"\"The minimum averaging time in ms.\"\"\" return 2.0 # 2ms @property def max_avg_time ( self ) -> float : \"\"\"The maximum averaging time in ms.\"\"\" return 10000.0 # 10s @property def min_pow_cal ( self ) -> float : \"\"\"The minimum power calibration value in dB.\"\"\" return self . __Base . min_pow_cal . __get__ ( self ) @property def max_pow_cal ( self ) -> float : \"\"\"The maximum power calibration value in dB.\"\"\" return self . __Base . max_pow_cal . __get__ ( self ) @property def min_att ( self ) -> float : \"\"\"Minimum settable attenuation in dB. The minimum settable attenuation = 0 dB + the optical attenuation offset value. \"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . min_att @property def max_att ( self ) -> float : \"\"\"Maximum settable attenuation in dB. The maximum settable attenuation = The maximum attenuation + the optical attenuation offset value. \"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . max_att @property def min_att_offset ( self ) -> float : \"\"\"Minimum attenuation offset value in dB.\"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . min_att_offset @property def max_att_offset ( self ) -> float : \"\"\"Maximum attenuation offset value in dB.\"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . max_att_offset def get_frequency ( self ) -> float : \"\"\" Queries the optical frequency setting of the instrument in THz. Returns: The optical frequency setting value in THz. \"\"\" return super () . get_frequency () def set_frequency ( self , frequency : int | float ) -> None : \"\"\"Set optical frequency. Args: frequency: The optical frequency setting in THz. \"\"\" return super () . set_frequency ( frequency ) def get_wavelength ( self ) -> float : \"\"\"Queries the optical wavelength setting of the instrument in nm. Returns: The optical wavelength setting value in nm. \"\"\" return self . __Base . get_wavelength ( self ) def set_wavelength ( self , wavelength : int | float ) -> None : \"\"\"Set optical wavelength. Args: wavelength: The optical wavelength setting in nm. \"\"\" return self . __Base . set_wavelength ( self , wavelength ) def get_power_value ( self ) -> float : \"\"\"Fetch the value of measured optical power in current unit setting. The measured value includes the power calibration. Measured value (dBm) = the actual measured value (dBm) + power calibration (dB) Refer to `get_pow_cal` and `set_pow_cal` to operate with the power calibration. Returns: The value of the optical power. \"\"\" return self . __Base . get_power_value ( self ) def get_power_unit ( self ) -> OpticalPowerUnit : \"\"\"Get optical power unit setting. Returns: The unit of the optical power. \"\"\" return self . __Base . get_power_unit ( self ) def set_power_unit ( self , unit : OpticalPowerUnit ) -> None : \"\"\"Set the unit of optical power. Args: unit: The unit of the optical power. \"\"\" return self . __Base . set_power_unit ( self , unit ) def get_pow_cal ( self ) -> float : \"\"\" Get the power calibration offset in dB. Note: The power calibration value defined here is opposite in sign with the instrument display value. This is to unify the definition of power calibration across different models of OPMs. Please refer to `get_power_value` for the math equation. Returns: The power calibration offset in dB. \"\"\" return self . __Base . get_pow_cal ( self ) def set_pow_cal ( self , value : int | float ) -> None : \"\"\" Set the power calibration offset in dB. Args: value: The power calibration offset in dB. \"\"\" return self . __Base . set_pow_cal ( self , value ) def get_avg_time ( self ) -> float : \"\"\" Get the averaging time in ms. Returns: The averaging time in ms. \"\"\" return self . __Base . get_avg_time ( self ) def set_avg_time ( self , value : int | float ) -> None : \"\"\" Set the averaging time in ms. Args: value: The averaging time in ms. \"\"\" return self . __Base . set_avg_time ( self , value ) def enable ( self , en : bool = True ) -> None : \"\"\" Enable (disable) the optical output. Args: en: True = Enable, False = Disable. \"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . enable ( en ) def disable ( self ) -> None : \"\"\"Disable the optical output.\"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () self . enable ( False ) def is_enabled ( self ) -> bool : \"\"\" Returns: Whether the optical output is enabled. \"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . is_enabled () def get_att ( self ) -> float : \"\"\" Get the current attenuation value in dB. Includes the attenuation offset. Queried attenuator = the actual attenuator value + attenuator offset Use `get_att_offset` and `set_att_offset` to operate with the attenuator offset. Returns: The attenuation value in dB. \"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . get_att () def set_att ( self , att : int | float ) -> None : \"\"\" Set attenuation value in dB. Includes the attenuation offset. Refer to `get_att` for more information. Args: att: The attenuation value in dB. \"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . set_att ( att ) def get_att_offset ( self ) -> float : \"\"\" Get the attenuation offset value in dB. Returns: The attenuation offset in dB. \"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . get_att_offset () def set_att_offset ( self , offset : int | float ) -> None : \"\"\" Set the attenuation offset value in dB. Args: offset: The attenuation offset in dB. \"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . set_att_offset ( offset )","title":"ModelN7752A"},{"location":"api/models/#pyinst.models.ModelN7752A.__init__","text":"Parameters: Name Type Description Default resource_name str Resource name or alias of the VISA resource to open. required slot int The slot number in the frame. required **kwargs Directly passed to VisaInstrument.__init__ . {} Source code in pyinst\\models.py 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 def __init__ ( self , resource_name : str , slot : int , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: The slot number in the frame. **kwargs: Directly passed to `VisaInstrument.__init__`. \"\"\" super ( ModelN7752A , self ) . __init__ ( resource_name , slot , ** kwargs ) __topology = { 1 : 'voa_with_opm' , 2 : 'voa_with_opm' , 3 : 'voa_with_opm' , 4 : 'voa_with_opm' , 5 : 'opm' , 6 : 'opm' , } self . __slot_type = __slot_type = __topology [ slot ] self . __Base = BaseModelN77xx_OPM if __slot_type == 'opm' else BaseModelN77xx_VOA_with_OPM","title":"__init__()"},{"location":"api/models/#pyinst.models.ModelN7752A.disable","text":"Disable the optical output. Source code in pyinst\\models.py 841 842 843 844 845 def disable ( self ) -> None : \"\"\"Disable the optical output.\"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () self . enable ( False )","title":"disable()"},{"location":"api/models/#pyinst.models.ModelN7752A.enable","text":"Enable (disable) the optical output. Parameters: Name Type Description Default en bool True = Enable, False = Disable. True Source code in pyinst\\models.py 830 831 832 833 834 835 836 837 838 839 def enable ( self , en : bool = True ) -> None : \"\"\" Enable (disable) the optical output. Args: en: True = Enable, False = Disable. \"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . enable ( en )","title":"enable()"},{"location":"api/models/#pyinst.models.ModelN7752A.get_att","text":"Get the current attenuation value in dB. Includes the attenuation offset. Queried attenuator = the actual attenuator value + attenuator offset Use get_att_offset and set_att_offset to operate with the attenuator offset. Returns: Type Description float The attenuation value in dB. Source code in pyinst\\models.py 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 def get_att ( self ) -> float : \"\"\" Get the current attenuation value in dB. Includes the attenuation offset. Queried attenuator = the actual attenuator value + attenuator offset Use `get_att_offset` and `set_att_offset` to operate with the attenuator offset. Returns: The attenuation value in dB. \"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . get_att ()","title":"get_att()"},{"location":"api/models/#pyinst.models.ModelN7752A.get_att_offset","text":"Get the attenuation offset value in dB. Returns: Type Description float The attenuation offset in dB. Source code in pyinst\\models.py 888 889 890 891 892 893 894 895 896 897 def get_att_offset ( self ) -> float : \"\"\" Get the attenuation offset value in dB. Returns: The attenuation offset in dB. \"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . get_att_offset ()","title":"get_att_offset()"},{"location":"api/models/#pyinst.models.ModelN7752A.get_avg_time","text":"Get the averaging time in ms. Returns: Type Description float The averaging time in ms. Source code in pyinst\\models.py 812 813 814 815 816 817 818 819 def get_avg_time ( self ) -> float : \"\"\" Get the averaging time in ms. Returns: The averaging time in ms. \"\"\" return self . __Base . get_avg_time ( self )","title":"get_avg_time()"},{"location":"api/models/#pyinst.models.ModelN7752A.get_frequency","text":"Queries the optical frequency setting of the instrument in THz. Returns: Type Description float The optical frequency setting value in THz. Source code in pyinst\\models.py 725 726 727 728 729 730 731 732 def get_frequency ( self ) -> float : \"\"\" Queries the optical frequency setting of the instrument in THz. Returns: The optical frequency setting value in THz. \"\"\" return super () . get_frequency ()","title":"get_frequency()"},{"location":"api/models/#pyinst.models.ModelN7752A.get_pow_cal","text":"Get the power calibration offset in dB. Note The power calibration value defined here is opposite in sign with the instrument display value. This is to unify the definition of power calibration across different models of OPMs. Please refer to get_power_value for the math equation. Returns: Type Description float The power calibration offset in dB. Source code in pyinst\\models.py 788 789 790 791 792 793 794 795 796 797 798 799 800 801 def get_pow_cal ( self ) -> float : \"\"\" Get the power calibration offset in dB. Note: The power calibration value defined here is opposite in sign with the instrument display value. This is to unify the definition of power calibration across different models of OPMs. Please refer to `get_power_value` for the math equation. Returns: The power calibration offset in dB. \"\"\" return self . __Base . get_pow_cal ( self )","title":"get_pow_cal()"},{"location":"api/models/#pyinst.models.ModelN7752A.get_power_unit","text":"Get optical power unit setting. Returns: Type Description OpticalPowerUnit The unit of the optical power. Source code in pyinst\\models.py 772 773 774 775 776 777 778 def get_power_unit ( self ) -> OpticalPowerUnit : \"\"\"Get optical power unit setting. Returns: The unit of the optical power. \"\"\" return self . __Base . get_power_unit ( self )","title":"get_power_unit()"},{"location":"api/models/#pyinst.models.ModelN7752A.get_power_value","text":"Fetch the value of measured optical power in current unit setting. The measured value includes the power calibration. Measured value (dBm) = the actual measured value (dBm) + power calibration (dB) Refer to get_pow_cal and set_pow_cal to operate with the power calibration. Returns: Type Description float The value of the optical power. Source code in pyinst\\models.py 758 759 760 761 762 763 764 765 766 767 768 769 770 def get_power_value ( self ) -> float : \"\"\"Fetch the value of measured optical power in current unit setting. The measured value includes the power calibration. Measured value (dBm) = the actual measured value (dBm) + power calibration (dB) Refer to `get_pow_cal` and `set_pow_cal` to operate with the power calibration. Returns: The value of the optical power. \"\"\" return self . __Base . get_power_value ( self )","title":"get_power_value()"},{"location":"api/models/#pyinst.models.ModelN7752A.get_wavelength","text":"Queries the optical wavelength setting of the instrument in nm. Returns: Type Description float The optical wavelength setting value in nm. Source code in pyinst\\models.py 742 743 744 745 746 747 748 def get_wavelength ( self ) -> float : \"\"\"Queries the optical wavelength setting of the instrument in nm. Returns: The optical wavelength setting value in nm. \"\"\" return self . __Base . get_wavelength ( self )","title":"get_wavelength()"},{"location":"api/models/#pyinst.models.ModelN7752A.is_enabled","text":"Returns: Type Description bool Whether the optical output is enabled. Source code in pyinst\\models.py 847 848 849 850 851 852 853 854 def is_enabled ( self ) -> bool : \"\"\" Returns: Whether the optical output is enabled. \"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . is_enabled ()","title":"is_enabled()"},{"location":"api/models/#pyinst.models.ModelN7752A.max_att","text":"Maximum settable attenuation in dB. The maximum settable attenuation = The maximum attenuation + the optical attenuation offset value. Source code in pyinst\\models.py 700 701 702 703 704 705 706 707 708 709 @property def max_att ( self ) -> float : \"\"\"Maximum settable attenuation in dB. The maximum settable attenuation = The maximum attenuation + the optical attenuation offset value. \"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . max_att","title":"max_att()"},{"location":"api/models/#pyinst.models.ModelN7752A.max_att_offset","text":"Maximum attenuation offset value in dB. Source code in pyinst\\models.py 718 719 720 721 722 723 @property def max_att_offset ( self ) -> float : \"\"\"Maximum attenuation offset value in dB.\"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . max_att_offset","title":"max_att_offset()"},{"location":"api/models/#pyinst.models.ModelN7752A.max_avg_time","text":"The maximum averaging time in ms. Source code in pyinst\\models.py 674 675 676 677 @property def max_avg_time ( self ) -> float : \"\"\"The maximum averaging time in ms.\"\"\" return 10000.0 # 10s","title":"max_avg_time()"},{"location":"api/models/#pyinst.models.ModelN7752A.max_frequency","text":"The maximum settable optical frequency value in THz. Source code in pyinst\\models.py 654 655 656 657 @property def max_frequency ( self ) -> float : \"\"\"The maximum settable optical frequency value in THz.\"\"\" return super () . max_frequency","title":"max_frequency()"},{"location":"api/models/#pyinst.models.ModelN7752A.max_pow_cal","text":"The maximum power calibration value in dB. Source code in pyinst\\models.py 684 685 686 687 @property def max_pow_cal ( self ) -> float : \"\"\"The maximum power calibration value in dB.\"\"\" return self . __Base . max_pow_cal . __get__ ( self )","title":"max_pow_cal()"},{"location":"api/models/#pyinst.models.ModelN7752A.max_wavelength","text":"The maximum settable optical wavelength value in nm. Source code in pyinst\\models.py 664 665 666 667 @property def max_wavelength ( self ) -> float : \"\"\"The maximum settable optical wavelength value in nm.\"\"\" return self . __Base . max_wavelength . __get__ ( self )","title":"max_wavelength()"},{"location":"api/models/#pyinst.models.ModelN7752A.min_att","text":"Minimum settable attenuation in dB. The minimum settable attenuation = 0 dB + the optical attenuation offset value. Source code in pyinst\\models.py 689 690 691 692 693 694 695 696 697 698 @property def min_att ( self ) -> float : \"\"\"Minimum settable attenuation in dB. The minimum settable attenuation = 0 dB + the optical attenuation offset value. \"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . min_att","title":"min_att()"},{"location":"api/models/#pyinst.models.ModelN7752A.min_att_offset","text":"Minimum attenuation offset value in dB. Source code in pyinst\\models.py 711 712 713 714 715 716 @property def min_att_offset ( self ) -> float : \"\"\"Minimum attenuation offset value in dB.\"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . min_att_offset","title":"min_att_offset()"},{"location":"api/models/#pyinst.models.ModelN7752A.min_avg_time","text":"The minimum averaging time in ms. Source code in pyinst\\models.py 669 670 671 672 @property def min_avg_time ( self ) -> float : \"\"\"The minimum averaging time in ms.\"\"\" return 2.0 # 2ms","title":"min_avg_time()"},{"location":"api/models/#pyinst.models.ModelN7752A.min_frequency","text":"The minimum settable optical frequency value in THz. Source code in pyinst\\models.py 649 650 651 652 @property def min_frequency ( self ) -> float : \"\"\"The minimum settable optical frequency value in THz.\"\"\" return super () . min_frequency","title":"min_frequency()"},{"location":"api/models/#pyinst.models.ModelN7752A.min_pow_cal","text":"The minimum power calibration value in dB. Source code in pyinst\\models.py 679 680 681 682 @property def min_pow_cal ( self ) -> float : \"\"\"The minimum power calibration value in dB.\"\"\" return self . __Base . min_pow_cal . __get__ ( self )","title":"min_pow_cal()"},{"location":"api/models/#pyinst.models.ModelN7752A.min_wavelength","text":"The minimum settable optical wavelength value in nm. Source code in pyinst\\models.py 659 660 661 662 @property def min_wavelength ( self ) -> float : \"\"\"The minimum settable optical wavelength value in nm.\"\"\" return self . __Base . min_wavelength . __get__ ( self )","title":"min_wavelength()"},{"location":"api/models/#pyinst.models.ModelN7752A.set_att","text":"Set attenuation value in dB. Includes the attenuation offset. Refer to get_att for more information. Parameters: Name Type Description Default att int | float The attenuation value in dB. required Source code in pyinst\\models.py 874 875 876 877 878 879 880 881 882 883 884 885 886 def set_att ( self , att : int | float ) -> None : \"\"\" Set attenuation value in dB. Includes the attenuation offset. Refer to `get_att` for more information. Args: att: The attenuation value in dB. \"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . set_att ( att )","title":"set_att()"},{"location":"api/models/#pyinst.models.ModelN7752A.set_att_offset","text":"Set the attenuation offset value in dB. Parameters: Name Type Description Default offset int | float The attenuation offset in dB. required Source code in pyinst\\models.py 899 900 901 902 903 904 905 906 907 908 def set_att_offset ( self , offset : int | float ) -> None : \"\"\" Set the attenuation offset value in dB. Args: offset: The attenuation offset in dB. \"\"\" if self . __slot_type == 'opm' : self . __raise_NotImplementedError () return super () . set_att_offset ( offset )","title":"set_att_offset()"},{"location":"api/models/#pyinst.models.ModelN7752A.set_avg_time","text":"Set the averaging time in ms. Parameters: Name Type Description Default value int | float The averaging time in ms. required Source code in pyinst\\models.py 821 822 823 824 825 826 827 828 def set_avg_time ( self , value : int | float ) -> None : \"\"\" Set the averaging time in ms. Args: value: The averaging time in ms. \"\"\" return self . __Base . set_avg_time ( self , value )","title":"set_avg_time()"},{"location":"api/models/#pyinst.models.ModelN7752A.set_frequency","text":"Set optical frequency. Parameters: Name Type Description Default frequency int | float The optical frequency setting in THz. required Source code in pyinst\\models.py 734 735 736 737 738 739 740 def set_frequency ( self , frequency : int | float ) -> None : \"\"\"Set optical frequency. Args: frequency: The optical frequency setting in THz. \"\"\" return super () . set_frequency ( frequency )","title":"set_frequency()"},{"location":"api/models/#pyinst.models.ModelN7752A.set_pow_cal","text":"Set the power calibration offset in dB. Parameters: Name Type Description Default value int | float The power calibration offset in dB. required Source code in pyinst\\models.py 803 804 805 806 807 808 809 810 def set_pow_cal ( self , value : int | float ) -> None : \"\"\" Set the power calibration offset in dB. Args: value: The power calibration offset in dB. \"\"\" return self . __Base . set_pow_cal ( self , value )","title":"set_pow_cal()"},{"location":"api/models/#pyinst.models.ModelN7752A.set_power_unit","text":"Set the unit of optical power. Parameters: Name Type Description Default unit OpticalPowerUnit The unit of the optical power. required Source code in pyinst\\models.py 780 781 782 783 784 785 786 def set_power_unit ( self , unit : OpticalPowerUnit ) -> None : \"\"\"Set the unit of optical power. Args: unit: The unit of the optical power. \"\"\" return self . __Base . set_power_unit ( self , unit )","title":"set_power_unit()"},{"location":"api/models/#pyinst.models.ModelN7752A.set_wavelength","text":"Set optical wavelength. Parameters: Name Type Description Default wavelength int | float The optical wavelength setting in nm. required Source code in pyinst\\models.py 750 751 752 753 754 755 756 def set_wavelength ( self , wavelength : int | float ) -> None : \"\"\"Set optical wavelength. Args: wavelength: The optical wavelength setting in nm. \"\"\" return self . __Base . set_wavelength ( self , wavelength )","title":"set_wavelength()"},{"location":"api/models/#pyinst.models.ModelN7764A","text":"Bases: BaseModelN77xx_VOA_with_OPM Keysight N7764A 4-channel variable optical attenuator with built-in power meter. Source code in pyinst\\models.py 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 class ModelN7764A ( BaseModelN77xx_VOA_with_OPM ): \"\"\"Keysight N7764A 4-channel variable optical attenuator with built-in power meter.\"\"\" brand = \"Keysight\" model = \"N7764A\" details = { \"Wavelength Range\" : \"1260~1640 nm\" , \"Att Range\" : \"0 ~ 45 dB\" , \"Safe Power\" : \"+23 dBm\" , \"Averaging Time\" : \"2 ms ~ 10 s\" , } params = [ { \"name\" : \"slot\" , \"type\" : \"int\" , \"options\" : [ 1 , 3 , 5 , 7 ] } ] def __init__ ( self , resource_name : str , slot : int , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: The slot number in the frame. **kwargs: Directly passed to `VisaInstrument.__init__` \"\"\" super ( ModelN7764A , self ) . __init__ ( resource_name , slot ) @property def _max_slot ( self ): return 8","title":"ModelN7764A"},{"location":"api/models/#pyinst.models.ModelN7764A.__init__","text":"Parameters: Name Type Description Default resource_name str Resource name or alias of the VISA resource to open. required slot int The slot number in the frame. required **kwargs Directly passed to VisaInstrument.__init__ {} Source code in pyinst\\models.py 932 933 934 935 936 937 938 939 def __init__ ( self , resource_name : str , slot : int , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. slot: The slot number in the frame. **kwargs: Directly passed to `VisaInstrument.__init__` \"\"\" super ( ModelN7764A , self ) . __init__ ( resource_name , slot )","title":"__init__()"},{"location":"api/models/#pyinst.models.ModelNSW","text":"Bases: BaseInstrument , TypeSW The Smart Optical Switch produced by NeoPhotonics. Source code in pyinst\\models.py 4335 4336 4337 4338 4339 4340 4341 4342 4343 4344 4345 4346 4347 4348 4349 4350 4351 4352 4353 4354 4355 4356 4357 4358 4359 4360 4361 4362 4363 4364 4365 4366 4367 4368 4369 4370 4371 4372 4373 4374 4375 4376 4377 4378 4379 4380 4381 4382 4383 4384 4385 4386 4387 4388 4389 4390 4391 4392 4393 4394 4395 4396 4397 4398 4399 4400 4401 4402 4403 4404 4405 4406 4407 4408 class ModelNSW ( BaseInstrument , TypeSW ): \"\"\"The Smart Optical Switch produced by NeoPhotonics.\"\"\" model = \"Neo_SW\" brand = \"NeoPhotonics\" params = [ { \"name\" : \"slot_or_type\" , \"type\" : \"str\" , \"options\" : [ '1' , '2' , '3' , '1*8' , '1*16' ] } ] def __init__ ( self , resource_name : str , slot_or_type : int | str ) -> None : \"\"\" Args: resource_name: The USB S/N of the device. You can use get_usb_devices() method to list all the available devices. slot_or_type: For optical switch with 1x2/2x2/1x4 optical switch slots, this parameter is the slot in the frame. For 1x8 and 1x16 optical switch, this parameter defines the type of the optical switch. - `1`|`2`|`3`: The slot in the frame. - '1*8': This optical switch is 1x8 type. - '1*16': This optical switch is 1x16 type. \"\"\" super ( ModelNSW , self ) . __init__ () if isinstance ( slot_or_type , int ): self . __index = slot_or_type - 1 else : index_map = { '1' : 0 , '2' : 1 , '3' : 2 , '1*8' : 3 , '1*16' : 4 , } try : self . __index = index_map [ slot_or_type ] except KeyError : raise KeyError ( 'Invalid value for slot_or_type: %r ' % slot_or_type ) self . __usb_dev = NeoUsbDevice ( resource_name ) self . __reg_ch_sel = 16 * self . __index + 130 @property def resource_name ( self ) -> str : \"\"\"The USB S/N of the device.\"\"\" return super () . resource_name @classmethod def get_usb_devices ( cls ) -> List [ str ]: \"\"\"The USB S/N of all the available devices.\"\"\" return [ i [ \"Serial Number\" ] . upper () for i in NeoUsbDevice . get_devices_information ()] def close ( self ) -> None : pass # def check_connection(self) -> ConnectionStatus: # try: # self.get_channel() # return ConnectionStatus(True) # except Exception as e: # return ConnectionStatus(False, e.args[0] if e.args else None) def set_channel ( self , channel : int ) -> None : self . __usb_dev . write_registers ( 0xC2 , self . __reg_ch_sel , channel . to_bytes ( 1 , 'big' )) time . sleep ( 0.4 ) if self . get_channel () != channel : raise ValueError ( 'Set switch channel failed.' ) def get_channel ( self ) -> None : channel = int . from_bytes ( self . __usb_dev . read_registers ( 0xC2 , self . __reg_ch_sel , 1 ), 'big' ) if channel <= 0 : raise ValueError ( 'Invalid channel number.' ) return channel","title":"ModelNSW"},{"location":"api/models/#pyinst.models.ModelNSW.__init__","text":"Parameters: Name Type Description Default resource_name str The USB S/N of the device. You can use get_usb_devices() method to list all the available devices. required slot_or_type int | str For optical switch with 1x2/2x2/1x4 optical switch slots, this parameter is the slot in the frame. For 1x8 and 1x16 optical switch, this parameter defines the type of the optical switch. - 1 | 2 | 3 : The slot in the frame. - '1 8': This optical switch is 1x8 type. - '1 16': This optical switch is 1x16 type. required Source code in pyinst\\models.py 4347 4348 4349 4350 4351 4352 4353 4354 4355 4356 4357 4358 4359 4360 4361 4362 4363 4364 4365 4366 4367 4368 4369 4370 4371 4372 4373 4374 4375 4376 def __init__ ( self , resource_name : str , slot_or_type : int | str ) -> None : \"\"\" Args: resource_name: The USB S/N of the device. You can use get_usb_devices() method to list all the available devices. slot_or_type: For optical switch with 1x2/2x2/1x4 optical switch slots, this parameter is the slot in the frame. For 1x8 and 1x16 optical switch, this parameter defines the type of the optical switch. - `1`|`2`|`3`: The slot in the frame. - '1*8': This optical switch is 1x8 type. - '1*16': This optical switch is 1x16 type. \"\"\" super ( ModelNSW , self ) . __init__ () if isinstance ( slot_or_type , int ): self . __index = slot_or_type - 1 else : index_map = { '1' : 0 , '2' : 1 , '3' : 2 , '1*8' : 3 , '1*16' : 4 , } try : self . __index = index_map [ slot_or_type ] except KeyError : raise KeyError ( 'Invalid value for slot_or_type: %r ' % slot_or_type ) self . __usb_dev = NeoUsbDevice ( resource_name ) self . __reg_ch_sel = 16 * self . __index + 130","title":"__init__()"},{"location":"api/models/#pyinst.models.ModelNSW.get_usb_devices","text":"The USB S/N of all the available devices. Source code in pyinst\\models.py 4383 4384 4385 4386 @classmethod def get_usb_devices ( cls ) -> List [ str ]: \"\"\"The USB S/N of all the available devices.\"\"\" return [ i [ \"Serial Number\" ] . upper () for i in NeoUsbDevice . get_devices_information ()]","title":"get_usb_devices()"},{"location":"api/models/#pyinst.models.ModelNSW.resource_name","text":"The USB S/N of the device. Source code in pyinst\\models.py 4378 4379 4380 4381 @property def resource_name ( self ) -> str : \"\"\"The USB S/N of the device.\"\"\" return super () . resource_name","title":"resource_name()"},{"location":"api/models/#pyinst.models.ModelOTF930","text":"Bases: VisaInstrument , TypeOTF Source code in pyinst\\models.py 4140 4141 4142 4143 4144 4145 4146 4147 4148 4149 4150 4151 4152 4153 4154 4155 4156 4157 4158 4159 4160 4161 4162 4163 4164 4165 4166 4167 4168 4169 4170 4171 4172 4173 4174 4175 4176 4177 4178 4179 4180 4181 4182 4183 4184 4185 4186 4187 4188 4189 4190 4191 4192 4193 4194 4195 4196 4197 4198 4199 4200 4201 4202 4203 4204 4205 4206 4207 4208 4209 4210 4211 4212 4213 4214 4215 4216 4217 4218 4219 4220 4221 4222 4223 class ModelOTF930 ( VisaInstrument , TypeOTF ): model = \"OTF-930\" brand = \"Santec\" details = { \"Wavelength Range\" : \"1520 ~ 1610 nm\" , \"Frequency Range\" : \"186.2 ~ 197.2 THz\" , \"Bandwidth\" : \"Fixed and different between bandwidth types\" , \"Max Input Power\" : \"+20 dBm\" } def __init__ ( self , resource_name : str , read_termination : str = ' \\r\\n ' , write_termination : str = ' \\r\\n ' , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. read_termination: Read termination character. write_termination: Write termination character. \"\"\" super () . __init__ ( resource_name , read_termination = read_termination , write_termination = write_termination , ** kwargs ) @property def min_frequency ( self ) -> float : return super () . min_frequency @property def max_frequency ( self ) -> float : return super () . max_frequency @property def min_wavelength ( self ) -> float : return 1520.0 @property def max_wavelength ( self ) -> float : return 1610.0 @property def min_bandwidth_in_nm ( self ) -> float : return float ( 'nan' ) @property def max_bandwidth_in_nm ( self ) -> float : return float ( 'nan' ) @property def min_bandwidth_in_ghz ( self ) -> float : return float ( 'nan' ) @property def max_bandwidth_in_ghz ( self ) -> float : return float ( 'nan' ) def get_wavelength ( self ) -> float : cmd = 'WA' wl = float ( self . query ( cmd )) return wl def set_wavelength ( self , wavelength : int | float ) -> None : if not self . min_wavelength <= wavelength <= self . max_wavelength : raise ValueError ( 'Parameter wavelength out of range: {wl!r} ' . format ( wl = wavelength )) cmd = 'WA {wl:.3f} ' . format ( wl = wavelength ) self . command ( cmd ) def get_frequency ( self ) -> float : return super () . get_frequency () def set_frequency ( self , frequency : int | float ) -> None : return super () . set_frequency ( frequency ) def get_bandwidth_in_nm ( self ) -> float : raise Error ( 'The bandwidth of this OTF model is not tunable.' ) def set_bandwidth_in_nm ( self , value : int | float ) -> None : raise Error ( 'The bandwidth of this OTF model is not tunable.' ) def get_bandwidth_in_ghz ( self ) -> float : raise Error ( 'The bandwidth of this OTF model is not tunable.' ) def set_bandwidth_in_ghz ( self , value : int | float ) -> None : raise Error ( 'The bandwidth of this OTF model is not tunable.' )","title":"ModelOTF930"},{"location":"api/models/#pyinst.models.ModelOTF930.__init__","text":"Parameters: Name Type Description Default resource_name str Resource name or alias of the VISA resource to open. required read_termination str Read termination character. '\\r\\n' write_termination str Write termination character. '\\r\\n' Source code in pyinst\\models.py 4151 4152 4153 4154 4155 4156 4157 4158 4159 4160 4161 4162 def __init__ ( self , resource_name : str , read_termination : str = ' \\r\\n ' , write_termination : str = ' \\r\\n ' , ** kwargs ): \"\"\" Args: resource_name: Resource name or alias of the VISA resource to open. read_termination: Read termination character. write_termination: Write termination character. \"\"\" super () . __init__ ( resource_name , read_termination = read_termination , write_termination = write_termination , ** kwargs )","title":"__init__()"},{"location":"api/models/#pyinst.models.ModelPMD1000","text":"Bases: VisaInstrument , TypePMDE Source code in pyinst\\models.py 5641 5642 5643 5644 5645 5646 5647 5648 5649 5650 5651 5652 5653 5654 5655 5656 5657 5658 5659 5660 5661 5662 5663 5664 5665 5666 5667 5668 5669 5670 5671 5672 5673 5674 5675 5676 5677 5678 5679 5680 5681 5682 5683 5684 5685 5686 5687 5688 5689 5690 5691 5692 5693 5694 5695 5696 5697 5698 5699 5700 5701 5702 5703 5704 5705 5706 5707 5708 5709 5710 5711 5712 5713 5714 5715 5716 5717 5718 5719 5720 5721 5722 5723 5724 class ModelPMD1000 ( VisaInstrument , TypePMDE ): model = \"PMD-1000\" brand = \"General Photonics\" details = { \"Wavelength Range\" : \"C Band\" , \"Insertion Loss\" : \"5.5 dB\" , \"1st Order PMD Range\" : \"0.36 to 182.4 ps\" , \"2nd Order PMD Range\" : \"8100 ps2\" } def __init__ ( self , resource_name : str , read_termination : str = '' , write_termination : str = '#' , ** kwargs ): super () . __init__ ( resource_name , read_termination , write_termination , ** kwargs ) def _formatted_query ( self , cmd ): return self . query ( cmd )[ 1 :] @property def min_frequency ( self ) -> float : return 191.6 @property def max_frequency ( self ) -> float : return 195.9 @property def min_wavelength ( self ) -> float : return super () . min_wavelength @property def max_wavelength ( self ) -> float : return super () . max_wavelength def get_frequency ( self ) -> float : ch_str = self . _formatted_query ( '*CHA?' ) if ch_str [ 0 ] != 'C' : raise ValueError ( 'Unexpected Reply' ) ch = int ( ch_str [ 1 :]) freq = 191.6 + ( ch - 1 ) * 0.05 return freq def set_frequency ( self , frequency : int | float ) -> None : \"\"\"Set optical frequency value. Note: The PMD-1000 can only set to several discrete values on the ITU C-band: frequency = 191.6 + n*0.05, 0 <= n <= 86 If the frequency is not on the ITU grid, it will be set to the nearest valid value, and no exception will be raised. Args: frequency: optical frequency in THz. \"\"\" if not self . min_frequency <= frequency <= self . max_frequency : raise ValueError ( f 'frequency is out of range: { frequency !r} ' ) ch = round (( frequency - 191.6 ) / 0.05 ) + 1 self . command ( '*CHC %03d #' % ch ) def get_wavelength ( self ) -> float : return super () . get_wavelength () def set_wavelength ( self , wavelength : int | float ) -> None : return super () . set_wavelength ( wavelength ) def get_pmd_value ( self ) -> Tuple [ float , float ]: cmd = \"*PMD:CON CAL?\" r = self . _formatted_query ( cmd ) pmd , sopmd = ( float ( i ) for i in r . split ( ',' )) return pmd , sopmd def set_pmd_value ( self , pmd : int | float , sopmd : int | float ) -> None : \"\"\" Note: The pmd and sopmd setting of the PMD-1000 is not continuous. The pmd and sopmd will be set to the nearest supported values, so the real value will not be exactly the same with the setting values. \"\"\" if not 0 <= pmd <= 182.4 : raise ValueError ( f 'pmd is out of range: { pmd } ' ) if not 0 <= sopmd <= 8319.9 : raise ValueError ( f 'sopmd is out of range: { sopmd } ' ) self . command ( '*PMD:CON %.2f , %.2f #' % ( pmd , sopmd ))","title":"ModelPMD1000"},{"location":"api/models/#pyinst.models.ModelPMD1000.set_frequency","text":"Set optical frequency value. Note The PMD-1000 can only set to several discrete values on the ITU C-band: frequency = 191.6 + n*0.05, 0 <= n <= 86 If the frequency is not on the ITU grid, it will be set to the nearest valid value, and no exception will be raised. Parameters: Name Type Description Default frequency int | float optical frequency in THz. required Source code in pyinst\\models.py 5681 5682 5683 5684 5685 5686 5687 5688 5689 5690 5691 5692 5693 5694 5695 5696 5697 5698 5699 def set_frequency ( self , frequency : int | float ) -> None : \"\"\"Set optical frequency value. Note: The PMD-1000 can only set to several discrete values on the ITU C-band: frequency = 191.6 + n*0.05, 0 <= n <= 86 If the frequency is not on the ITU grid, it will be set to the nearest valid value, and no exception will be raised. Args: frequency: optical frequency in THz. \"\"\" if not self . min_frequency <= frequency <= self . max_frequency : raise ValueError ( f 'frequency is out of range: { frequency !r} ' ) ch = round (( frequency - 191.6 ) / 0.05 ) + 1 self . command ( '*CHC %03d #' % ch )","title":"set_frequency()"},{"location":"api/models/#pyinst.models.ModelPMD1000.set_pmd_value","text":"Note The pmd and sopmd setting of the PMD-1000 is not continuous. The pmd and sopmd will be set to the nearest supported values, so the real value will not be exactly the same with the setting values. Source code in pyinst\\models.py 5713 5714 5715 5716 5717 5718 5719 5720 5721 5722 5723 5724 def set_pmd_value ( self , pmd : int | float , sopmd : int | float ) -> None : \"\"\" Note: The pmd and sopmd setting of the PMD-1000 is not continuous. The pmd and sopmd will be set to the nearest supported values, so the real value will not be exactly the same with the setting values. \"\"\" if not 0 <= pmd <= 182.4 : raise ValueError ( f 'pmd is out of range: { pmd } ' ) if not 0 <= sopmd <= 8319.9 : raise ValueError ( f 'sopmd is out of range: { sopmd } ' ) self . command ( '*PMD:CON %.2f , %.2f #' % ( pmd , sopmd ))","title":"set_pmd_value()"},{"location":"api/models/#pyinst.models.ModelPSY101","text":"Bases: VisaInstrument , TypePOLC Source code in pyinst\\models.py 5152 5153 5154 5155 5156 5157 5158 5159 5160 5161 5162 5163 5164 5165 5166 5167 5168 5169 5170 5171 5172 5173 5174 5175 5176 5177 5178 5179 5180 5181 5182 5183 5184 5185 5186 5187 5188 5189 5190 5191 5192 5193 5194 5195 5196 5197 5198 5199 5200 5201 5202 5203 5204 5205 5206 5207 5208 5209 5210 5211 5212 5213 5214 5215 5216 5217 5218 5219 5220 5221 5222 5223 5224 5225 5226 5227 5228 5229 5230 5231 5232 5233 5234 5235 5236 5237 5238 5239 5240 5241 5242 5243 5244 5245 5246 5247 5248 5249 5250 5251 5252 5253 5254 5255 5256 5257 5258 5259 5260 5261 5262 5263 5264 class ModelPSY101 ( VisaInstrument , TypePOLC ): model = \"PSY-101\" brand = \"General Photonics\" details = { \"Wavelength Range\" : \"1500 ~ 1600 nm\" , \"Operating Power Range\" : \"-15 ~ 10 dBm\" } def __init__ ( self , resource_name : str , read_termination : str = '#' , write_termination : str = '' , ** kwargs ): super () . __init__ ( resource_name , read_termination , write_termination , ** kwargs ) def __format_result ( self , result : str ) -> str : return result [ 1 :] @property def min_frequency ( self ) -> float : return super () . min_frequency @property def max_frequency ( self ) -> float : return super () . max_frequency @property def min_wavelength ( self ) -> float : return 1500.0 @property def max_wavelength ( self ) -> float : return 1600.0 def get_frequency ( self ) -> float : return super () . get_frequency () def set_frequency ( self , frequency : int | float ) -> None : return super () . set_frequency ( frequency ) def get_wavelength ( self ) -> float : cmd = \"*WAV?\" wl = float ( self . __format_result ( self . query ( cmd ))) return wl def set_wavelength ( self , wavelength : int | float ) -> None : if not self . min_wavelength <= wavelength <= self . max_wavelength : raise ValueError ( f \"The parameter wavelength is out of range: { wavelength !r} \" ) cmd = f \"*WAV { wavelength : d } #\" err_code = self . __format_result ( self . query ( cmd )) if err_code != 'E00' : raise Error ( f 'Error code: { err_code } ' ) def _random_scramble ( self , state : bool , rate : Optional [ int | float ] = None ) -> None : \"\"\"Set random scrambling rate and state. Args: state: `True` = Enable scrambling, `False` = Disable scrambling. rate: The scrambling rate in Hz. \"\"\" if rate is not None : if not 1 <= rate <= 6000 : raise ValueError ( f \"Parameter rate is out of range: { rate !r} \" ) cmd1 = f \"*RAN:FRQ { rate : d } #\" err_code = self . __format_result ( self . query ( cmd1 )) if err_code != 'E00' : raise Error ( f 'Error code: { err_code } ' ) cmd2 = f \"*RAN:ENA { [ 'OFF' , 'ON' ][ state ] } #\" err_code = self . __format_result ( self . query ( cmd2 )) if err_code != 'E00' : raise Error ( f 'Error code: { err_code } ' ) def _saw_scramble ( self , state : bool , rate : Optional [ int | float ] = None ) -> None : \"\"\"Set saw wave scrambling rate and state. Args: state: `True` = Enable scrambling, `False` = Disable scrambling. rate: The scrambling rate in Hz. \"\"\" if rate is not None : if not 0.1 <= rate <= 500.0 : raise ValueError ( f \"Parameter rate is out of range: { rate !r} \" ) cmd1 = f \"*SAW:FRQ { rate : .1f } #\" err_code = self . __format_result ( self . query ( cmd1 )) if err_code != 'E00' : raise Error ( f 'Error code: { err_code } ' ) cmd2 = f \"*SAW:ENA { [ 'OFF' , 'ON' ][ state ] } #\" err_code = self . __format_result ( self . query ( cmd2 )) if err_code != 'E00' : raise Error ( f 'Error code: { err_code } ' ) def start_scrambling ( self , mode : str , rate : int | float , ** params ) -> None : \"\"\"Start scrambling with specified mode and speed. Args: mode: Scrambling mode. - `RANdom`: Random scrambling. - `SAW`: Saw wave scrambling. rate: Scrambling rate in Hz. params: Not used for PSY-101. \"\"\" if mode . upper () . startswith ( 'RAN' ): self . _random_scramble ( True , rate = rate ) if mode . upper () . startswith ( 'SAW' ): self . _saw_scramble ( True , rate = rate ) else : raise ValueError ( f \"Invalid mode: { mode !r} \" ) def stop_scrambling ( self ) -> None : self . _random_scramble ( False )","title":"ModelPSY101"},{"location":"api/models/#pyinst.models.ModelPSY101.start_scrambling","text":"Start scrambling with specified mode and speed. Parameters: Name Type Description Default mode str Scrambling mode. RANdom : Random scrambling. SAW : Saw wave scrambling. required rate int | float Scrambling rate in Hz. required params Not used for PSY-101. required Source code in pyinst\\models.py 5244 5245 5246 5247 5248 5249 5250 5251 5252 5253 5254 5255 5256 5257 5258 5259 5260 5261 def start_scrambling ( self , mode : str , rate : int | float , ** params ) -> None : \"\"\"Start scrambling with specified mode and speed. Args: mode: Scrambling mode. - `RANdom`: Random scrambling. - `SAW`: Saw wave scrambling. rate: Scrambling rate in Hz. params: Not used for PSY-101. \"\"\" if mode . upper () . startswith ( 'RAN' ): self . _random_scramble ( True , rate = rate ) if mode . upper () . startswith ( 'SAW' ): self . _saw_scramble ( True , rate = rate ) else : raise ValueError ( f \"Invalid mode: { mode !r} \" )","title":"start_scrambling()"},{"location":"api/models/#pyinst.models.ModelPSY201","text":"Bases: VisaInstrument , TypePOLC Source code in pyinst\\models.py 4951 4952 4953 4954 4955 4956 4957 4958 4959 4960 4961 4962 4963 4964 4965 4966 4967 4968 4969 4970 4971 4972 4973 4974 4975 4976 4977 4978 4979 4980 4981 4982 4983 4984 4985 4986 4987 4988 4989 4990 4991 4992 4993 4994 4995 4996 4997 4998 4999 5000 5001 5002 5003 5004 5005 5006 5007 5008 5009 5010 5011 5012 5013 5014 5015 5016 5017 5018 5019 5020 5021 5022 5023 5024 5025 5026 5027 5028 5029 5030 5031 5032 5033 5034 5035 5036 5037 5038 5039 5040 5041 5042 5043 5044 5045 5046 5047 5048 5049 5050 5051 5052 5053 5054 5055 5056 5057 5058 5059 5060 5061 5062 5063 5064 5065 5066 5067 5068 5069 5070 5071 5072 5073 5074 5075 5076 5077 5078 5079 5080 5081 5082 5083 5084 5085 5086 5087 5088 5089 5090 5091 5092 5093 5094 5095 5096 5097 5098 5099 5100 5101 5102 5103 5104 5105 5106 5107 5108 5109 5110 5111 5112 5113 5114 5115 5116 5117 5118 5119 5120 5121 5122 5123 5124 5125 5126 5127 5128 5129 5130 5131 5132 5133 5134 5135 5136 5137 5138 5139 5140 5141 5142 5143 5144 5145 5146 5147 5148 5149 class ModelPSY201 ( VisaInstrument , TypePOLC ): model = \"PSY-201\" brand = \"General Photonics\" details = { \"Wavelength Range\" : \"1480 ~ 1620 nm\" , \"Operating power range\" : \"-35 ~ 10 dBm\" } def __init__ ( self , resource_name : str , write_termination : str = ' \\r\\n ' , read_termination : str = ' \\r\\n ' , ** kwargs ): super ( ModelPSY201 , self ) . __init__ ( resource_name , write_termination = write_termination , read_termination = read_termination , ** kwargs ) @property def min_frequency ( self ) -> float : return super () . min_frequency @property def max_frequency ( self ) -> float : return super () . max_frequency @property def min_wavelength ( self ) -> float : return 1480.0 @property def max_wavelength ( self ) -> float : return 1620.0 def get_frequency ( self ) -> float : return super () . get_frequency () def set_frequency ( self , frequency : int | float ) -> None : return super () . set_frequency ( frequency ) def get_wavelength ( self ) -> float : cmd = \":CONFigure:WLENgth?\" wl = float ( self . query ( cmd )) return wl def set_wavelength ( self , wavelength : int | float ) -> None : \"\"\"Set optical wavelength value. Wavelength setting rounds to the nearest multiple of 5. Args: wavelength: The optical wavelength in nm. \"\"\" if not self . min_wavelength <= wavelength <= self . max_wavelength : raise ValueError ( f \"Parameter wavelength is out of range: { wavelength !r} \" ) cmd = f \":CONFigure:WLENgth { wavelength : d } \" self . command ( cmd ) def _discrete_scramble ( self , state : bool , rate : Optional [ int | float ] = None ) -> None : \"\"\"Set discrete scrambling rate and state. Args: state: `True` = Enable scrambling, `False` = Disable scrambling. rate: The scrambling rate in points/s. \"\"\" if rate is not None : if not 0.01 <= rate <= 20000 : raise ValueError ( f 'Parameter rate is out of range: { rate !r} ' ) cmd1 = f \":CONTrol:SCRamble:DISCrete:RATE { rate : .2f } \" self . command ( cmd1 ) cmd2 = f \":CONTrol:SCRamble:DISCrete:STATe { state : d } \" self . command ( cmd2 ) def _triangle_scramble ( self , state : bool , rate : Optional [ int | float ] = None ) -> None : \"\"\"Set triangle scrambling rate and state. Args: state: `True` = Enable scrambling, `False` = Disable scrambling. rate: The scrambling rate in 2\u03c0 rad/s. \"\"\" if rate is not None : if not 0.01 <= rate <= 2000 : raise ValueError ( f 'Parameter rate is out of range: { rate !r} ' ) cmd1 = f \":CONTrol:SCRamble:TRIangle:RATE { rate : .2f } \" self . command ( cmd1 ) cmd2 = f \":CONTrol:SCRamble:TRIangle:STATe { state : d } \" self . command ( cmd2 ) def _tornado_scramble ( self , state : bool , _type : Optional [ int ], rate : Optional [ int | float ]) -> None : \"\"\"Set tornado scrambling rate, type and state. Args: state: `True` = Enable scrambling, `False` = Disable scrambling. _type: The scrambling type of tornado. `0` = Fixed axis, `1` = Rotating axis. rate: The scrambling rate in Rev/s. \"\"\" if _type is not None : cmd1 = f \":CONTrol:SCRamble:TORNado:TYPE { _type : d } \" self . command ( cmd1 ) if rate is not None : if not 0.01 <= rate <= 2000 : raise ValueError ( f 'Parameter rate is out of range: { rate !r} ' ) cmd2 = f \":CONTrol:SCRamble:TORNado:RATE { rate : .2f } \" self . command ( cmd2 ) cmd3 = f \":CONTrol:SCRamble:TORNado:STATe { state : d } \" self . command ( cmd3 ) def get_sop ( self ) -> Tuple [ float , float , float ]: \"\"\"Query measured SOP (Stokes parameters) S1, S2, S3. Returns: The stokes parameters S1, S2, S3. \"\"\" cmd = \":MEASure:SOP? \" s1 , s2 , s3 = ( float ( i ) for i in self . query ( cmd ) . split ( ',' )) return s1 , s2 , s3 def get_dop ( self ) -> float : \"\"\"Query measured degree of polarization. Returns: The degree of polarization. \"\"\" cmd = ':MEASure:DOP?' dop = float ( self . query ( cmd )) return dop def set_sop ( self , s1 : int | float , s2 : int | float , s3 : int | float ) -> None : \"\"\"Set SOP by Stokes parameters and enable tracking. Args: s1: 1st dimention of the Stokes parameters. s2: 2nd dimention of the Stokes parameters. s3: 3rd dimention of the Stokes parameters. Tips: Stokes parameters are auto-normalized to unit vector before tracking: SOP will be set to `(s1/A, s2/A, s3/A)` where `A = sqrt(s1*s1, s2*s2, s3*s3)` Note: `s1=s2=s3=0` is not allowed. \"\"\" if s1 == s2 == s3 == 0 : raise ValueError ( \"s1=s2=s3=0 is not allowed.\" ) cmd = f \":CONTrol:SOP { s1 : .2f } , { s2 : .2f } , { s3 : .2f } \" self . command ( cmd ) def set_sop_in_spherical ( self , theta : int | float , phi : int | float ) -> None : \"\"\" Set SOP in spherical coordinates and enable tracking. Args: theta: 1st dimension in degree of the spherical coordinates. 0 to 360 (degrees). phi: 2nd dimention in degree of the spherical cordinates. 0 to 180 (degrees). \"\"\" if not 0 <= theta <= 360 : raise ValueError ( f \"Parameter theta is out of range: { theta !r} \" ) if not 0 <= phi <= 180 : raise ValueError ( f \"Parameter phi is out of range: { phi !r} \" ) cmd = f \":CONTrol:ANGLe { theta : .2f } , { phi : .2f } \" self . command ( cmd ) def start_scrambling ( self , mode : str , rate : int | float , ** params ) -> None : \"\"\"Start scrambling with specified mode and speed. Args: mode: Scrambling mode. - `DISCrete`: Discrete scrambling. - `TRIangle`: Triangle scrambling. - `TORNado`: Tornado scrambling. Additional scrambling parameter `_type` is required. rate: Scrambling rate. Different mode may have different units. params: Additional scrambling params if any. * `_type (int)`: For `TORNado` mode only. `0` = Fixed axis, `1` = Rotating axis. Note: Different mode has different unit for scrambling rate: - Discrete: points/s - Triangle: 2\u03c0 rad/s - Tornado: rev/s \"\"\" if mode . upper () . startswith ( 'DISC' ): self . _discrete_scramble ( True , rate = rate ) elif mode . upper () . startswith ( 'TRI' ): self . _triangle_scramble ( True , rate = rate ) elif mode . upper () . startswith ( 'TORN' ): self . _tornado_scramble ( True , _type = params [ '_type' ], rate = rate ) else : raise ValueError ( f \"Invalid mode: { mode !r} \" ) def stop_scrambling ( self ) -> None : self . _tornado_scramble ( False )","title":"ModelPSY201"},{"location":"api/models/#pyinst.models.ModelPSY201.get_dop","text":"Query measured degree of polarization. Returns: Type Description float The degree of polarization. Source code in pyinst\\models.py 5070 5071 5072 5073 5074 5075 5076 5077 5078 def get_dop ( self ) -> float : \"\"\"Query measured degree of polarization. Returns: The degree of polarization. \"\"\" cmd = ':MEASure:DOP?' dop = float ( self . query ( cmd )) return dop","title":"get_dop()"},{"location":"api/models/#pyinst.models.ModelPSY201.get_sop","text":"Query measured SOP (Stokes parameters) S1, S2, S3. Returns: Type Description Tuple [ float , float , float ] The stokes parameters S1, S2, S3. Source code in pyinst\\models.py 5060 5061 5062 5063 5064 5065 5066 5067 5068 def get_sop ( self ) -> Tuple [ float , float , float ]: \"\"\"Query measured SOP (Stokes parameters) S1, S2, S3. Returns: The stokes parameters S1, S2, S3. \"\"\" cmd = \":MEASure:SOP? \" s1 , s2 , s3 = ( float ( i ) for i in self . query ( cmd ) . split ( ',' )) return s1 , s2 , s3","title":"get_sop()"},{"location":"api/models/#pyinst.models.ModelPSY201.set_sop","text":"Set SOP by Stokes parameters and enable tracking. Parameters: Name Type Description Default s1 int | float 1st dimention of the Stokes parameters. required s2 int | float 2nd dimention of the Stokes parameters. required s3 int | float 3rd dimention of the Stokes parameters. required Tips Stokes parameters are auto-normalized to unit vector before tracking: SOP will be set to (s1/A, s2/A, s3/A) where A = sqrt(s1*s1, s2*s2, s3*s3) Note s1=s2=s3=0 is not allowed. Source code in pyinst\\models.py 5080 5081 5082 5083 5084 5085 5086 5087 5088 5089 5090 5091 5092 5093 5094 5095 5096 5097 5098 5099 5100 5101 5102 def set_sop ( self , s1 : int | float , s2 : int | float , s3 : int | float ) -> None : \"\"\"Set SOP by Stokes parameters and enable tracking. Args: s1: 1st dimention of the Stokes parameters. s2: 2nd dimention of the Stokes parameters. s3: 3rd dimention of the Stokes parameters. Tips: Stokes parameters are auto-normalized to unit vector before tracking: SOP will be set to `(s1/A, s2/A, s3/A)` where `A = sqrt(s1*s1, s2*s2, s3*s3)` Note: `s1=s2=s3=0` is not allowed. \"\"\" if s1 == s2 == s3 == 0 : raise ValueError ( \"s1=s2=s3=0 is not allowed.\" ) cmd = f \":CONTrol:SOP { s1 : .2f } , { s2 : .2f } , { s3 : .2f } \" self . command ( cmd )","title":"set_sop()"},{"location":"api/models/#pyinst.models.ModelPSY201.set_sop_in_spherical","text":"Set SOP in spherical coordinates and enable tracking. Parameters: Name Type Description Default theta int | float 1st dimension in degree of the spherical coordinates. 0 to 360 (degrees). required phi int | float 2nd dimention in degree of the spherical cordinates. 0 to 180 (degrees). required Source code in pyinst\\models.py 5104 5105 5106 5107 5108 5109 5110 5111 5112 5113 5114 5115 5116 def set_sop_in_spherical ( self , theta : int | float , phi : int | float ) -> None : \"\"\" Set SOP in spherical coordinates and enable tracking. Args: theta: 1st dimension in degree of the spherical coordinates. 0 to 360 (degrees). phi: 2nd dimention in degree of the spherical cordinates. 0 to 180 (degrees). \"\"\" if not 0 <= theta <= 360 : raise ValueError ( f \"Parameter theta is out of range: { theta !r} \" ) if not 0 <= phi <= 180 : raise ValueError ( f \"Parameter phi is out of range: { phi !r} \" ) cmd = f \":CONTrol:ANGLe { theta : .2f } , { phi : .2f } \" self . command ( cmd )","title":"set_sop_in_spherical()"},{"location":"api/models/#pyinst.models.ModelPSY201.set_wavelength","text":"Set optical wavelength value. Wavelength setting rounds to the nearest multiple of 5. Parameters: Name Type Description Default wavelength int | float The optical wavelength in nm. required Source code in pyinst\\models.py 4994 4995 4996 4997 4998 4999 5000 5001 5002 5003 5004 def set_wavelength ( self , wavelength : int | float ) -> None : \"\"\"Set optical wavelength value. Wavelength setting rounds to the nearest multiple of 5. Args: wavelength: The optical wavelength in nm. \"\"\" if not self . min_wavelength <= wavelength <= self . max_wavelength : raise ValueError ( f \"Parameter wavelength is out of range: { wavelength !r} \" ) cmd = f \":CONFigure:WLENgth { wavelength : d } \" self . command ( cmd )","title":"set_wavelength()"},{"location":"api/models/#pyinst.models.ModelPSY201.start_scrambling","text":"Start scrambling with specified mode and speed. Parameters: Name Type Description Default mode str Scrambling mode. DISCrete : Discrete scrambling. TRIangle : Triangle scrambling. TORNado : Tornado scrambling. Additional scrambling parameter _type is required. required rate int | float Scrambling rate. Different mode may have different units. required params Additional scrambling params if any. _type (int) : For TORNado mode only. 0 = Fixed axis, 1 = Rotating axis. required Note Different mode has different unit for scrambling rate: Discrete: points/s Triangle: 2\u03c0 rad/s Tornado: rev/s Source code in pyinst\\models.py 5118 5119 5120 5121 5122 5123 5124 5125 5126 5127 5128 5129 5130 5131 5132 5133 5134 5135 5136 5137 5138 5139 5140 5141 5142 5143 5144 5145 5146 def start_scrambling ( self , mode : str , rate : int | float , ** params ) -> None : \"\"\"Start scrambling with specified mode and speed. Args: mode: Scrambling mode. - `DISCrete`: Discrete scrambling. - `TRIangle`: Triangle scrambling. - `TORNado`: Tornado scrambling. Additional scrambling parameter `_type` is required. rate: Scrambling rate. Different mode may have different units. params: Additional scrambling params if any. * `_type (int)`: For `TORNado` mode only. `0` = Fixed axis, `1` = Rotating axis. Note: Different mode has different unit for scrambling rate: - Discrete: points/s - Triangle: 2\u03c0 rad/s - Tornado: rev/s \"\"\" if mode . upper () . startswith ( 'DISC' ): self . _discrete_scramble ( True , rate = rate ) elif mode . upper () . startswith ( 'TRI' ): self . _triangle_scramble ( True , rate = rate ) elif mode . upper () . startswith ( 'TORN' ): self . _tornado_scramble ( True , _type = params [ '_type' ], rate = rate ) else : raise ValueError ( f \"Invalid mode: { mode !r} \" )","title":"start_scrambling()"},{"location":"api/models/#pyinst.models.ModelTC3625","text":"Bases: RawSerialInstrument , TypeTS TC-36-25 is a TEC model by TE Technology. You may have to configure some parameters via the GUI provided by the vendor before your first use, this class will only perform the temperature control. Source code in pyinst\\models.py 3919 3920 3921 3922 3923 3924 3925 3926 3927 3928 3929 3930 3931 3932 3933 3934 3935 3936 3937 3938 3939 3940 3941 3942 3943 3944 3945 3946 3947 3948 3949 3950 3951 3952 3953 3954 3955 3956 3957 3958 3959 3960 3961 3962 3963 3964 3965 3966 3967 3968 3969 3970 3971 3972 3973 3974 3975 3976 3977 3978 3979 3980 3981 3982 3983 3984 3985 3986 3987 3988 3989 3990 3991 3992 3993 3994 3995 3996 3997 3998 3999 4000 4001 4002 4003 4004 4005 4006 4007 4008 4009 4010 4011 4012 4013 4014 4015 class ModelTC3625 ( RawSerialInstrument , TypeTS ): \"\"\"TC-36-25 is a TEC model by TE Technology. You may have to configure some parameters via the GUI provided by the vendor before your first use, this class will only perform the temperature control. \"\"\" model = \"TC-36-25\" brand = \"TE Technology\" def __init__ ( self , resource_name , baudrate = 9600 , read_termination = '^' , write_termination = ' \\r ' , ** kwargs ): \"\"\" Args: resource_name: Serial port name. baudrate: Baud rate such as 9600 or 115200 etc.. read_termination: Read termination character. write_termination: Write termination character. \"\"\" super ( ModelTC3625 , self ) . __init__ ( resource_name , baudrate = baudrate , read_termination = read_termination , write_termination = write_termination , ** kwargs ) @property def ts_type ( self ) -> TemperatureSourceType : return TemperatureSourceType . TEC def formatted_query ( self , cmd_code : int , value : int = 0 ) -> int : \"\"\" Send a formated command to the TEC and return the result value. Args: cmd_code: Comand code is an int between 0 and 0xFF. value: An int value sent with the command. Defaults to 0 if it is not needed. Between -0x80000000 and 0x7FFFFFFF. Returns: The \"\"\" if not 0 <= value <= 0xFF : raise ValueError ( 'Parameter cmd_code out of range: {!r} ' . format ( cmd_code )) if not - 0x80000000 <= value <= 0x7FFFFFFF : raise ValueError ( 'Parameter value out of range: {!r} ' . format ( value )) STX = '*' # Start of text character that always prepend to the cmd. ADDR = 0 # The address of this device is fixed to 0 cmd_body = ' {addr:02x}{cmd_code:02x}{val:08x} ' . format ( addr = ADDR , cmd_code = cmd_code , val = signed_to_unsigned ( value , byte_count = 4 )) check_sum = calc_check_sum ( cmd_body . encode ()) cmd = ' {pre}{cmd_body}{check_sum:02x} ' . format ( pre = STX , cmd_body = cmd_body , check_sum = check_sum ) result = self . query ( cmd )[ 1 :] result_content = result [ 0 : - 2 ] result_check_sum = int ( result [ - 2 :], base = 16 ) calculated_check_sum = calc_check_sum ( result_content . encode ()) if result_check_sum != calculated_check_sum : raise ValueError ( \"Mismatched checksum of the reply.\" ) if result_content == \"X\" * 8 : raise ValueError ( \"Mismatched checksum of the command.\" ) result_value = unsigned_to_signed ( int ( result_content , base = 16 ), 4 ) return result_value # def check_connection(self) -> ConnectionStatus: # try: # self.get_target_temp() # return ConnectionStatus(True) # except Exception as e: # return ConnectionStatus(False, e.args[0] if e.args else None) def set_target_temp ( self , value : int | float ) -> None : cmd_value = round ( value * 100 ) rtn_value = self . formatted_query ( 0x1c , cmd_value ) if cmd_value != rtn_value : raise ValueError ( 'The return value mismatched with the cmd value: {!r} / {!r} ' . format ( rtn_value , cmd_value )) def get_target_temp ( self ) -> float : rtn_value = self . formatted_query ( 0x03 ) t = rtn_value / 100 return t def get_current_temp ( self ) -> float : rtn_value = self . formatted_query ( 0x01 ) t = rtn_value / 100 return t def set_temp_unit ( self , unit : TemperatureUnit ) -> None : unit = TemperatureUnit ( unit ) rtn_value = self . formatted_query ( 0x32 , unit . value ) if rtn_value != unit . value : raise ValueError ( 'The return value mismatched with the cmd value: {!r} / {!r} ' . format ( rtn_value , unit )) def get_temp_unit ( self ) -> TemperatureUnit : rtn_value = self . formatted_query ( 0x4b ) return TemperatureUnit ( rtn_value )","title":"ModelTC3625"},{"location":"api/models/#pyinst.models.ModelTC3625.__init__","text":"Parameters: Name Type Description Default resource_name Serial port name. required baudrate Baud rate such as 9600 or 115200 etc.. 9600 read_termination Read termination character. '^' write_termination Write termination character. '\\r' Source code in pyinst\\models.py 3927 3928 3929 3930 3931 3932 3933 3934 3935 3936 3937 3938 3939 3940 3941 3942 3943 3944 def __init__ ( self , resource_name , baudrate = 9600 , read_termination = '^' , write_termination = ' \\r ' , ** kwargs ): \"\"\" Args: resource_name: Serial port name. baudrate: Baud rate such as 9600 or 115200 etc.. read_termination: Read termination character. write_termination: Write termination character. \"\"\" super ( ModelTC3625 , self ) . __init__ ( resource_name , baudrate = baudrate , read_termination = read_termination , write_termination = write_termination , ** kwargs )","title":"__init__()"},{"location":"api/models/#pyinst.models.ModelTC3625.formatted_query","text":"Send a formated command to the TEC and return the result value. Parameters: Name Type Description Default cmd_code int Comand code is an int between 0 and 0xFF. required value int An int value sent with the command. Defaults to 0 if it is not needed. Between -0x80000000 and 0x7FFFFFFF. 0 Returns: Type Description int The Source code in pyinst\\models.py 3950 3951 3952 3953 3954 3955 3956 3957 3958 3959 3960 3961 3962 3963 3964 3965 3966 3967 3968 3969 3970 3971 3972 3973 3974 3975 3976 3977 3978 3979 3980 3981 3982 def formatted_query ( self , cmd_code : int , value : int = 0 ) -> int : \"\"\" Send a formated command to the TEC and return the result value. Args: cmd_code: Comand code is an int between 0 and 0xFF. value: An int value sent with the command. Defaults to 0 if it is not needed. Between -0x80000000 and 0x7FFFFFFF. Returns: The \"\"\" if not 0 <= value <= 0xFF : raise ValueError ( 'Parameter cmd_code out of range: {!r} ' . format ( cmd_code )) if not - 0x80000000 <= value <= 0x7FFFFFFF : raise ValueError ( 'Parameter value out of range: {!r} ' . format ( value )) STX = '*' # Start of text character that always prepend to the cmd. ADDR = 0 # The address of this device is fixed to 0 cmd_body = ' {addr:02x}{cmd_code:02x}{val:08x} ' . format ( addr = ADDR , cmd_code = cmd_code , val = signed_to_unsigned ( value , byte_count = 4 )) check_sum = calc_check_sum ( cmd_body . encode ()) cmd = ' {pre}{cmd_body}{check_sum:02x} ' . format ( pre = STX , cmd_body = cmd_body , check_sum = check_sum ) result = self . query ( cmd )[ 1 :] result_content = result [ 0 : - 2 ] result_check_sum = int ( result [ - 2 :], base = 16 ) calculated_check_sum = calc_check_sum ( result_content . encode ()) if result_check_sum != calculated_check_sum : raise ValueError ( \"Mismatched checksum of the reply.\" ) if result_content == \"X\" * 8 : raise ValueError ( \"Mismatched checksum of the command.\" ) result_value = unsigned_to_signed ( int ( result_content , base = 16 ), 4 ) return result_value","title":"formatted_query()"}]}